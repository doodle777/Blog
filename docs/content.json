{"meta":{"title":"MAY THE FORCE BE WITH YOU","subtitle":null,"description":null,"author":"Duan Xu","url":"http://blog.duanxu.tech"},"pages":[{"title":"","date":"2018-12-07T12:17:50.090Z","updated":"2018-12-07T12:17:50.090Z","comments":false,"path":"tags/index.html","permalink":"http://blog.duanxu.tech/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-12-07T12:18:00.978Z","updated":"2018-12-07T12:18:00.978Z","comments":false,"path":"categories/index.html","permalink":"http://blog.duanxu.tech/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"搭建Git服务器","slug":"2017/2017-08-31-搭建Git服务器","date":"2017-08-31T06:55:30.000Z","updated":"2018-12-07T12:53:27.561Z","comments":true,"path":"2017/08/31/2017/2017-08-31-搭建Git服务器/","link":"","permalink":"http://blog.duanxu.tech/2017/08/31/2017/2017-08-31-搭建Git服务器/","excerpt":"","text":"content{:toc} GitHub就是一个免费托管开源代码的远程仓库。托管在GitHUb上的。 搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。 假设你已经有sudo权限的用户账号，下面，正式开始安装。 Step1 安装git1$ sudo apt-get install git Step2 创建一个git用户，用来运行git服务1$ sudo adduser git Step3 创建证书登录：对于每个需要登录的用户，需要收集用户的公钥。输入命令：-al ~/.ssh```，如果列表中有文件```id_rsa.pub```或```id_dsa.pub```，那么这个文件就是用户的公钥，否则需要生成一个公钥：1234567891011```shell$ ssh-keygen -t rsa -C \"xxx@yyy.com\"Generating public/private rsa key pair.Enter file in which to save the key (/Users/xxxx/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /Users/xxxx/.ssh/id_rsa.Your public key has been saved in /Users/xxxx/.ssh/id_rsa.pub.The key fingerprint is:-------------------------------------- xxxx@yyy.com 之后，在id_rsa.pub```等文件，其中```id_rsa.pub```便是我们需要的公钥文件。收集所有需要登录的用户的公钥，把所有公钥导入到服务器的```/home/git/.ssh/authorized_keys```文件里，一行一个。123456#### Step4 初始化Git仓库先选定一个目录作为Git仓库，假定是```/gitRepo/sample.git```，在```/gitRepo```目录下输入命令：```shell$ sudo git init --bare sample.git Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：1$ sudo chown -R git:git sample.git Step5 禁用shell登录出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑12```shellgit:x:1001:1001:,,,:/home/git:/bin/bash 改为：1git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。 Step6 克隆远程仓库现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：123$ git clone git@server:/gitRepo/sample.gitCloning into 'sample'...warning: You appear to have cloned an empty repository. 剩下的push操作就像我们平时用GitHub一样了。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.duanxu.tech/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.duanxu.tech/tags/Linux/"},{"name":"Git","slug":"Git","permalink":"http://blog.duanxu.tech/tags/Git/"}]},{"title":"Ubuntu下Thunderbird邮件ExQuilla插件license过期解决办法","slug":"2017/2017-08-20-Ubuntu下Thunderbird邮件ExQuilla插件license过期解决办法","date":"2017-08-20T06:41:30.000Z","updated":"2018-12-06T19:56:06.000Z","comments":true,"path":"2017/08/20/2017/2017-08-20-Ubuntu下Thunderbird邮件ExQuilla插件license过期解决办法/","link":"","permalink":"http://blog.duanxu.tech/2017/08/20/2017/2017-08-20-Ubuntu下Thunderbird邮件ExQuilla插件license过期解决办法/","excerpt":"","text":"content{:toc} Linux上只用Web版处理邮件，就是因为找不到太好的能支持Exchange的邮件客户端。在网上无意中发现了ExQuilla 这个Thunderbird的插件，试用了一下还是不错的，很方便，不过只能免费试用60天。 网上能找到的解决办法都是用老版本的Thunderbird，搭配老版本的ExQuilla，但版本都太老了点。 另外一种办法是破解license，原来的注册码的结构是：1EX0,*@*,2015-03-19,80324c6d8724c3e4cd0111b51a5718ad 可以看到，注册码被用逗号分成了四个部分： 第一部分是注册类型，EX0是免费给的试用类型，我不知道EX1、EX2是什么情况，但试了下，EX1是可以用的 第二部分是邮件，@是免费给的60天试用的，这里要填有效的Exchange邮箱，可以在选项里Valid Emails里看到 第三部分是license过期日期。 第四部分是校验码，分别是前三个部分再加上**123456 例如，注册类型EX1、Exchange邮箱xxx@xxx.com，到期日期2016-12-31(注意这里的到期日期是未来你想用到什么时候)，可以计算出MD5的值EX1,xxx@xxx.com,2016-12-31,356B4B5C将上面字符串(邮件填写自己的，日期是到期时间)，用md5工具加密，生成加密串，这个加密串是32位的。在线MD5加密工具:[站长之家MD5加密][2] 把生成的加密串放到注册码的第四部分如下： EX1,xxx@xxx.com,2016-12-31,4decad8da20e0118311e5861775eb6a7`把这个替换原来的注册码就成功了，本例中可以一直用到2016-12-31Thunderbird -&gt; Tools -&gt; ExQuilla for Microsoft Exchange -&gt; ExQuilla license options -&gt; 在顶部输入栏内，替换新的完整的注册码，重启Thunderbird即可。","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://blog.duanxu.tech/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://blog.duanxu.tech/tags/Ubuntu/"},{"name":"Thunderbird","slug":"Thunderbird","permalink":"http://blog.duanxu.tech/tags/Thunderbird/"},{"name":"ExQuilla","slug":"ExQuilla","permalink":"http://blog.duanxu.tech/tags/ExQuilla/"}]},{"title":"Java集合框架学习笔记(1) ArrayList","slug":"2017/2017-05-01-JAVA集合框架学习笔记(1)-ArrayList","date":"2017-05-01T11:45:30.000Z","updated":"2018-12-07T12:37:18.046Z","comments":true,"path":"2017/05/01/2017/2017-05-01-JAVA集合框架学习笔记(1)-ArrayList/","link":"","permalink":"http://blog.duanxu.tech/2017/05/01/2017/2017-05-01-JAVA集合框架学习笔记(1)-ArrayList/","excerpt":"","text":"content{:toc} 类定义123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;&#125; ArrayList 是Java集合框架中最常用的一类，","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.duanxu.tech/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.duanxu.tech/tags/Java/"},{"name":"Framework","slug":"Framework","permalink":"http://blog.duanxu.tech/tags/Framework/"},{"name":"ArrayList","slug":"ArrayList","permalink":"http://blog.duanxu.tech/tags/ArrayList/"}]},{"title":"Java集合框架学习笔记(0) Overview","slug":"2017/2017-05-01-JAVA集合框架学习笔记(0)-Overview","date":"2017-05-01T11:29:30.000Z","updated":"2018-12-07T12:37:12.021Z","comments":true,"path":"2017/05/01/2017/2017-05-01-JAVA集合框架学习笔记(0)-Overview/","link":"","permalink":"http://blog.duanxu.tech/2017/05/01/2017/2017-05-01-JAVA集合框架学习笔记(0)-Overview/","excerpt":"","text":"content{:toc} Collection List AbstractList Vector Stack ArrayList LinkedList Set AbstractSet HashSet LinkedHashSet TreeSet Map AbstractMap HashMap LinkedHashMap WeakHashMap HashTable IdentityHashMap TreeMap","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.duanxu.tech/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.duanxu.tech/tags/Java/"},{"name":"Framework","slug":"Framework","permalink":"http://blog.duanxu.tech/tags/Framework/"},{"name":"Collection","slug":"Collection","permalink":"http://blog.duanxu.tech/tags/Collection/"}]},{"title":"[转]Java核心技术点之注解","slug":"2017/2017-03-30-转-Java核心技术点之注解","date":"2017-03-30T12:45:30.000Z","updated":"2018-12-07T12:36:52.249Z","comments":true,"path":"2017/03/30/2017/2017-03-30-转-Java核心技术点之注解/","link":"","permalink":"http://blog.duanxu.tech/2017/03/30/2017/2017-03-30-转-Java核心技术点之注解/","excerpt":"","text":"content{:toc} 原文链接：Java核心技术点之注解 本博文是对Java中注解相关知识点的简单总结，若有叙述不清晰或是不准确的地方，希望大家可以指正，谢谢大家：） 一、什么是注解我们大家都知道Java代码中使用注释是为了向以后阅读这份代码的人解释说明一些事情，注解是注释的升级版，它可以向编译器、虚拟机等解释说明一些事情。比如我们非常熟悉的@Override就是一种元注解，它的作用是告诉编译器它所注解的方法是重写父类的方法，这样编译器就会去检查父类是否存在这个方法，以及这个方法的签名与父类是否相同。 也就是说，注解是描述Java代码的代码，它能够被编译器解析，注解处理工具在运行时也能够解析注解。我们在Java源文件中使用注释，是为了以后我们或他人再来读这段代码时，能够更好地理解它。Javadoc工具可以解析我们在源代码中为类、方法、变量等添加的描述信息，并根据这些描述信息自动生成一个HTML文档，这些自动生成的文档即可作为API帮助文档。只要我们为类、方法等添加的描述信息符合Javadoc要求的语法，我们就能够使用Javadoc工具根据我们的描述信息自动生成一个帮助文档。而注解比java注释和Javadoc要强大得多，它们三者之间的重大的区别在于，Java注释和Javadoc描述所发挥的作用仅仅到编译时就止步了，而注解直到运行时都能够发挥作用。 我们知道，使用“transient”关键字可以告诉编译器这个域不可序列化。相比于用”transient“这样的关键字修饰一个属性，注解为我们提供了为类/方法/属性/变量添加描述信息的更通用的方式，而这些描述信息对于开发者、自动化工具、Java编译器和Java运行时来说都是有意义的，也就是说他们都能“读懂”注解信息。”transient“关键字是一个修饰符，而注解也是一种修饰符。除了传递信息，我们也可以使用注解生成代码。我们可以使用注解，然后让注解解析工具来解析它们，以此来生成一些”模板化“的代码。比如Hibernate、Spring、Axis这些框架大量使用了注解，来避免一些重复的工作。 二、元注解元注解即用来描述注解的注解，比如以下代码中我们使用“@Target”元注解来说明MethodInfo这个注解只能应用于对方法进行注解： 1234@Target(ElementType.METHOD)public @interface MethodInfo &#123; ...&#125; 下面我们来具体介绍一下几种元注解。 1. Documented当一个注解类型被@Documented元注解所描述时，那么无论在哪里使用这个注解，都会被Javadoc工具文档化。我们来看一下它的定义： 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented &#123;&#125; 我们从以上代码中可以看到，定义注解使用@interface关键字，这就好比我们定义类时使用class关键字，定义接口时使用interface关键字一样，注解也是一种类型。这个元注解被@Documented修饰，表示它本身也会被文档化。@Retention元注解的值RetentionPolicy.RUNTIME表示@Documented这个注解能保留到运行时；@Target元注解的值ElementType.ANNOTATION_TYPE表示@Documented这个注解只能够用来描述注解类型。 2. Inherited 表明被修饰的注解类型是自动继承的。具体解释如下：若一个注解类型被Inherited元注解所修饰，则当用户在一个类声明中查询该注解类型时，若发现这个类声明中不包含这个注解类型，则会自动在这个类的父类中查询相应的注解类型，这个过程会被重复，直到该注解类型被找到或是查找完了Object类还未找到。这个元注解的定义如下： 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Inherited &#123;&#125; 我们可以看到这个元注解类型被@Documented所注解，能够保留到运行时，只能用来描述注解类型。 3. Retention我们在上面已经见到个这个元注解，它表示一个注解类型会被保留到什么时候，比如以下代码表示Developer注解会被保留到运行时： 1234@Retention(RetentionPolicy.RUNTIME)public @interface Developer &#123; String value();&#125; @Retention元注解的定义如下： 123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123; RetentionPolicy value();&#125; 我们在使用@Retention时，后面括号里的内容即表示他的取值，从以上定义我们可以看到，取值的类型为RetentionPolicy，这是一个枚举类型，它可以取以下值： SOURCE：表示在编译时这个注解会被移除，不会包含在编译后产生的class文件中； CLASS：表示这个注解会被包含在class文件中，但在运行时会被移除； RUNTIME：表示这个注解会被保留到运行时，在运行时可以JVM访问到，我们可以在运行时通过反射解析这个注解。 4. Target这个元注解说明了被修饰的注解的应用范围，也就是被修饰的注解可以用来注解哪些程序元素，它的定义如下： 123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; ElementType[] value();&#125; 从以上定义我们可以看到它也会保留到运行时，而且它的取值是为ElementType[]类型（一个数组，意思是可以指定多个值），ElementType是一个枚举类型，它可以取以下值： TYPE：表示可以用来注解类、接口、注解类型或枚举类型； PACKAGE：可以用来注解包； PARAMETER：可以用来注解参数； ANNOTATION_TYPE：可以用来注解 注解类型； METHOD：可以用来注解方法； FIELD：可以用来注解属性（包括枚举常量）； CONSTRUCTOR：可以用来注解构造器； LOCAL_VARIABLE：可用来注解局部变量。 三、常见内建注解Java本身内建了一些注解，下面我们来介绍一下我们在日常开发中比较常见的注解：@Override、@Deprecated、@SuppressWarnings。相信我们大家或多或少都使用过这三个注解，下面我们一起再重新认识一下它们。 1. @Override注解我们先来看一下这个注解类型的定义： 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; 从它的定义我们可以看到，这个注解可以被用来修饰方法，并且它只在编译时有效，在编译后的class文件中便不再存在。这个注解的作用我们大家都不陌生，那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。 2. @Deprecated这个注解的定义如下： 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;&#125; 从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。 3. @SuppressWarnings这个注解我们也比较常用到，先来看下它的定义： 12345@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123; String[] value();&#125; 它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为String[]。它的作用是告诉编译器忽略指定的警告信息，它可以取的值如下所示： deprecation：忽略使用了废弃的类或方法时的警告； unchecked：执行了未检查的转换； fallthrough：swich语句款中case忘加break从而直接“落入”下一个case； path：类路径或原文件路径等不存在； serial：可序列化的类缺少serialVersionUID； finally：存在不能正常执行的finally子句； all：以上所有情况产生的警告均忽略。 这个注解的使用示例如下： 12@SuppressWarning(value=&#123;\"deprecation\", \"unchecked\"&#125;)public void myMethos() &#123;...&#125; 通过使用以上注解，我们告诉编译器忽略myMethod方法中由于使用了废弃的类或方法或是做了未检查的转换而产生的警告。 四、自定义注解我们可以创建我们自己的注解类型并使用它。请看下面的示例： 123456789@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Inheritedpublic @interface MethodInfo &#123; String author() default \"absfree\"; String date(); int version() default 1;&#125; 在自定义注解时，有以下几点需要我们了解： 注解类型是通过”@interface“关键字定义的；在”注解体“中，所有的方法均没有方法体且只允许public和abstract这两种修饰符号（不加修饰符缺省为public），注解方法不允许有throws子句；注解方法的返回值只能为以下几种：原始数据类型）, String, Class, 枚举类型, 注解和它们的一维数组，可以为方法指定默认返回值。 我们再把上面提到过的@SuppressWarnings这个注解类型的定义拿出来看一下，这个注解类型是系统为我们定义好的，它的定义如下： 12345@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123; String[] value();&#125; 我们可以看到，它只定义了一个注解方法value()，它的返回值类型为String[]，没有指定默认返回值。我们使用@SuppressWarnings这个注解所用的语法如下： 1@SuppressWarnings(value=&#123;\"value1\", \"value2\", ...&#125;) 也就是在注解类型名称后的括号内为每个注解方法指定返回值就可以使用这个注解。下面我们来看看怎么使用我们自定义的注解类型@MethodInfo： 123456public class AnnotationTest &#123; @MethodInfo(author=\"absfree\", date=\"20160410\") public static void main(String[] args) &#123; System.out.println(\"Using custom annotation...\"); &#125;&#125; 那么现在问题来了，我们使用的自定义注解对于编译器或是虚拟机来说是有意义的吗（编译器或是虚拟机能读懂吗）？显然我们什么都不做的话，编译器或者虚拟机是读不懂我们的自定义注解的。下面我们来介绍以下注解的解析，让编译器或虚拟机能够读懂我们的自定义注解。 五、注解的解析1. 编译时解析编译时注解指的是@Retention的值为CLASS的注解，对于这类注解的解析，我们只需做以下两件事： 自定义类继承 AbstractProcessor类； 重写其中的 process 函数。 实际上，编译器在编译时会自动查找所有继承自 AbstractProcessor 的类，然后调用他们的 process 方法。因此我们只要做好上面两件事，编译器就会主动去解析我们的编译时注解。现在，我们把上面定义的MethodInfo的Retention改为CLASS，我们就可以按照以下代码来解析它： 1234567891011121314@SupportedAnnotationTypes(&#123; \"com.custom.customannotation.MethodInfo\" &#125;)public class MethodInfoProcessor extends AbstractProcessor &#123; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) &#123; HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); for (TypeElement typeElement : annotations) &#123; for (Element element : env.getElementsAnnotatedWith(typeElement)) &#123; MethodInfo methodInfo = element.getAnnotation(MethodInfo.class); map.put(element.getEnclosingElement().toString(), methodInfo.author()); &#125; &#125; return false; &#125;&#125; @SupportedAnnotationTypes注解描述了Processor要解析的注解的名字。process 函数的annotations参数表示 表示待处理的注解集，env表示当前或是之前的运行环境。process函数的返回值表示annotations中的注解是否被这个Processor接受。 运行时注解解析 首先我们把MethodInfo注解类型中Retention的值改回原来的RUNTIME，接下来我们介绍如何通过反射机制在运行时解析我们的自定义注解类型。 java.lang.reflect包中有一个AnnotatedElement接口，这个接口定义了用于获取注解信息的几个方法： 1234T getAnnotation(Class annotationClass) //返回该程序元素的指定类型的注解，若不存在这个类型的注解则返回nullAnnotation[] getAnnotations() //返回修饰该程序元素的所有注解Annotation[] getDeclaredAnnotations() //返回直接修饰该元素的所有注解boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) //当该程序元素被指定类型注解修饰时，返回true，否则返回false 解析我们上面的自定义注解MethodInfo的相关示例代码如下(AnnotationParser.java)： 123456789101112131415161718public class AnnotationParser &#123; public static void main(String[] args) &#123; try &#123; Class cls = AnnotationTest.class; for (Method method : cls.getMethods()) &#123; MethodInfo methodInfo = method.getAnnotation(MethodInfo.class); if (methodInfo != null) &#123; System.out.println(\"method name:\" + method.getName()); System.out.println(\"method author:\" + methodInfo.author()); System.out.println(\"method date:\" + methodInfo.date()); System.out.println(\"method version:\" + methodInfo.version()); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行以上代码我们可以得到以下输出： method name:mainmethod author:absfreemethod date:20160410method version:1 这说明我们已经成功解析了自定义注解。关于注解有点我们需要明确的是，作为描述代码本身的一种元数据，注解是一种”被动“的信息。也就是说，必须由编译器或虚拟机来“主动”解析它，它才能发挥自己的作用。 六、参考资料 Java Documention 公共技术点之Java注解 Java 注解","categories":[{"name":"Repost","slug":"Repost","permalink":"http://blog.duanxu.tech/categories/Repost/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.duanxu.tech/tags/Java/"},{"name":"Annotation","slug":"Annotation","permalink":"http://blog.duanxu.tech/tags/Annotation/"}]},{"title":"[转]一起写一个JSON解析器","slug":"2017/2017-03-30-转-一起写一个JSON解析器","date":"2017-03-30T12:45:30.000Z","updated":"2018-12-07T12:36:56.754Z","comments":true,"path":"2017/03/30/2017/2017-03-30-转-一起写一个JSON解析器/","link":"","permalink":"http://blog.duanxu.tech/2017/03/30/2017/2017-03-30-转-一起写一个JSON解析器/","excerpt":"","text":"content{:toc} 原文链接：一起写一个JSON解析器 【本篇博文会介绍JSON解析的原理与实现，并一步一步写出来一个简单但实用的JSON解析器，项目地址：SimpleJSON。希望通过这篇博文，能让我们以后与JSON打交道时更加得心应手。由于个人水平有限，叙述中难免存在不准确或是不清晰的地方，希望大家可以指正：）】 一、JSON解析器介绍相信大家在平时的开发中没少与JSON打交道，那么我们平常使用的一些JSON解析库都为我们做了哪些工作呢？这里我们以知乎日报API返回的JSON数据来介绍一下两个主流JSON解析库的用法。我们对地址 http://news-at.zhihu.com/api/4/news/latest进行GET请求，返回的JSON响应的整体结构如下： 123456789101112131415161718192021222324252627&#123; date: \"20140523\", stories: [ &#123; images:[\"http:\\/\\/pic1.zhimg.com\\/4e7ecded780717589609d950bddbf95c.jpg\"] type: 0, id: 3930445, ga_prefix: \"052321\", title: \"中国古代家具发展到今天有两个高峰，一个两宋一个明末（多图）\", &#125;, ... ], top_stories: [ &#123; image:\"http:\\/\\/pic4.zhimg.com\\/8f209bcfb5b6e0625ca808e43c0a0a73.jpg\", type:0, id:8314043, ga_prefix:\"051717\", title:\"怎样才能找到自己的兴趣所在，发自内心地去工作？\" &#125;, ... ] &#125; 以上JSON响应表示的是某天的最新知乎日报内容。顶层的date的值表示的是日期；stories的值是一个数组，数组的每个元素又包含images、type、id等域；top_stories的值也是一个数组，数组元素的结构与stories类似。我们先把把以上返回的JSON数据表示为一个model类： 12345678910111213141516171819202122232425public class LatestNews &#123; private String date; private List&lt;TopStory&gt; top_stories; private List&lt;Story&gt; stories; //省略LatestNews类的getter与setter public static class TopStory &#123; private String image; private int type; private int id; private String title; //省略TopStory类的getter与setter &#125; public static class Story implements Serializable &#123; private List&lt;String&gt; images; private int type; private int id; private String title; //省略Story类的getter与setter &#125;&#125; 在以上的代码中，我们定义的域与返回的JSON响应的键一一对应。那么接下来我们就来完成JSON响应的解析吧。首先我们使用org.json包来完成JSON的解析。相关代码如下： 12345678910111213141516171819202122232425262728293031323334public class JSONParsingTest &#123; public static final String urlString = \"http://news-at.zhihu.com/api/4/news/latest\"; public static void main(String[] args) throws Exception &#123; try &#123; String jsonString = new String(HttpUtil.get(urlString)); JSONObject latestNewsJSON = new JSONObject(jsonString); String date = latestNewsJSON.getString(\"date\"); JSONArray top_storiesJSON = latestNewsJSON.getJSONArray(\"top_stories\"); LatestNews latest = new LatestNews(); List&lt;LatestNews.TopStory&gt; stories = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; top_storiesJSON.length(); i++) &#123; LatestNews.TopStory story = new LatestNews.TopStory(); story.setId(((JObject) top_storiesJSON.get(i)).getInt(\"id\")); story.setType(((JObject) top_storiesJSON.get(i)).getInt(\"type\")); story.setImage(((JObject) top_storiesJSON.get(i)).getString(\"image\")); story.setTitle(((JObject) top_storiesJSON.get(i)).getString(\"title\")); stories.add(story); &#125; latest.setDate(date); System.out.println(\"date: \" + latest.getDate()); for (int i = 0; i &lt; stories.size(); i++) &#123; System.out.println(stories.get(i)); &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 相信Android开发的小伙伴对org.json都不陌生，因为Android SDK中提供的JSON解析类库就是org.json，要是使用别的开发环境我们可能就需要手动导入org.json包。 第5行我们调用了HttpUtil.get方法来获取JSON格式的响应字符串，HttpUtil是我们封装的一个用于网络请求的静态代码库，代码见这里： 接着在第6行，我们以JSON字符串为参数构造了一个JSONObject对象；在第7行我们调用JSONObject的实例方法getString根据键名“date”获取了date对应的值并保存在了一个String变量中。 在第8行我们调用了JSONObject的getJSONArray方法来从JSONObject对象中获取一个JSON数组，这个JSON数组的每个元素均为JSONObject（代表了一个TopStory)，每个JSONObject都可以通过在其上调用getInt、getString等方法获取type、title等键的值。正如我们在第14到21行所做的，我们通过一个循环读取JSONArray的每个JSONObject中的title、id、type、image域的值，并把他们写入TopStory对象的对应实例域。 我们可以看到，当返回的JSON响应结构比较复杂时，使用org.json包来解析响应比较繁琐。那么我们看看如何使用gson（Google出品的JSON解析库，被广泛应用于Android开发中）来完成相同的工作： 12345678910111213public class GsonTest &#123; public static final String urlString = \"http://news-at.zhihu.com/api/4/news/latest\"; public static void main(String[] args) &#123; LatestNews latest = new LatestNews(); String jsonString = new String(HttpUtil.get(urlString)); latest = (new Gson()).fromJson(jsonString, LatestNews.class); System.out.println(latest.getDate()); for (int i = 0; i &lt; latest.getTop_stories().size(); i++) &#123; System.out.println(latest.getTop_stories().get(i)); &#125; &#125;&#125; 我们可以看到，使用gson完成同样的工作只需要一行代码。那么让我们一起来看一下gson是如何做到的。在上面的代码中，我们调用了Gson对象的fromJson方法，传入了返回的JSON字符串和Latest.class作为参数。看到Latest.class，我们就大概能够知道fromJson方法的内部工作机制了。可以通过反射获取到LatestNews的各个实例域，然后帮助我们读取并填充这些实例域。那么fromJson怎么知道我们要填充LatestNews的哪些实例域呢？实际上我们必须保证LatestNews的域的名字与JSON字符串中对应的键的名字相同，这样gson就能够把我们的model类与JSON字符串“一一对应“起来，也就是说我们要保证我们的model类与JSON字符串具有相同的层级结构，这样gson就可以根据名称从JSON字符串中为我们的实例域寻找一个对应的值。我们可以做个小实验：把LatestNews中TopStory的title实例域的名字改为title1，这时再只执行以上程序，会发现每个story的title1域均变为null了。 通过上面的介绍，我们感受到了JSON解析库带给我们的便利，接下来我们一起来实现org.json包提供给我们的基本JSON解析功能，然后再进一步尝试实现gson提供给我们的更方便快捷的JSON解析功能。 二、JSON解析基本原理现在，假设我们没有任何现成的JSON解析库可用，我们要自己完成JSON的解析工作。JSON解析的工作主要分一下几步： 词法分析：这个过程把输入的JSON字符串分解为一系列词法单元（token）。比如以下JSON字符串：{ “date” : 20160517, “id” : 1}经过词法分析后，会被分解为以下token：“{”、 ”date“、 “:”、 “20160517”、 “,”、 “id”、 “:”、 “1”、 “}”。 语法分析：这一过程的输入是上一步得到的token序列。语法分析这一阶段完成的工作是把token构造成抽象语法单元。对于JSON的解析，这里的抽象语法对象就类似于org.json包中的JSONObject和JSONArray等。有了抽象语法对象，我们就可以进一步把它“映射到”Java数据类型。 实际上，在进行词法分析之前，JSON数据对计算机来说只是一个没有意义的字符串而已。词法分析的目的是把这些无意义的字符串变成一个一个的token，而这些token有着自己的类型和值，所以计算机能够区分不同的token，还能以token为单位解读JSON数据。接下来，语法分析的目的就是进一步处理token，把token构造成一棵抽象语法树（Abstract Syntax Tree）（这棵树的结点是我们上面所说的抽象语法对象）。比如上面的JSON数据我们经过词法分析后得到了一系列token，然后我们把这些token作为语法分析的输入，就可以构造出一个JSONObject对象（即只有一个结点的抽象语法树），这个JSONObject对象有date和id两个实例域。下面我们来分别介绍词法分析与语法分析的原理和实现。 1. 词法分析JSON字符串中，一共有几种token呢？根据http://www.json.org/对JSON格式的相关定义，我们可以把token分为以下类型： STRING（字符串字面量） NUMBER（数字字面量） NULL（null） START_ARRAY（[） END_ARRAY（]） START_OBJ（{） END_OBJ（}） COMMA（,） COLON（:） BOOLEAN（true或者false） END_DOC（表示JSON数据的结束） 我们可以定义一个枚举类型来表示不同的token类型： 123public enum TokenType &#123; START_OBJ, END_OBJ, START_ARRAY, END_ARRAY, NULL, NUMBER, STRING, BOOLEAN, COLON, COMMA, END_DOC&#125; 然后，我们还需要定义一个Token类用于表示token： 123456789101112131415161718192021public class Token &#123; private TokenType type; private String value; public Token(TokenType type, String value) &#123; this.type = type; this.value = value; &#125; public TokenType getType() &#123; return type; &#125; public String getValue() &#123; return value; &#125; public String toString() &#123; return getValue(); &#125;&#125; 在这之后，我们就可以开始写词法分析器了，词法分析器通常被称为lexer或是tokenizer。我们可以使用DFA（确定有限状态自动机）来实现tokenizer，也可以直接使用使用Java的regex包。这里我们使用DFA来实现tokenizer。 实现词法分析器（tokenizer）和语法分析器（parser）的依据都是JSON文法，完整的JSON文法如下（来自https://www.zhihu.com/question/24640264/answer/80500016）： 123456789101112131415object = &#123;&#125; | &#123; members &#125;members = pair | pair , memberspair = string : valuearray = [] | [ elements ]elements = value | value , elementsvalue = string | number | object | array | true | false | nullstring = &quot;&quot; | &quot; chars &quot;chars = char | char charschar = any-Unicode-character-except-&quot;-or-\\-or- control-character | \\&quot; | \\\\ | \\/ | \\b | \\f | \\n | \\r | \\t | \\u four-hex-digitsnumber = int | int frac | int exp | int frac expint = digit | digit1-9 digits | - digit | - digit1-9 digitsfrac = . digitsexp = e digitsdigits = digit | digit digitse = e | e+ | e- | E | E+ | E- 现在，我们就可以根据JSON的文法来构造DFA了，核心代码如下： 1234567891011121314151617181920212223242526272829303132333435private Token start() throws Exception &#123; c = '?'; Token token = null; do &#123; //先读一个字符，若为空白符（ASCII码在[0, 20H]上）则接着读，直到刚读的字符非空白符 c = read(); &#125; while (isSpace(c)); if (isNull(c)) &#123; return new Token(TokenType.NULL, null); &#125; else if (c == ',') &#123; return new Token(TokenType.COMMA, \",\"); &#125; else if (c == ':') &#123; return new Token(TokenType.COLON, \":\"); &#125; else if (c == '&#123;') &#123; return new Token(TokenType.START_OBJ, \"&#123;\"); &#125; else if (c == '[') &#123; return new Token(TokenType.START_ARRAY, \"[\"); &#125; else if (c == ']') &#123; return new Token(TokenType.END_ARRAY, \"]\"); &#125; else if (c == '&#125;') &#123; return new Token(TokenType.END_OBJ, \"&#125;\"); &#125; else if (isTrue(c)) &#123; return new Token(TokenType.BOOLEAN, \"true\"); //the value of TRUE is not null &#125; else if (isFalse(c)) &#123; return new Token(TokenType.BOOLEAN, \"false\"); //the value of FALSE is null &#125; else if (c == '\"') &#123; return readString(); &#125; else if (isNum(c)) &#123; unread(); return readNum(); &#125; else if (c == -1) &#123; return new Token(TokenType.END_DOC, \"EOF\"); &#125; else &#123; throw new JsonParseException(\"Invalid JSON input.\"); &#125;&#125; 我们可以看到，tokenizer的核心代码十分简洁，因为我们把一些稍繁杂的处理逻辑都封装在了一个个方法中，比如上面的readNum方法、readString方法等。 以上代码的第4到第6行的功能是消耗掉开头的所有空白字符（如space、tab等），直到读取到一个非空白字符，isSpace方法用于判断一个字符是否属于空白字符。也就是说，DFA从起始状态开始，若读到一个空字符，会在起始状态不断循环，直到遇到非空字符，状态转移情况如下： 接下来我们可以看到从代码的第7行到第33行是一个if语句块，外层的所有if分支覆盖了DFA的所有可能状态。在第7行我们会判断读入的是不是“null”，isNull方法的代码如下： 12345678910111213141516171819202122private boolean isNull(int c) throws IOException &#123; if (c == 'n') &#123; c = read(); if (c == 'u') &#123; c = read(); if (c == 'l') &#123; c = read(); if (c == 'l') &#123; return true; &#125; else &#123; throw new JsonParseException(\"Invalid JSON input.\"); &#125; &#125; else &#123; throw new JsonParseException(\"Invalid JSON input.\"); &#125; &#125; else &#123; throw new JsonParseException(\"Invalid JSON input.\"); &#125; &#125; else &#123; return false; &#125;&#125; 也就是说，当第一个非空字符为’n’时，我们会判断下一个是否为‘u’，接着判断下面的是不是’u’、’l’，这中间任何一步的判断结果为否，就说明我们遇到了一个非法关键字（比如null拼写错误，拼成了noll，这就是非法关键字），就会抛出异常，只有我们依次读取的4个字符分别为’n’、’u’、’l’、’l’时，isNull方法才会返回true。下面出现的isTrue、isFalse分别用来判断“true”和“false”，具体实现与isNull类似。 现在让我们回到以上的代码，接着看从第9行到第20行，我们会根据下一个字符的不同转移到不同的状态。若下一个字符为’{‘、 ‘}’、 ‘[‘、 ‘]’、 ‘:’、 ‘,’等6种中的一个，则DFA运行停止，此时我们构造一个新的相应类型的Token对象，并直接返回这个token，作为DFA本次运行的结果。这几个状态转移的示意图如下： 上图中圆圈中的数字仅仅表示状态的标号，我们仅画出了下一个字符分别为’{‘、’[‘、’:’时的状态转移（省略了3种情况）。 接下来，让我们看第25行到第26行的代码。这部分代码的主要作用是读取一个由双引号包裹的字符串字面量并构造一个TokenType为STRING的Token对象。若刚读取到的字符为双引号，意味着接下来的是一个字符串字面量，所以我们调用readString方法来读入一个字符串变量。readString方法的代码如下： 123456789101112131415161718192021222324252627private Token readString() throws IOException &#123; StringBuilder sb = new StringBuilder(); while (true) &#123; c = read(); if (isEscape()) &#123; //判断是否为\\\", \\\\, \\/, \\b, \\f, \\n, \\t, \\r. if (c == 'u') &#123; sb.append('\\\\' + (char) c); for (int i = 0; i &lt; 4; i++) &#123; c = read(); if (isHex(c)) &#123; sb.append((char) c); &#125; else &#123; throw new JsonParseException(\"Invalid Json input.\"); &#125; &#125; &#125; else &#123; sb.append(\"\\\\\" + (char) c); &#125; &#125; else if (c == '\"') &#123; return new Token(TokenType.STRING, sb.toString()); &#125; else if (c == '\\r' || c == '\\n')&#123; throw new JsonParseException(\"Invalid JSON input.\"); &#125; else &#123; sb.append((char) c); &#125; &#125; &#125; 我们来看一下readString方法的代码。第3到26行是一个无限循环，退出循环的条件有两个：一个是又读取到一个双引号（意味着字符串的结束），第二个条件是读取到了非法字符（’\\r’或’、’\\n’）。第5行的功能是判断刚读取的字符是否是转义字符的开始，isEscape方法的代码如下： 12345678910111213private boolean isEscape() throws IOException &#123; if (c == '\\\\') &#123; c = read(); if (c == '\"' || c == '\\\\' || c == '/' || c == 'b' || c == 'f' || c == 'n' || c == 't' || c == 'r' || c == 'u') &#123; return true; &#125; else &#123; throw new JsonParseException(\"Invalid JSON input.\"); &#125; &#125; else &#123; return false; &#125;&#125; 我们可以看到这个方法是用来判断接下来的输入流中是否为以下字符组合：\\”, \\, \\/, \\b, \\f, \\n, \\t, \\r, \\uhhhh（hhhh表示四位十六进制数）。若是以上几种中的一个，我们会接着判断是不是“\\uhhhh“，并对他进行特殊处理，如readString方法的第7到15行所示，实际上就是先把’\\u’添加到StringBuilder对象中，在依次读取它后面的4个字符，若是十六进制数字，则append，否则抛出异常。 现在让我们回到start方法，接着看第27到29行的代码，这两行代码用于读入一个数字字面量。isNum方法用于判断输入流中接下来的内容是否是数字字面量，这个方法的源码如下： 123private boolean isNum(int c) &#123; return isDigit(c) || c == '-';&#125; 根据上面我们贴出的JSON文法，只有下一个字符为数字0~9或是’-‘，接下来的内容才可能是一个数字字面量，isDigit方法用于判断下一个字符是否是0~9这10个数字中的一个。 我们注意到第28行有一个unread方法调用，意味着我们下回调用read方法还是返回上回调用read方法返回的那个字符，为什么这么做我们看一下readNum方法的代码就知道了： 123456789101112131415161718192021222324252627282930313233private Token readNum() throws IOException &#123; StringBuilder sb = new StringBuilder(); int c = read(); if (c == '-') &#123; //- sb.append((char) c); c = read(); if (c == '0') &#123; //-0 sb.append((char) c); numAppend(sb); &#125; else if (isDigitOne2Nine(c)) &#123; //-digit1-9 do &#123; sb.append((char) c); c = read(); &#125; while (isDigit(c)); unread(); numAppend(sb); &#125; else &#123; throw new JsonParseException(\"- not followed by digit\"); &#125; &#125; else if (c == '0') &#123; //0 sb.append((char) c); numAppend(sb); &#125; else if (isDigitOne2Nine(c)) &#123; //digit1-9 do &#123; sb.append((char) c); c = read(); &#125; while (isDigit(c)); unread(); numAppend(sb); &#125; return new Token(TokenType.NUMBER, sb.toString()); //the value of 0 is null &#125; 我们来看一下第4到31行，外层的if语句有三种情况：分别对应着刚读取的字符为’-‘、’0’和数字1~9中的一个。我们来看一下第5到9行的代码，对应了刚读取到的字符为’-‘这种情况。这种情况表示这个数字字面量是个负数。然后我们再看这种情况下的内层if语句，共有两种情况，一是负号后面的字符为0，另一个是负号后面的字符为数字1~9中的一个。前者表示本次读取的数字字面量为-0（后面可以跟着frac或是exp），后者表示本次读取的字面量为负整数（后面也可以跟着frac或exp）。然后我们看第9行调用的numAppend方法，它的源码如下: 1234567891011121314151617private void numAppend(StringBuilder sb) throws IOException &#123; c = read(); if (c == '.') &#123; //int frac sb.append((char) c); //apppend '.' appendFrac(sb); if (isExp(c)) &#123; //int frac exp sb.append((char) c); //append 'e' or 'E'; appendExp(sb); &#125; &#125; else if (isExp(c)) &#123; // int exp sb.append((char) c); //append 'e' or 'E' appendExp(sb); &#125; else &#123; unread(); &#125;&#125; 我们上面贴的JSON文法中对数字字面量的定义如下： 1number = int | int frac | int exp | int frac exp numAppend方法的功能就是在我们读取了数字字面量的int部分后，接着读取后面可能还有的frac或exp部分，上面的appendFrac方法用于读取frac部分，appendExp方法用于读取exp部分。具体的逻辑比较直接，大家直接看代码就可以了。（ 这部分的处理逻辑是否正确未经过严格测试，如有错误希望大家可以指出，谢谢：) ） 到了这里，tokenizer的核心——start()方法我们已经介绍的差不多了，tokenizer的完整代码请参考文章开头给出的链接，接下来让我们看一下如何实现JSON parser。 2. 语法分析经过前一步的词法分析，我们已经得到了一个token序列，现在让我们来用这个序列构造出类似于org.json包的JSONObject与JSONArray对象。现在我们的任务就是编写一个语法分析器（parser），以词法分析得到的token序列为输入，产生JSONObject或是JSONArray抽象语法对象。语法分析的依据同样是上面我们贴出的JSON文法。 语法分析器依据JSON文法的以下部分实现： 123456object = &#123;&#125; | &#123; members &#125;members = pair | pair , memberspair = string : valuearray = [] | [ elements ]elements = value | value , elementsvalue = string | number | object | array | true | false | null 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130public class Parser &#123; private Tokenizer tokenizer; public Parser(Tokenizer tokenizer) &#123; this.tokenizer = tokenizer; &#125; private JObject object() &#123; tokenizer.next(); //consume '&#123;' Map&lt;String, Value&gt; map = new HashMap&lt;&gt;(); if (isToken(TokenType.END_OBJ)) &#123; tokenizer.next(); //consume '&#125;' return new JObject(map); &#125; else if (isToken(TokenType.STRING)) &#123; map = key(map); &#125; return new JObject(map); &#125; private Map&lt;String, Value&gt; key(Map&lt;String, Value&gt; map) &#123; String key = tokenizer.next().getValue(); if (!isToken(TokenType.COLON)) &#123; throw new JsonParseException(\"Invalid JSON input.\"); &#125; else &#123; tokenizer.next(); //consume ':' if (isPrimary()) &#123; Value primary = new Primary(tokenizer.next().getValue()); map.put(key, primary); &#125; else if (isToken(TokenType.START_ARRAY)) &#123; Value array = array(); map.put(key, array); &#125; if (isToken(TokenType.COMMA)) &#123; tokenizer.next(); //consume ',' if (isToken(TokenType.STRING)) &#123; map = key(map); &#125; &#125; else if (isToken(TokenType.END_OBJ)) &#123; tokenizer.next(); //consume '&#125;' return map; &#125; else &#123; throw new JsonParseException(\"Invalid JSON input.\"); &#125; &#125; return map; &#125; private JArray array() &#123; tokenizer.next(); //consume '[' List&lt;Json&gt; list = new ArrayList&lt;&gt;(); JArray array = null; if (isToken(TokenType.START_ARRAY)) &#123; array = array(); list.add(array); if (isToken(TokenType.COMMA)) &#123; tokenizer.next(); //consume ',' list = element(list); &#125; &#125; else if (isPrimary()) &#123; list = element(list); &#125; else if (isToken(TokenType.START_OBJ)) &#123; list.add(object()); while (isToken(TokenType.COMMA)) &#123; tokenizer.next(); //consume ',' list.add(object()); &#125; &#125; else if (isToken(TokenType.END_ARRAY)) &#123; tokenizer.next(); //consume ']' array = new JArray(list); return array; &#125; tokenizer.next(); //consume ']' array = new JArray(list); return array; &#125; private List&lt;Json&gt; element(List&lt;Json&gt; list) &#123; list.add(new Primary(tokenizer.next().getValue())); if (isToken(TokenType.COMMA)) &#123; tokenizer.next(); //consume ',' if (isPrimary()) &#123; list = element(list); &#125; else if (isToken(TokenType.START_OBJ)) &#123; list.add(object()); &#125; else if (isToken(TokenType.START_ARRAY)) &#123; list.add(array()); &#125; else &#123; throw new JsonParseException(\"Invalid JSON input.\"); &#125; &#125; else if (isToken(TokenType.END_ARRAY)) &#123; return list; &#125; else &#123; throw new JsonParseException(\"Invalid JSON input.\"); &#125; return list; &#125; private Json json() &#123; TokenType type = tokenizer.peek(0).getType(); if (type == TokenType.START_ARRAY) &#123; return array(); &#125; else if (type == TokenType.START_OBJ) &#123; return object(); &#125; else &#123; throw new JsonParseException(\"Invalid JSON input.\"); &#125; &#125; private boolean isToken(TokenType tokenType) &#123; Token t = tokenizer.peek(0); return t.getType() == tokenType; &#125; private boolean isToken(String name) &#123; Token t = tokenizer.peek(0); return t.getValue().equals(name); &#125; private boolean isPrimary() &#123; TokenType type = tokenizer.peek(0).getType(); return type == TokenType.BOOLEAN || type == TokenType.NULL || type == TokenType.NUMBER || type == TokenType.STRING; &#125; public Json parse() throws Exception &#123; Json result = json(); return result; &#125;&#125; 我们先来看以上代码的第98到107行的json方法，这个方法可以作为语法分析的起点。它会根据第一个Token的类型是START_OBJ或START_ARRAY而选择调用object方法或是array方法。object方法会返回一个JObject对象（JSONObject），array方法会返回一个JArray对象（JSONArray）。JArray与JObject的定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class JArray extends Json implements Value &#123; private List&lt;Json&gt; list = new ArrayList&lt;&gt;(); public JArray(List&lt;Json&gt; list) &#123; this.list = list; &#125; public int length() &#123; return list.size(); &#125; public void add(Json element) &#123; list.add(element); &#125; public Json get(int i) &#123; return list.get(i); &#125; @Override public Object value() &#123; return this; &#125; public String toString() &#123; . . . &#125; &#125;public class JObject extends Json &#123; private Map&lt;String, Value&gt; map = new HashMap&lt;&gt;(); public JObject(Map&lt;String, Value&gt; map) &#123; this.map = map; &#125; public int getInt(String key) &#123; return Integer.parseInt((String) map.get(key).value()); &#125; public String getString(String key) &#123; return (String) map.get(key).value(); &#125; public boolean getBoolean(String key) &#123; return Boolean.parseBoolean((String) map.get(key).value()); &#125; public JArray getJArray(String key) &#123; return (JArray) map.get(key).value(); &#125; public String toString() &#123; . . . &#125;&#125; JSON parser的逻辑也没有太复杂的地方，如果哪位同学不太理解，可以写一个test case跟着走几遍。 接下来，我们要进入有意思的部分了——实现类似org.json包的根据JSON字符串直接构造JSONObject与JSONArray。 3. parseJSONObject方法与parseJSONArray方法基于以上的tokenizer与parser，我们可以实现两个实用的JSON解析方法，有了这两个方法，可以说我们就完成了一个基本的JSON解析库。 ####（1）parseJSONObject方法 该方法以一个JSON字符串为输入，返回一个JObject，代码如下： 123456public static JObject parseJSONObject(String jsonString) throws Exception &#123; Tokenizer tokenizer = new Tokenizer(new BufferedReader(new StringReader(jsonString))); tokenizer.tokenize(); Parser parser = new Parser(tokenizer); return parser.object();&#125; ####（2）parseJSONArray方法 该方法以一个JSON字符串为输入，返回一个JArray，代码如下： 123456public static JObject parseJSONArray(String jsonString) throws Exception &#123; Tokenizer tokenizer = new Tokenizer(new BufferedReader(new StringReader(jsonString))); tokenizer.tokenize(); Parser parser = new Parser(tokenizer); return parser.array();&#125; 接下来，我们来测试以下这两个放究竟能不能用，test case如下： 123456789101112131415161718192021222324252627282930public static void main(String[] args) throws Exception &#123; try &#123; String jsonString = new String(HttpUtil.get(urlString)); JObject latestNewsJSON = parseJSONObject(jsonString); String date = latestNewsJSON.getString(\"date\"); JArray top_storiesJSON = latestNewsJSON.getJArray(\"top_stories\"); LatestNews latest = new LatestNews(); List&lt;LatestNews.TopStory&gt; stories = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; top_storiesJSON.length(); i++) &#123; LatestNews.TopStory story = new LatestNews.TopStory(); story.setId(((JObject) top_storiesJSON.get(i)).getInt(\"id\")); story.setType(((JObject) top_storiesJSON.get(i)).getInt(\"type\")); story.setImage(((JObject) top_storiesJSON.get(i)).getString(\"image\")); story.setTitle(((JObject) top_storiesJSON.get(i)).getString(\"title\")); stories.add(story); &#125; latest.setDate(date); System.out.println(\"date: \" + latest.getDate()); for (int i = 0; i &lt; stories.size(); i++) &#123; System.out.println(stories.get(i)); &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; 实际上，上面的代码只是把我们使用org.json包的代码稍作修改。然后我们可以得到了同使用org.json包一样的输出，这说明我们的JSON解析器工作正常。以上代码中的getInt方法与getString方法定义在JObject中，只需要根据要取得的值的类型做类型转换即可，具体实现可以参考开头给出的项目地址。接下来，让我们更上一层楼，实现一个类似与gson中fromJson方法的便捷方法。 4. fromJson方法的实现这个方法的核心思想是：根据给定的JSON字符串和model类的class对象，通过反射获取model类的各个实例域的类型及名称。然后用java.lang.reflect包提供给我们的方法在运行时创建一个model类的对象，然后根据它的实例域的名称从JObject中获取相应的值并为model类对象的对应实例域赋值。若实例域为List，我们需要特殊进行处理，这里我们实现了一个inflateList方法来处理这种情况。fromJson方法的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738public static &lt;T&gt; T fromJson(String jsonString, Class&lt;T&gt; classOfT) throws Exception &#123; Tokenizer tokenizer = new Tokenizer(new BufferedReader(new StringReader(jsonString))); tokenizer.tokenize(); Parser parser = new Parser(tokenizer); JObject result = parser.object(); Constructor&lt;T&gt; constructor = classOfT.getConstructor(); Object latestNews = constructor.newInstance(); Field[] fields = classOfT.getDeclaredFields(); int numField = fields.length; String[] fieldNames = new String[numField]; String[] fieldTypes = new String[numField]; for (int i = 0; i &lt; numField; i++) &#123; String type = fields[i].getType().getTypeName(); String name = fields[i].getName(); fieldTypes[i] = type; fieldNames[i] = name; &#125; for (int i = 0; i &lt; numField; i++) &#123; if (fieldTypes[i].equals(\"java.lang.String\")) &#123; fields[i].setAccessible(true); fields[i].set(latestNews, result.getString(fieldNames[i])); &#125; else if (fieldTypes[i].equals(\"java.util.List\")) &#123; fields[i].setAccessible(true); JArray array = result.getJArray(fieldNames[i]); ParameterizedType pt = (ParameterizedType) fields[i].getGenericType(); Type elementType = pt.getActualTypeArguments()[0]; String elementTypeName = elementType.getTypeName(); Class&lt;?&gt; elementClass = Class.forName(elementTypeName); fields[i].set(latestNews, inflateList(array, elementClass));//类型捕获 &#125; else if (fieldTypes[i].equals(\"int\")) &#123; fields[i].setAccessible(true); fields[i].set(latestNews, result.getInt(fieldNames[i])); &#125; &#125; return (T) latestNews; &#125; 在第8行，我们构造了一个LatestNews对象。在第9到18行，我们获取了LatestNews类的所有实例域，并把它们的名称存在了String数组fieldNames中，把它们的类型存在了String数组fieldTypes中。然后在第19到36行，我们遍历Field数组fields，对每个实例域进行赋值。若实例域的类型为int或是String或是primitive types（int、double等基本类型），则直接调用set方法对相应实例域赋值（简单起见，上面只实现了对String类型实例域的处理，对于primitive types的处理与之类似，感兴趣的同学可以自己尝试实现下）；若实例域的类型为List，则我们需要为这个List中的每个元素赋值。在第26到29行，我们获取了List中存储的元素的类型名称，然后根据这个名称获取了对应的class对象。在第30行，我们调用了inflateList方法来“填充“这个List，这里存在一个”类型捕获“，具体来说，就是inflateList方法接收的第2个参数Class中的类型参数T捕获了List中存储元素的实际类型（第29行我们获取了这个实际类型并用类型通配符接收了它）。inflateList方法的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static &lt;T&gt; List&lt;T&gt; inflateList(JArray array, Class&lt;T&gt; clz) throws Exception &#123; int size = array.length(); List&lt;T&gt; list = new ArrayList&lt;T&gt;(); Constructor&lt;T&gt; constructor = clz.getConstructor(); String className = clz.getName(); if (className.equals(\"java.lang.String\")) &#123; for (int i = 0; i &lt; size; i++) &#123; String element = (String) ((Primary) array.get(i)).value(); list.add((T) element); return list; &#125; &#125; Field[] fields = clz.getDeclaredFields(); int numField = fields.length; String[] fieldNames = new String[numField]; String[] fieldTypes = new String[numField]; for (int i = 0; i &lt; numField; i++) &#123; String type = fields[i].getType().getTypeName(); String name = fields[i].getName(); fieldTypes[i] = type; fieldNames[i] = name; &#125; for (int i = 0; i &lt; size; i++) &#123; T element = constructor.newInstance(); JObject object = (JObject) array.get(i); for (int j = 0; j &lt; numField; j++) &#123; if (fieldTypes[j].equals(\"java.lang.String\")) &#123; fields[j].setAccessible(true); fields[j].set(element, (object.getString(fieldNames[j]))); &#125; else if (fieldTypes[j].equals(\"java.util.List\")) &#123; fields[j].setAccessible(true); JArray nestArray = object.getJArray(fieldNames[j]); ParameterizedType pt = (ParameterizedType) fields[j].getGenericType(); Type elementType = pt.getActualTypeArguments()[0]; String elementTypeName = elementType.getTypeName(); Class&lt;?&gt; elementClass = Class.forName(elementTypeName); String value = null; fields[j].set(element, inflateList(nestArray, elementClass));//Type Capture &#125; else if (fieldTypes[j].equals(\"int\")) &#123; fields[j].setAccessible(true); fields[j].set(element, object.getInt(fieldNames[j])); &#125; &#125; list.add(element); &#125; return list; &#125; 在这个方法中，我们会根据对JSON解析获取的JArray所含的元素个数，以及我们之前获取到的元素的类型，构造相应数目的对象，并添加到list中去。具体的执行过程大家可以参考代码，逻辑比较直接。 需要注意的是以上代码的第7到13行，它的意思是若列表的元素类型为String，我们就应直接从相应的JArray中获取元素并添加到list中，然后直接返回list。实际上，对于primitive types我们都应该做相似处理，简单起见，这里只对String类型做了处理，其他primitive types的处理方式类似。 接下来测试一下我们实现的fromJson方法是否能如我们预期那样工作，test case还是解析上面的知乎日报API返回的数据： 123456789101112public class SimpleJSONTest &#123; public static final String urlString = \"http://news-at.zhihu.com/api/4/news/latest\"; public static void main(String[] args) throws Exception &#123; LatestNews latest = new LatestNews(); String jsonString = new String(HttpUtil.get(urlString)); latest = Parser.fromJson(jsonString, LatestNews.class); System.out.println(latest.getDate()); for (int i = 0; i &lt; latest.getTop_stories().size(); i++) &#123; System.out.println(latest.getTop_stories().get(i)); &#125; &#125;&#125; 我们还可以对比一下我们的实现与gson的实现的性能，我这里测试的结果是SimpleJSON的速度大约是gson速度的三倍，考虑到我们的SimpleJSON在不少地方”偷懒“了，这个测试结果并不能说明我们的实现性能要优于gson，不过这或许可以说明我们的JSON解析库还是具备一定的实用性… 由于本篇博文重点在介绍一个JSON解析器的实现思路，在具体实现上很多部分做的并不好。比如没有做足够多的测试来验证JSON解析的正确性，业务逻辑上也尽量使用直接的方式，许多地方没使用更加高效的实现，另外在抛出异常方面也比较随便，“一言不合”就抛异常…由于个人水平有限，代码中难免存在谬误，希望大家多多包涵，更希望可以指出不足之处，谢谢大家：） 三、参考资料 http://www.liaoxuefeng.com/article/0014211269349633dda29ee3f29413c91fa65c372585f23000?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io https://www.zhihu.com/question/24640264/answer/80500016 http://docs.oracle.com/javase/specs/jls/se8/jls8.pdf 《Java核心技术（卷一）》","categories":[{"name":"Repost","slug":"Repost","permalink":"http://blog.duanxu.tech/categories/Repost/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.duanxu.tech/tags/Java/"},{"name":"JSON","slug":"JSON","permalink":"http://blog.duanxu.tech/tags/JSON/"}]},{"title":"[转]三十分钟学会SED","slug":"2016/2016-12-27-转-三十分钟学会SED","date":"2016-12-27T03:37:30.000Z","updated":"2018-12-07T12:53:03.005Z","comments":true,"path":"2016/12/27/2016/2016-12-27-转-三十分钟学会SED/","link":"","permalink":"http://blog.duanxu.tech/2016/12/27/2016/2016-12-27-转-三十分钟学会SED/","excerpt":"","text":"content{:toc} 原文链接：三十分钟学会SED 本文承接之前写的三十分钟学会AWK一文，在学习完AWK之后，趁热打铁又学习了一下SED，不得不说这两个工具真的堪称文本处理神器，谁用谁知道！本文大部分内容依旧是翻译自Tutorialspoint上的入门教程，这次是 Sed Tutorial 一文，内容做了一些删减和补充，增加了一些原文中没有提及到的语法和命令的讲解，并且对原文所有的示例都一一进行了验证，希望本文对大家学习和了解Sed有所帮助。 文中用到的测试文件可以在 https://github.com/mylxsw/sed-demo找到。 本文将会持续修正和更新，最新内容请参考我的 GITHUB 上的 程序猿成长计划 项目，欢迎 Star。 概述SED的英文全称是 Stream EDitor，它是一个简单而强大的文本解析转换工具，在1973-1974年期间由贝尔实验室的Lee E. McMahon开发，今天，它已经运行在所有的主流操作系统上了。 McMahon创建了一个通用的行编辑器，最终变成为了SED。SED的很多语法和特性都借鉴了ed编辑器。设计之初，它就已经支持正则表达式，SED可以从文件中接受类似于管道的输入，也可以接受来自标准输入流的输入。 SED由自由软件基金组织（FSF）开发和维护并且随着GNU/Linux进行分发，因此，通常它也称作 GNU SED。对于新手来说，SED的语法看起来可能有些神秘，但是，一旦掌握了它的语法，你就可以只用几行代码去解决非常复杂的任务，这就是SED的魅力所在。 SED的典型用途SED的用途非常广泛，例如： 文本替换 选择性的输出文本文件 从文本文件的某处开始编辑 无交互式的对文本文件进行编辑等 工作流在本章中，我们将会探索SED是如何工作的，要想成为一个SED专家，你需要知道它的内部实现。SED遵循简单的工作流：读取，执行和显示，下图描述了该工作流： 读取： SED从输入流（文件，管道或者标准输入）中读取一行并且存储到它叫做 模式空间（pattern buffer） 的内部缓冲区 执行： 默认情况下，所有的SED命令都在模式空间中顺序的执行，除非指定了行的地址，否则SED命令将会在所有的行上依次执行 显示： 发送修改后的内容到输出流。在发送数据之后，模式空间将会被清空。 在文件所有的内容都被处理完成之前，上述过程将会重复执行 需要注意的几点 模式空间 （pattern buffer） 是一块活跃的缓冲区，在sed编辑器执行命令时它会保存待检查的文本 默认情况下，所有的SED命令都是在模式空间中执行，因此输入文件并不会发生改变 还有另外一个缓冲区叫做 保持空间 （hold buffer），在处理模式空间中的某些行时，可以用保持空间来临时保存一些行。在每一个循环结束的时候，SED将会移除模式空间中的内容，但是该缓冲区中的内容在所有的循环过程中是持久存储的。SED命令无法直接在该缓冲区中执行，因此SED允许数据在 保持空间 和 模式空间之间切换 初始情况下，保持空间 和 模式空间 这两个缓冲区都是空的 如果没有提供输入文件的话，SED将会从标准输入接收请求 如果没有提供地址范围的话，默认情况下SED将会对所有的行进行操作 示例让我们创建一个名为 quote.txt 的文本文件，文件内容为著名作家Paulo Coelho的一段名言 $ vi quote.txt There is only one thing that makes a dream impossible to achieve: the fear of failure. - Paulo Coelho, The Alchemist 为了理解SED的工作流，我们首先使用SED显示出quote.txt文件的内容，该示例与cat命令类似 $ sed &apos;&apos; quote.txt There is only one thing that makes a dream impossible to achieve: the fear of failure. - Paulo Coelho, The Alchemist 在上面的例子中，quote.txt是输入的文件名称，两个单引号是要执行的SED命令。 首先，SED将会读取quote.txt文件中的一行内容存储到它的模式空间中，然后会在该缓冲区中执行SED命令。在这里，没有提供SED命令，因此对该缓冲区没有要执行的操作，最后它会删除模式空间中的内容并且打印该内容到标准输出，很简单的过程，对吧? 在下面的例子中，SED会从标准输入流接受输入 $ sed &apos;&apos; 当上述命令被执行的时候，将会产生下列结果 There is only one thing that makes a dream impossible to achieve: the fear of failure. There is only one thing that makes a dream impossible to achieve: the fear of failure. 在这里，第一行内容是通过键盘输入的内容，第二行是SED输出的内容。 从SED会话中退出，使用组合键ctrl-D (^D) 基础语法本章中将会介绍SED中的基本命令和它的命令行使用方法。SED可以用下列两种方式调用： sed [-n] [-e] &apos;command(s)&apos; files sed [-n] -f scriptfile files 第一种方式在命令行中使用单引号指定要执行的命令，第二种方式则指定了包含SED命令的脚本文件。当然，这两种方法也可以同时使用，SED提供了很多参数用于控制这种行为。 让我们看看如何指定多个SED命令。SED提供了delete命令用于删除某些行，这里让我们删除第一行，第二行和第五行： 首先，使用cat命令显示文件内容 $ cat books.txt 1) A Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 现在，使用SED移除指定的行，为了删除三行，我们使用-e选项指定三个独立的命令 $ sed -e &apos;1d&apos; -e &apos;2d&apos; -e &apos;5d&apos; books.txt 3) The Alchemist, Paulo Coelho, 197 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 6) A Game of Thrones, George R. R. Martin, 864 我们还可以将多个SED命令写在一个文本文件中，然后将该文件作为SED命令的参数，SED可以对模式空间中的内容执行文件中的每一个命令，下面的例子描述了SED的第二种用法 首先，创建一个包含SED命令的文本文件，为了便于理解，我们使用与之前相同的SED命令 $ echo -e &quot;1d\\n2d\\n5d&quot; &gt; commands.txt $ cat commands.txt 1d 2d 5d 接下来构造一个SED命令去执行该操作 $ sed -f commands.txt books.txt 3) The Alchemist, Paulo Coelho, 197 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 6) A Game of Thrones, George R. R. Martin, 864 标准选项SED支持下列标准选项： -n 默认情况下，模式空间中的内容在处理完成后将会打印到标准输出，该选项用于阻止该行为 $ sed -n &apos;&apos; quote.txt -e 指定要执行的命令，使用该参数，我们可以指定多个命令，让我们打印每一行两次： $ sed -e &apos;&apos; -e &apos;p&apos; quote.txt There is only one thing that makes a dream impossible to achieve: the fear of failure. There is only one thing that makes a dream impossible to achieve: the fear of failure. - Paulo Coelho, The Alchemist - Paulo Coelho, The Alchemist -f 指定包含要执行的命令的脚本文件 $ echo &quot;p&quot; &gt; commands $ $ sed -n -f commands quote.txt There is only one thing that makes a dream impossible to achieve: the fear of failure. - Paulo Coelho, The Alchemist GNU选项这些选项是GNU规范定义的，可能对于某些版本的SED并不支持。 -n， –quiet, –slient：与标准的-n选项相同 -e script，–expression=script：与标准的-e选项相同 -f script-file， –file=script-file：与标准的-f选项相同 –follow-symlinks：如果提供该选项的话，在编辑的文件是符号链接时，SED将会跟随链接 -i[SUFFIX]，–in-place[=SUFFIX]：该选项用于对当前文件进行编辑，如果提供了SUFFIX的话，将会备份原始文件，否则将会覆盖原始文件 -l N， –line-lenght=N：该选项用于设置行的长度为N个字符 –posix：该选项禁用所有的GNU扩展 -r，–regexp-extended：该选项将启用扩展的正则表达式 -u， –unbuffered：指定该选项的时候，SED将会从输入文件中加载最少的数据，并且更加频繁的刷出到输出缓冲区。在编辑tail -f命令的输出，你不希望等待输出的时候该选项是非常有用的。 -z，–null-data：默认情况下，SED对每一行使用换行符分割，如果提供了该选项的话，它将使用NULL字符分割行 循环与其它编程语言类似，SED提供了用于控制执行流的循环和分支语句。 SED中的循环有点类似于goto语句，SED可以根据标签（label）跳转到某一行继续执行，在SED中，我们可以定义如下的标签： :label :start :end :up 在上面的示例中，我们创建了四个标签。 要跳转到指定的标签，使用 b 命令后面跟着标签名，如果忽略标签名的话，SED将会跳转到SED文件的结尾。 b标签用于无条件的跳转到指定的label。 为了更好地理解SED中的循环和分支，让我们创建一个名为books2.txt的文本文件，其中包含一些图书的标题和作者信息，下面的示例中会合并图书的标题和作者，使用逗号分隔。之后搜索所有匹配“Paulo”的行，如果匹配的话就在这一行的开头添加-，否则跳转到Print标签，打印出该行内容。 $ cat books2.txt A Storm of Swords George R. R. Martin The Two Towers J. R. R. Tolkien The Alchemist Paulo Coelho The Fellowship of the Ring J. R. R. Tolkien The Pilgrimage Paulo Coelho A Game of Thrones George R. R. Martin $ sed -n &apos; h;n;H;x s/\\n/, / /Paulo/!b Print s/^/- / :Print p&apos; books2.txt A Storm of Swords , George R. R. Martin The Two Towers , J. R. R. Tolkien - The Alchemist , Paulo Coelho The Fellowship of the Ring , J. R. R. Tolkien - The Pilgrimage , Paulo Coelho A Game of Thrones , George R. R. Martin 乍看来上述的代码非常神秘，让我们逐步拆解一下 第一行是h;n;H;x这几个命令，记得上面我们提到的 保持空间 吗？第一个h是指将当前模式空间中的内容覆盖到 保持空间中，n用于提前读取下一行，并且覆盖当前模式空间中的这一行，H将当前模式空间中的内容追加到 保持空间 中，最后的x用于交换模式空间和保持空间中的内容。因此这里就是指每次读取两行放到模式空间中交给下面的命令进行处理 接下来是 s/\\n/, / 用于将上面的两行内容中的换行符替换为逗号 第三个命令在不匹配的时候跳转到Print标签，否则继续执行第四个命令 :Print仅仅是一个标签名，而p则是print命令 为了提高可读性，每一个命令都占了一行，当然，你也可以把所有命令放在一行 $ sed -n &apos;h;n;H;x;s/\\n/, /;/Paulo/!b Print; s/^/- /; :Print;p&apos; books2.txt 关于h，H，x命令参考官方手册 sed, a stream editor 3.6 Less Frequently-Used Commands节 分支使用 t 命令创建分支。只有当前置条件成功的时候，t 命令才会跳转到该标签。 t命令只有在前一个替换（s）命令执行成功的时候才会执行。 让我们看一些前面章节中的例子，与之前不同的是，这次我们将打印四个连字符”-“，而之前是一个。 $ sed -n &apos; h;n;H;x s/\\n/, / :Loop /Paulo/s/^/-/ /----/!t Loop p&apos; books2.txt A Storm of Swords , George R. R. Martin The Two Towers , J. R. R. Tolkien ----The Alchemist , Paulo Coelho The Fellowship of the Ring , J. R. R. Tolkien ----The Pilgrimage , Paulo Coelho A Game of Thrones , George R. R. Martin 在上面的例子中，前面两行与上一节中讲的作用一致，第三行定义了一个Loop标签，接下来匹配存在“Paulo”的行，如果存在则在最前面添加一个-，接下来是我们这里的重点： /----/!t Loop这一行首先检查上面添加-之后是否满足四个-，如果不满足则跳转到Loop继续执行第三行，这样不停的追加-，最后如果改行满足前面有四个-才继续往下执行。 为了提高可读性，我们将每一个SED命令独立一行，我们也可以在同一行中使用： sed -n &apos;h;n;H;x; s/\\n/, /; :Loop;/Paulo/s/^/-/; /----/!t Loop; p&apos; books.txt 模式空间和保持空间模式空间对任何文件的来说，最基本的操作就是输出它的内容，为了实现该目的，在SED中可以使用print命令打印出模式空间中的内容。 首先创建一个包含行号，书名，作者和页码数的文件，在本文中我们将会使用该文件，你也可以创建任何其它的文件，但是这里我们就创建一个包含以下内容的文件 $ vi books.txt 1) A Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho,288 6) A Game of Thrones, George R. R. Martin, 864 执行p命令 $ sed &apos;p&apos; books.txt 1) A Storm of Swords, George R. R. Martin, 1216 1) A Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 3) The Alchemist, Paulo Coelho, 197 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho, 288 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 6) A Game of Thrones, George R. R. Martin, 864 你可能会疑惑，为什么每一行被显示了两次？ 你还记得SED的工作流吗？默认情况下，SED将会输出模式空间中的内容，另外，我们的命令中包含了输出命令p，因此每一行被打印两次。但是不要担心，SED提供了-n参数用于禁止自动输出模式空间的每一行的行为 $ sed -n &apos;p&apos; books.txt 1) A Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 行寻址默认情况下，在SED中使用的命令会作用于文本数据的所有行。如果只想将命令作用于特定的行或者某些行，则需要使用 行寻址 功能。 在SED中包含两种形式的行寻址： 以数字形式表示的行区间 以文本模式来过滤行 两种形式都使用相同的语法格式 [address]command 数字方式的行寻址在下面的示例中SED只会对第3行进行操作 $ sed -n &apos;3p&apos; books.txt 3) The Alchemist, Paulo Coelho, 197 当然，我们还可以让SED输出某些行。在SED中使用逗号,分隔输出行号的范围，例如下面的代码会输出出2-5行的内容 $ sed -n &apos;2,5 p&apos; books.txt 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho, 288 特殊字符 $ 代表了文件的最后一行，输出文件的最后一行 $ sed -n &apos;$ p&apos; books.txt 6) A Game of Thrones, George R. R. Martin, 864 也可以使用 $ 指定输出的地址范围，下列命令输出第三行到最后一行 $ sed -n &apos;3,$ p&apos; books.txt 3) The Alchemist, Paulo Coelho, 197 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho,288 6) A Game of Thrones, George R. R. Martin, 864 SED还提供了另外两种操作符用于指定地址范围，第一个是加号（+）操作符，它可以与逗号（,）操作符一起使用，例如 M, +n 将会打印出从第M行开始的下n行。下面的示例将会输出第二行开始的下面四行 $ sed -n &apos;2,+4 p&apos; books.txt 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 我们还可以使用波浪线操作符（~）指定地址范围，它使用M~N的形式，它告诉SED应该处理M行开始的每N行。例如，50~5匹配行号50，55，60，65等，让我们只输出文件中的奇数行 $ sed -n &apos;1~2 p&apos; books.txt 1) A Storm of Swords, George R. R. Martin, 1216 3) The Alchemist, Paulo Coelho, 197 5) The Pilgrimage, Paulo Coelho, 288 下面的代码则是只输出文件中的偶数行 $ sed -n &apos;2~2 p&apos; books.txt 2) The Two Towers, J. R. R. Tolkien, 352 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 6) A Game of Thrones, George R. R. Martin, 864 注意，如果使用的是Mac系统自带的sed命令，可能不支持~和+操作符。可以使用brew install gnu-sed --with-default-names重新安装GNU-SED。 使用文本模式过滤器SED编辑器允许指定文本模式来过滤出命令要作用的行。格式如下： /pattern/command 必须用正斜线将要指定的pattern封起来。sed编辑器会将该命令作用到包含指定文本模式的行上。 下面的示例中，将会输出所有作者为Paulo Coelho的书籍。 $ sed -n &apos;/Paulo/ p&apos; books.txt 3) The Alchemist, Paulo Coelho, 197 5) The Pilgrimage, Paulo Coelho, 288 模式匹配也可以与数字形式的寻址同时使用，在下面的示例会从第一次匹配到Alchemist开始输出，直到第5行为止。 $ sed -n &apos;/Alchemist/, 5 p&apos; books.txt 3) The Alchemist, Paulo Coelho, 197 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho, 288 使用逗号（,）操作符指定匹配多个匹配的模式。下列的示例将会输出Two和Pilgrimage之间的所有行 $ sed -n &apos;/Two/, /Pilgrimage/ p&apos; books.txt 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho, 288 在使用文本模式过滤器的时候，与数字方式的行寻址类似，可以使用加号操作符 +，它会输出从当前匹配位置开始的某几行，下面的示例会从第一次Two出现的位置开始输出接下来的4行 $ sed -n &apos;/Two/, +4 p&apos; books.txt 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 保持空间在处理模式空间中的某些行时，可以用保持空间来临时保存一些行。有5条命令可用来操作保持空间 命令 描述 h 将模式空间复制到保持空间 H 将模式空间附加到保持空间 g 将保持空间复制到模式空间 G 将保持空间附加到模式空间 x 交换模式空间和保持空间的内容 关于保持空间这里就不在举例了，前面再循环部分讲解下面这个命令的时候我们已经对它的使用做了说明。 $ sed -n &apos;h;n;H;x;s/\\n/, /;/Paulo/!b Print; s/^/- /; :Print;p&apos; books2.txt 基本命令本章将会讲解一些常用的SED命令，主要包括DELETE，WRITE，APPEND，CHANGE，INSERT，TRANSLATE，QUIT，READ，EXECUTE等命令。 删除命令 d删除命令格式如下 [address1[,address2]]d address1和address2是开始和截止地址，它们可以是行号或者字符串匹配模式，这两种地址都是可选的。 由命令的名称可以知道，delete 命令是用来执行删除操作的，并且因为SED是基于行的编辑器，因此我们说该命令是用来删除行的。注意的是，该命令只会移除模式空间中的行，这样该行就不会被发送到输出流，但原始内容不会改变。 $ sed &apos;d&apos; books.txt 为什么没有输出任何内容？默认情况下，SED将会对每一行执行删除操作，这就是该命令为什么没有在标准输出中输出任何内容的原因。 下列命令只移除第四行 [jerry]$ sed &apos;4d&apos; books.txt 1) A Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 SED也接受使用逗号(,)分隔的地址范围。我们可以构造地址范围去移除N1到N2行，例如，下列命令将删除2-4行 $ sed &apos;2, 4 d&apos; books.txt 1) A Storm of Swords, George R. R. Martin, 1216 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 SED的地址范围并不仅仅限于数字，我们也可以指定模式匹配作为地址，下面的示例会移除所有作者为Paulo Coelho的书籍 $ sed &apos;/Paulo Coelho/d&apos; books.txt 1) A Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 6) A Game of Thrones, George R. R. Martin, 864 我移除所有以Storm和Fellowship开头的行 $ sed &apos;/Storm/,/Fellowship/d&apos; books.txt 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 文件写入命令 wSED提供了 write 命令用于将模式空间中的内容写入到文件，与 delete 命令类似，下面是 write 命令的语法 [address1[,address2]]w file w 指定是写命令， file 指的是存储文件内容的文件名。使用 file 操作符的时候要小心，当提供了文件名但是文件不存在的时候它会自动创建，如果已经存在的话则会覆盖原文件的内容。 下面的SED命令会创建文件books.txt的副本，在 w 和 file 之间只能有一个空格 $ sed -n &apos;w books.bak&apos; books.txt 上述命令创建了一个名为 books.bak 的文件，验证一下两个文件的内容是否相同 $ diff books.txt books.bak $ echo $? 一旦执行上述的代码，你将会得到下列输出 0 聪明的你可能已经想到了，这不就是 cp 命令做的事情吗！确实如此，cp 命令也做了同一件事情，但是SED是一个成熟的工具，使用它你可以只复制文件中的某些行到新的文件中，如下代码会存储文件中的奇数行到另一个文件 $ sed -n &apos;2~2 w junk.txt&apos; books.txt $ cat junk.txt 2) The Two Towers, J. R. R. Tolkien, 352 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 6) A Game of Thrones, George R. R. Martin, 864 假设你希望存储所有独立作者的书到单独的文件。如果人工去做的话，肯定是非常无聊而且没有技术含量的，但是使用SED，你就有了更加聪明的方法去实现 $ sed -n -e &apos;/Martin/ w Martin.txt&apos; -e &apos;/Paulo/ w Paulo.txt&apos; -e &apos;/Tolkien/ w Tolkien.txt&apos; books.txt $ cat Martin.txt 1) A Storm of Swords, George R. R. Martin, 1216 6) A Game of Thrones, George R. R. Martin, 864 $ cat Paulo.txt 3) The Alchemist, Paulo Coelho, 197 5) The Pilgrimage, Paulo Coelho, 288 $ cat Tolkien.txt 2) The Two Towers, J. R. R. Tolkien, 352 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 追加命令 a文本追加命令语法： [address]a\\ Append text 在第四行之后追加一本新书： $ sed &apos;4 a 7) Adultry, Paulo Coelho, 234&apos; books.txt 1) A Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 7) Adultry, Paulo Coelho, 234 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 在命令部分，4指的是行号，a 是append命令，剩余部分为要追加的文本。 在文件的结尾插入一行文本，使用 $ 作为地址 $ sed &apos;$ a 7) Adultry, Paulo Coelho, 234&apos; books.txt 1) A Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 7) Adultry, Paulo Coelho, 234 除了行号，我们也可以使用文本模式指定地址，例如，在匹配 The Alchemist 的行之后追加文本 $ sed &apos;/The Alchemist/ a 7) Adultry, Paulo Coelho, 234&apos; books.txt 1) A Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 7) Adultry, Paulo Coelho, 234 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 行替换命令 cSED通过 c 提供了 change 和 replace 命令，该命令帮助我们使用新文本替换已经存在的行，当提供行的地址范围时，所有的行都被作为一组被替换为单行文本，下面是该命令的语法 [address1[,address2]]c\\ Replace text 比如，替换文本中的第三行为新的内容 $ sed &apos;3 c 3) Adultry, Paulo Coelho, 324&apos; books.txt 1) A Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 3) Adultry, Paulo Coelho, 324 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 SED也接受模式作为地址 $ sed &apos;/The Alchemist/ c 3) Adultry, Paulo Coelho, 324&apos; books.txt 1) A Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 3) Adultry, Paulo Coelho, 324 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 多行替换也是支持的，下面的命令实现了将第4-6行内容替换为单行 $ sed &apos;4, 6 c 4) Adultry, Paulo Coelho, 324&apos; books.txt 1) A Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 4) Adultry, Paulo Coelho, 324 插入命令 i插入命令与追加命令类似，唯一的区别是插入命令是在匹配的位置前插入新的一行。 [address]i\\ Insert text 下面的命令会在第四行前插入新的一行 $ sed &apos;4 i 7) Adultry, Paulo Coelho, 324&apos; books.txt 1) A Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 7) Adultry, Paulo Coelho, 324 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 转换命令 y转换（Translate）命令 y 是唯一可以处理单个字符的sed编辑器命令。转换命令格式 如下 [address]y/inchars/outchars/ 转换命令会对inchars和outchars值进行一对一的映射。inchars中的第一个字符会被转换为outchars中的第一个字符，第二个字符会被转换成outchars中的第二个字符。这个映射过程会一直持续到处理完指定字符。如果inchars和outchars的长度不同，则sed编辑器会产生一 条错误消息。 $ echo &quot;1 5 15 20&quot; | sed &apos;y/151520/IVXVXX/&apos; I V IV XX 输出隐藏字符命令 l你能通过直接观察区分出单词是通过空格还是tab进行分隔的吗？显然是不能的，但是SED可以为你做到这点。使用l命令（英文字母L的小写）可以显示文本中的隐藏字符（例如\\t或者$字符）。 [address1[,address2]]l [address1[,address2]]l [len] 为了测试该命令，我们首先将books.txt中的空格替换为tab。 $ sed &apos;s/ /\\t/g&apos; books.txt &gt; junk.txt 接下来执行l命令 $ sed -n &apos;l&apos; junk.txt 1)\\tStorm\\tof\\tSwords,\\tGeorge\\tR.\\tR.\\tMartin,\\t1216\\t$ 2)\\tThe\\tTwo\\tTowers,\\tJ.\\tR.\\tR.\\tTolkien,\\t352\\t$ 3)\\tThe\\tAlchemist,\\tPaulo\\tCoelho,\\t197\\t$ 4)\\tThe\\tFellowship\\tof\\tthe\\tRing,\\tJ.\\tR.\\tR.\\tTolkien,\\t432\\t$ 5)\\tThe\\tPilgrimage,\\tPaulo\\tCoelho,\\t288\\t$ 6)\\tA\\tGame\\tof\\tThrones,\\tGeorge\\tR.\\tR.\\tMartin,\\t864$ 使用l命令的时候，一个很有趣的特性是我们可以使用它来实现文本按照指定的宽度换行。 $ sed -n &apos;l 25&apos; books.txt 1) Storm of Swords, Geor\\ ge R. R. Martin, 1216 $ 2) The Two Towers, J. R.\\ R. Tolkien, 352 $ 3) The Alchemist, Paulo \\ Coelho, 197 $ 4) The Fellowship of the\\ Ring, J. R. R. Tolkien,\\ 432 $ 5) The Pilgrimage, Paulo\\ Coelho, 288 $ 6) A Game of Thrones, Ge\\ orge R. R. Martin, 864$ 上面的示例中在l命令后跟了一个数字25，它告诉SED按照每行25个字符进行换行，如果指定这个数字为0的话，则只有在存在换行符的情况下才进行换行。 l命令是GNU-SED的一部分，其它的一些变体中可能无法使用该命令。 退出命令 q在SED中，可以使用Quit命令退出当前的执行流 [address]q [address]q [value] 需要注意的是，q命令不支持地址范围，只支持单个地址匹配。默认情况下SED会按照读取、执行、重复的工作流执行，但当它遇到q命令的时候，它会退出当前的执行流。 $ sed &apos;3 q&apos; books.txt 1) A Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 $ sed &apos;/The Alchemist/ q&apos; books.txt 1) A Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 q命令也支持提供一个value，这个value将作为程序的返回代码返回 $ sed &apos;/The Alchemist/ q 100&apos; books.txt 1) A Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 $ echo $? 100 文件读取命令 r在SED中，我们可以让SED使用Read命令从外部文件中读取内容并且在满足条件的时候显示出来。 [address]r file 需要注意的是，r命令和文件名之间必须只有一个空格。 下面的示例会打开junk.txt文件，将其内容插入到books.txt文件的第三行之后 $ echo &quot;This is junk text.&quot; &gt; junk.txt $ sed &apos;3 r junk.txt&apos; books.txt 1) A Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 This is junk text. 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 r命令也支持地址范围，例如3, 5 r junk.txt会在第三行，第四行，第五行后面分别插入junk.txt的内容 执行外部命令 e如果你看过三十分钟学会AWK一文，你可能已经知道了在AWK中可以执行外部的命令，那么在SED中我们是否也可以这样做？ 答案是肯定的，在SED中，我们可以使用e命令执行外部命令 [address1[,address2]]e [command] 下面的命令会在第三行之前执行date命令 $ sed &apos;3 e date&apos; books.txt 1) Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 2016年11月29日 星期二 22时46分14秒 CST 3) The Alchemist, Paulo Coelho, 197 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 另一个示例 $ sed &apos;3,5 e who&apos; books.txt 1) Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 mylxsw console Nov 29 19:30 mylxsw ttys000 Nov 29 22:45 3) The Alchemist, Paulo Coelho, 197 mylxsw console Nov 29 19:30 mylxsw ttys000 Nov 29 22:45 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 mylxsw console Nov 29 19:30 mylxsw ttys000 Nov 29 22:45 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 如果你仔细观察e命令的语法，你会发现其实它的command参数是可选的。在没有提供外部命令的时候，SED会将模式空间中的内容作为要执行的命令。 $ echo -e &quot;date\\ncal\\nuname&quot; &gt; commands.txt $ cat commands.txt date cal uname $ sed &apos;e&apos; commands.txt 2016年11月29日 星期二 22时50分30秒 CST 十一月 2016 日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 Darwin 排除命令 !感叹号命令（!）用来排除命令，也就是让原本会起作用的命令不起作用。 $ sed -n &apos;/Paulo/p&apos; books.txt 3) The Alchemist, Paulo Coelho, 197 5) The Pilgrimage, Paulo Coelho, 288 $ sed -n &apos;/Paulo/!p&apos; books.txt 1) Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 6) A Game of Thrones, George R. R. Martin, 864 如上例所示，p命令原先是只输出匹配Paulo的行，添加!之后，变成了只输出不匹配Paulo的行。 $ sed -n &apos;1!G; h; $p&apos; books.txt 6) A Game of Thrones, George R. R. Martin, 864 5) The Pilgrimage, Paulo Coelho, 288 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 3) The Alchemist, Paulo Coelho, 197 2) The Two Towers, J. R. R. Tolkien, 352 1) Storm of Swords, George R. R. Martin, 1216 上面的命令实现了类似tac命令类似的输出，将文本内容倒序输出。看起来有些晦涩难懂，分解一下却十分简单： 1!G 这句的意思是出了第一行之外，处理每一行的时候都将保持空间中的内容追加到模式空间（正序-&gt;倒序） h 将模式空间中的内容复制到保持空间以备下一行匹配的时候追加到下一行的后面 $p 如果匹配到最后一行的话则输出模式空间中的内容 上述步骤不断重复直到文本结束刚好将文件内容翻转了一次 多行命令在使用sed编辑器的基础命令时，你可能注意到了一个局限。所有的sed编辑器命令都是针对单行数据执行操作的。在sed编辑器读取数据流时，它会基于换行符的位置将数据分成行。sed编辑器根据定义好的脚本命令一次处理一行数据，然后移到下一行重复这个过程。 幸运的是，sed编辑器的设计人员已经考虑到了这种情况，并设计了对应的解决方案。sed编辑器包含了三个可用来处理多行文本的特殊命令。 N：将数据流中的下一行加进来创建一个多行组来处理 D：删除多行组中的一行 P：打印多行组中的一行 N - 加载下一行默认情况下，SED是基于单行进行操作的，有些情况下我们可能需要使用多行进行编辑，启用多行编辑使用N命令，与n不同的是，N并不会清除、输出模式空间的内容，而是采用了追加模式。 [address1[,address2]]N 下面的示例将会把books2.txt中的标题和作者放到同一行展示，并且使用逗号进行分隔 $ sed &apos;N; s/\\n/,/g&apos; books2.txt A Storm of Swords ,George R. R. Martin The Two Towers ,J. R. R. Tolkien The Alchemist ,Paulo Coelho The Fellowship of the Ring ,J. R. R. Tolkien The Pilgrimage ,Paulo Coelho A Game of Thrones ,George R. R. Martin D - 删除多行中的一行sed编辑器提供了多行删除命令D，它只删除模式空间中的第一行。该命令会删除到换行符（含 换行符）为止的所有字符。 $ echo &apos;\\nThis is the header line.\\nThis is a data line.\\n\\nThis is the last line.&apos; | sed &apos;/^$/{N; /header/D}&apos; This is the header line. This is a data line. This is the last line. P - 输出多行中的一行P命令用于输出N命令创建的多行文本的模式空间中的第一行。 [address1[,address2]]P 例如下面的命令只输出了图书的标题 $ sed -n &apos;N;P&apos; books2.txt A Storm of Swords The Two Towers The Alchemist The Fellowship of the Ring The Pilgrimage A Game of Thrones 其它命令n - 单行next小写的n命令会告诉sed编辑器移动到数据流中的下一文本行，并且覆盖当前模式空间中的行。 $ cat data1.txt This is the header line. This is a data line. This is the last line. $ sed &apos;/header/{n ; d}&apos; data1.txt This is the header line. This is a data line. This is the last line. 上面的命令中，首先会匹配包含header的行，之后将移动到数据流的下一行，这里是一个空行，然后执行d命令对改行进行删除，所有就看到了这样的结果：第一个空行被删除掉了。 v - SED版本检查v命令用于检查SED的版本，如果版本大于参数中的版本则正常执行，否则失败 [address1[,address2]]v [version] 例如 $ sed --version sed (GNU sed) 4.2.2 $ sed &apos;v 4.2.3&apos; books.txt sed: -e expression #1, char 7: expected newer version of sed $ sed &apos;v 4.2.2&apos; books.txt 1) Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 特殊字符在SED中提供了两个可以用作命令的特殊字符：= 和 &amp; 。 =命令=命令用于输出行号，语法格式为 [/pattern/]= [address1[,address2]]= 例如为每一行输出行号 $ sed &apos;=&apos; books2.txt 1 A Storm of Swords 2 George R. R. Martin ... 只为1-4行输出行号 $ sed &apos;1, 4=&apos; books2.txt 1 A Storm of Swords 2 George R. R. Martin 3 The Two Towers 4 J. R. R. Tolkien The Alchemist Paulo Coelho The Fellowship of the Ring J. R. R. Tolkien The Pilgrimage Paulo Coelho A Game of Thrones George R. R. Martin 匹配Paulo的行输出行号 $ sed &apos;/Paulo/ =&apos; books2.txt A Storm of Swords George R. R. Martin The Two Towers J. R. R. Tolkien The Alchemist 6 Paulo Coelho The Fellowship of the Ring J. R. R. Tolkien The Pilgrimage 10 Paulo Coelho A Game of Thrones George R. R. Martin 最后一行输出行号，这个命令比较有意思了，可以用于输出文件总共有多少行 $ sed -n &apos;$ =&apos; books2.txt 12 &amp;命令特殊字符&amp;用于存储匹配模式的内容，通常与替换命令s一起使用。 $ sed &apos;s/[[:digit:]]/Book number &amp;/&apos; books.txt Book number 1) Storm of Swords, George R. R. Martin, 1216 Book number 2) The Two Towers, J. R. R. Tolkien, 352 Book number 3) The Alchemist, Paulo Coelho, 197 Book number 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 Book number 5) The Pilgrimage, Paulo Coelho, 288 Book number 6) A Game of Thrones, George R. R. Martin, 864 上述命令用于匹配每一行第一个数字，在其前面添加 Book number 。而下面这个命令则匹配最后一个数字，并修改为Pages =。其中[[:digit:]]* *$可能比较费解，这一部分其实是：匹配0个或多个数字+0个或多个空格+行尾。 sed &apos;s/[[:digit:]]* *$/Pages = &amp;/&apos; books.txt 1) Storm of Swords, George R. R. Martin, Pages = 1216 2) The Two Towers, J. R. R. Tolkien, Pages = 352 3) The Alchemist, Paulo Coelho, Pages = 197 4) The Fellowship of the Ring, J. R. R. Tolkien, Pages = 432 5) The Pilgrimage, Paulo Coelho, Pages = 288 6) A Game of Thrones, George R. R. Martin, Pages = 864 字符串替换命令 s文本替换命令非常常见，其格式如下 [address1[,address2]]s/pattern/replacement/[flags] 在前面我们使用的books.txt文件中，我们使用逗号“,”分隔每一列，下面的示例中，我们会使用替换命令将其替换为管道符“|”： $ sed &apos;s/,/ |/&apos; books.txt 1) Storm of Swords | George R. R. Martin, 1216 2) The Two Towers | J. R. R. Tolkien, 352 3) The Alchemist | Paulo Coelho, 197 4) The Fellowship of the Ring | J. R. R. Tolkien, 432 5) The Pilgrimage | Paulo Coelho, 288 6) A Game of Thrones | George R. R. Martin, 864 是不是觉得哪里不对？相信你已经发现，每一行的第二个逗号都没有被替换，只有第一个被替换了，确实如此，在SED中，使用替换命令的时候默认只会对第一个匹配的位置进行替换。使用g选项告诉SED对所有内容进行替换： $ sed &apos;s/,/ | /g&apos; books.txt 1) Storm of Swords | George R. R. Martin | 1216 2) The Two Towers | J. R. R. Tolkien | 352 3) The Alchemist | Paulo Coelho | 197 4) The Fellowship of the Ring | J. R. R. Tolkien | 432 5) The Pilgrimage | Paulo Coelho | 288 6) A Game of Thrones | George R. R. Martin | 864 如果对匹配模式（或地址范围）的行进行替换，则只需要在s命令前添加地址即可。比如只替换匹配The Pilgrimage的行：sed &#39;/The Pilgrimage/ s/,/ | /g&#39; books.txt 还有一些其它的选项，这里就简单的描述一下，不在展开讲解 数字n: 只替换第n次匹配，比如sed &#39;s/,/ | /2&#39; books.txt，只替换每行中第二个逗号 p：只输出改变的行，比如sed -n &#39;s/Paulo Coelho/PAULO COELHO/p&#39; books.txt w：存储改变的行到文件，比如sed -n &#39;s/Paulo Coelho/PAULO COELHO/w junk.txt&#39; books.txt i：匹配时忽略大小写，比如sed -n &#39;s/pAuLo CoElHo/PAULO COELHO/pi&#39; books.txt 在执行替换操作的时候，如果要替换的内容中包含/，这个时候怎么办？很简单，添加转义操作符。 $ echo &quot;/bin/sed&quot; | sed &apos;s/\\/bin\\/sed/\\/home\\/mylxsw\\/src\\/sed\\/sed-4.2.2\\/sed/&apos; /home/mylxsw/src/sed/sed-4.2.2/sed 上面的命令中，我们使用\\对/进行了转义，不过表达式已经看起来非常难看了，在SED中还可以使用|，@，^，!作为命令的分隔符，所以，下面的几个命令和上面的是等价的 echo &quot;/bin/sed&quot; | sed &apos;s|/bin/sed|/mylxsw/mylxsw/src/sed/sed-4.2.2/sed|&apos; echo &quot;/bin/sed&quot; | sed &apos;s@/bin/sed@/home/mylxsw/src/sed/sed-4.2.2/sed@&apos; echo &quot;/bin/sed&quot; | sed &apos;s^/bin/sed^/home/mylxsw/src/sed/sed-4.2.2/sed^&apos; echo &quot;/bin/sed&quot; | sed &apos;s!/bin/sed!/home/mylxsw/src/sed/sed-4.2.2/sed!&apos; 匹配子字符串前面我们学习了替换命令的用法，现在让我们看看如何获取匹配文本中的某个子串。 在SED中，使用\\(和\\)对匹配的内容进行分组，使用\\N的方式进行引用。请看下面示例 $ echo &quot;Three One Two&quot; | sed &apos;s|\\(\\w\\+\\) \\(\\w\\+\\) \\(\\w\\+\\)|\\2 \\3 \\1|&apos; One Two Three 我们输出了Three，One，Two三个单词，在SED的替换规则中，使用空格分隔了三小段正则表达式\\(\\w\\+\\)来匹配每一个单词，后面使用\\1，，\\2，\\3分别引用它们的值。 管理模式前面已经讲解过模式空间和保持空间的用法，在本节中我们将会继续探索它们的用法。 本部分内容暂未更新，请关注程序猿成长计划 项目，我将最先在Github的这个仓库中更新最新内容。 正则表达式这一部分就是标准正则表达式的一些特殊字符以元字符，比较熟悉的请略过。 标准正则表达式^匹配行的开始。 $ sed -n &apos;/^The/ p&apos; books2.txt The Two Towers, J. R. R. Tolkien The Alchemist, Paulo Coelho The Fellowship of the Ring, J. R. R. Tolkien The Pilgrimage, Paulo Coelho $匹配行的结尾 $ sed -n &apos;/Coelho$/ p&apos; books2.txt The Alchemist, Paulo Coelho The Pilgrimage, Paulo Coelho .匹配单个字符（除行尾） $ echo -e &quot;cat\\nbat\\nrat\\nmat\\nbatting\\nrats\\nmats&quot; | sed -n &apos;/^..t$/p&apos; cat bat rat mat []匹配字符集 $ echo -e &quot;Call\\nTall\\nBall&quot; | sed -n &apos;/[CT]all/ p&apos; Call Tall [\\^]排除字符集 $ echo -e &quot;Call\\nTall\\nBall&quot; | sed -n &apos;/[^CT]all/ p&apos; Ball [-]字符范围。 $ echo -e &quot;Call\\nTall\\nBall&quot; | sed -n &apos;/[C-Z]all/ p&apos; Call Tall \\? ，\\+ ，*分别对应0次到1次，一次到多次，0次到多次匹配。 {n} ，{n,} ，{m, n}精确匹配N次，至少匹配N次，匹配M-N次 |或操作。 $ echo -e &quot;str1\\nstr2\\nstr3\\nstr4&quot; | sed -n &apos;/str\\(1\\|3\\)/ p&apos; str1 str3 POSIX兼容的正则主要包含[:alnum:]，[:alpha:]，[:blank:]，[:digit:]，[:lower:]，[:upper:]，[:punct:]，[:space:]，这些基本都见名之意，不在赘述。 元字符\\s匹配单个空白内容 $ echo -e &quot;Line\\t1\\nLine2&quot; | sed -n &apos;/Line\\s/ p&apos; Line 1 \\S匹配单个非空白内容。 \\w ， \\W单个单词、非单词。 常用代码段Cat命令模拟cat命令比较简单，有下面两种方式 $ sed &apos;&apos; books.txt 1) Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 $ sed -n &apos;p&apos; books.txt 1) Storm of Swords, George R. R. Martin, 1216 2) The Two Towers, J. R. R. Tolkien, 352 3) The Alchemist, Paulo Coelho, 197 4) The Fellowship of the Ring, J. R. R. Tolkien, 432 5) The Pilgrimage, Paulo Coelho, 288 6) A Game of Thrones, George R. R. Martin, 864 移除空行$ echo -e &quot;Line #1\\n\\n\\nLine #2&quot; | sed &apos;/^$/d&apos; Line #1 Line #2 删除连续空行$ echo -e &quot;Line #1\\n\\n\\nLine #2&quot; | sed &apos;/./,/^$/!d&apos; Line #1 Line #2 删除开头的空行$ echo -e &quot;\\nLine #1\\n\\nLine #2&quot; | sed &apos;/./,$!d&apos; Line #1 Line #2 删除结尾的空行$ echo -e &quot;\\nLine #1\\nLine #2\\n\\n&quot; | sed &apos;:start /^\\n*$/{$d; N; b start }&apos; Line #1 Line #2 过滤所有的html标签$ cat html.txt &lt;html&gt; &lt;head&gt; &lt;title&gt;This is the page title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; This is the &lt;b&gt;first&lt;/b&gt; line in the Web page. This should provide some &lt;i&gt;useful&lt;/i&gt; information to use in our sed script. &lt;/body&gt; &lt;/html&gt; $ sed &apos;s/&lt;[^&gt;]*&gt;//g ; /^$/d&apos; html.txt This is the page title This is the first line in the Web page. This should provide some useful information to use in our sed script. 从C++程序中移除注释有下面这样一个cpp文件 $ cat hello.cpp #include &lt;iostream&gt; using namespace std; int main(void) { // Displays message on stdout. cout &gt;&gt; &quot;Hello, World !!!&quot; &gt;&gt; endl; return 0; // Return success. } 执行下面的命令可以移除注释 $ sed &apos;s|//.*||g&apos; hello.cpp #include &lt;iostream&gt; using namespace std; int main(void) { cout &gt;&gt; &quot;Hello, World !!!&quot; &gt;&gt; endl; return 0; } 为某些行添加注释$ sed &apos;3,5 s/^/#/&apos; hello.sh #!/bin/bash #pwd #hostname #uname -a who who -r lsb_release -a 实现Wc -l命令wc -l命令用于统计文件中的行数，使用SED也可以模拟该命令 $ wc -l hello.cpp 9 hello.cpp $ sed -n &apos;$ =&apos; hello.cpp 9 模拟实现head命令head命令用于输出文件中的前10行内容。 $ head books2.txt A Storm of Swords George R. R. Martin The Two Towers J. R. R. Tolkien The Alchemist Paulo Coelho The Fellowship of the Ring J. R. R. Tolkien The Pilgrimage Paulo Coelho 使用SED中的sed &#39;10 q&#39;可以模拟它的实现 $ sed &apos;10 q&apos; books.txt A Storm of Swords George R. R. Martin The Two Towers J. R. R. Tolkien The Alchemist Paulo Coelho The Fellowship of the Ring J. R. R. Tolkien The Pilgrimage Paulo Coelho 模拟tail -1命令tail -1输出文件的最后一行。 $ cat test.txt Line #1 Line #2 $ tail -1 test.txt Line #2 $ sed $ sed -n &apos;$p&apos; test.txt Line #2 模拟Dos2unix命令在DOS环境中，换行符是使用CR/LF两个字符一起表示的，下面命令模拟了dos2unix命令转换这些换行符为UNIX换行符。 在GNU/Linux环境中，CR/LF通常使用”\\^M”（不是简单的两个符号组合，请使用快捷键Ctrl+v,Ctrl+m输入）进行表示。 $ echo -e &quot;Line #1\\r\\nLine #2\\r&quot; &gt; test.txt $ file test.txt test.txt: ASCII text, with CRLF line terminators $ sed &apos;s/^M$//&apos; test.txt &gt; new.txt $ file new.txt new.txt: ASCII text $ cat -vte new.txt Line #1$ Line #2$ 模拟Unix2dos命令$ file new.txt new.txt: ASCII text $ sed &apos;s/$/\\r/&apos; new.txt &gt; new2.txt $ file new2.txt new2.txt: ASCII text, with CRLF line terminators $ cat -vte new2.txt Line #1^M$ Line #2^M$ 模拟cat -E命令cat -E命令会在每一行的行尾输出一个$符号。 $ echo -e &quot;Line #1\\nLine #2&quot; | cat -E Line #1$ Line #2$ $ echo -e &quot;Line #1\\nLine #2&quot; | sed &apos;s|$|&amp;$|&apos; Line #1$ Line #2$ 注意，在Mac下不支持cat -E，可以直接使用sed代替 模拟cat -ET命令cat -ET命令不仅对每一行的行尾添加$，还会将每一行中的TAB显示为^I。 $ echo -e &quot;Line #1\\tLine #2&quot; | cat -ET Line #1^ILine #2$ $ echo -e &quot;Line #1\\tLine #2&quot; | sed -n &apos;l&apos; | sed &apos;y/\\\\t/^I/&apos; Line #1^ILine #2$ 模拟nl命令命令nl可以为输入内容的每一行添加行号，记得之前介绍的=操作符吧，在SED中我们可以用它来实现与nl命令类似的功能。 $ echo -e &quot;Line #1\\nLine #2&quot; |nl 1 Line #1 2 Line #2 $ echo -e &quot;Line #1\\nLine #2&quot; | sed = | sed &apos;N;s/\\n/\\t/&apos; 1 Line #1 2 Line #2 上面的SED命令使用了两次，第一次使用=操作符为每一行输出行号，注意这个行号是独占一行的，因此使用管道符连接了第二个SED命令，每次读取两行，将换行符替换为Tab，这样就模拟出了nl命令的效果。 模拟cp命令$ sed -n &apos;w dup.txt&apos; data.txt $ diff data.txt dup.txt $ echo $? 0 模拟expand命令expand命令会转换输入中的TAB为空格，在SED中也可以模拟它 $ echo -e &quot;One\\tTwo\\tThree&quot; &gt; test.txt $ expand test.txt &gt; expand.txt $ sed &apos;s/\\t/ /g&apos; test.txt &gt; new.txt $ diff new.txt expand.txt $ echo $? 0 模拟tee命令tee命令会将数据输出到标准输出的同时写入文件。 $ echo -e &quot;Line #1\\nLine #2&quot; | tee test.txt Line #1 Line #2 在SED中，实现该命令非常简单 $ sed -n &apos;p; w new.txt&apos; test.txt One Two Three 模拟cat -s命令cat -s命令会将输入文件中的多行空格合并为一行。 $ echo -e &quot;Line #1\\n\\n\\n\\nLine #2\\n\\n\\nLine #3&quot; | cat -s Line #1 Line #2 Line #3 在SED中实现 $ echo -e &quot;Line #1\\n\\n\\n\\nLine #2\\n\\n\\nLine #3&quot; | sed &apos;1s/^$//p;/./,/^$/!d&apos; Line #1 Line #2 Line #3 这里需要注意的是/./,/^$/!d这个命令，它的意思是匹配区间/./到/^$，区间的开始会匹配至少包含一个字符的行，结束会匹配一个空行，在这个区间中的行不会被删除。 模拟grep命令$ echo -e &quot;Line #1\\nLine #2\\nLine #3&quot; | grep &apos;Line #1&apos; Line #1 $ echo -e &quot;Line #1\\nLine #2\\nLine #3&quot; | sed -n &apos;/Line #1/p&apos; Line #1 模拟grep -v命令$ echo -e &quot;Line #1\\nLine #2\\nLine #3&quot; | grep -v &apos;Line #1&apos; Line #2 Line #3 $ echo -e &quot;Line #1\\nLine #2\\nLine #3&quot; | sed -n &apos;/Line #1/!p&apos; Line #2 Line #3 模拟tr命令tr命令用于字符转换 $ echo &quot;ABC&quot; | tr &quot;ABC&quot; &quot;abc&quot; abc $ echo &quot;ABC&quot; | sed &apos;y/ABC/abc/&apos; abc 写在最后看到这里，你肯定要吐槽了，不是说了三十分钟学会吗？你确定你能三十分钟学会？上次的三十分钟学会AWK说三十分钟学会不靠谱，这次又不靠谱了。不好意思，这里的三十分钟其实只是为了吸引你的注意而已，只有在你已经用过SED并对它的一些特性有所了解的情况下三十分钟看完才是有可能的，毕竟那么多特殊字符，那么多命令需要记住。不过话说回来，看完之后你有收获吗？有的话，那本文的目的就达到了，之后用到SED的时候再回来参考一下就可以了。 本文将会持续修正和更新，最新内容请参考我的 GITHUB 上的 程序猿成长计划 项目，欢迎 Star。 参考 Sed Tutorial Linux命令行与shell脚本编程大全（第3版）","categories":[{"name":"Repost","slug":"Repost","permalink":"http://blog.duanxu.tech/categories/Repost/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.duanxu.tech/tags/Linux/"},{"name":"Sed","slug":"Sed","permalink":"http://blog.duanxu.tech/tags/Sed/"}]},{"title":"[转]三十分钟学会AWK","slug":"2016/2016-12-27-转-三十分钟学会AWK","date":"2016-12-27T03:31:30.000Z","updated":"2018-12-07T12:36:43.441Z","comments":true,"path":"2016/12/27/2016/2016-12-27-转-三十分钟学会AWK/","link":"","permalink":"http://blog.duanxu.tech/2016/12/27/2016/2016-12-27-转-三十分钟学会AWK/","excerpt":"","text":"content{:toc} 原文链接：三十分钟学会AWK 本文大部分内容翻译自我开始学习AWK时看到的一篇英文文章 AWK Tutorial ，觉得对AWK入门非常有帮助，所以对其进行了粗略的翻译，并对其中部分内容进行了删减或者补充，希望能为对AWK感兴趣的小伙伴提供一份快速入门的教程，帮助小伙伴们快速掌握AWK的基本使用方式，当然，我也是刚开始学习AWK，本文在翻译或者补充的过程中肯定会有很多疏漏或者错误，希望大家能够帮忙指正。 本文将会持续修正和更新，最新内容请参考我的 GITHUB 上的 程序猿成长计划 项目，欢迎 Star。 概述AWK是一门解释型的编程语言。在文本处理领域它是非常强大的，它的名字来源于它的三位作者的姓氏：Alfred Aho， Peter Weinberger 和 Brian Kernighan。 GNU/Linux发布的AWK目前由自由软件基金会（FSF）进行开发和维护，通常也称它为 GNU AWK。 AWK的类型下面是几个AWK的变体： AWK - 原先来源于 AT &amp; T 实验室的的AWK NAWK - AT &amp; T 实验室的AWK的升级版 GAWK - 这就是GNU AWK。所有的GNU/Linux发布版都自带GAWK，它与AWK和NAWK完全兼容 AWK的典型用途使用AWK可以做很多任务，下面是其中一些 文本处理 输出格式化的文本报表 执行算数运算 执行字符串操作等等 工作流要成为AWK编程专家，你需要先知道它的内部实现机制，AWK遵循了非常简单的工作流 - 读取，执行和重复，下图描述了AWK的工作流。 Read AWK从输入流（文件，管道或者标准输入）中读取一行，然后存储到内存中。 Execute 所有的AWK命令都依次在输入上执行。默认情况下，AWK会对每一行执行命令，我们可以通过提供模式限制这种行为。 Repeat 处理过程不断重复，直到到达文件结尾。 程序结构现在，让我们先学习一下AWK的程序结构。 BEGIN 语句块BEGIN语句块的语法 BEGIN {awk-commands} BEGIN语句块在程序开始的使用执行，它只执行一次，在这里可以初始化变量。BEGIN是AWK的关键字，因此它必须为大写，注意，这个语句块是可选的。 BODY 语句块BODY语句块的语法 /pattern/ {awk-commands} BODY语句块中的命令会对输入的每一行执行，我们也可以通过提供模式来控制这种行为。注意，BODY语句块没有关键字。 END 语句块END语句块的语法 END {awk-commands} END语句块在程序的最后执行，END是AWK的关键字，因此必须为大写，它也是可选的。 让我们创建一个包含序号，学生姓名，科目名称和得分的文件 marks.txt。 1) Amit Physics 80 2) Rahul Maths 90 3) Shyam Biology 87 4) Kedar English 85 5) Hari History 89 下面的例子中我们将会显示文件内容，并且添加每一列的标题 $ awk &apos;BEGIN{printf &quot;Sr No\\tName\\tSub\\tMarks\\n&quot;} {print}&apos; marks.txt 上述代码执行后，输出以下内容 Sr No Name Sub Marks 1) Amit Physics 80 2) Rahul Maths 90 3) Shyam Biology 87 4) Kedar English 85 5) Hari History 89 在程序的开始，AWK在BEGIN语句中打印出标题。然后再BODY语句中，它会读取文件的每一行然后执行AWK的print命令将每一行的内容打印到标准输出。这个过程会一直重复直到文件的结尾。 基础语法AWK的使用非常简单，我们可以直接在命令行中执行AWK的命令，也可以从包含AWK命令的文本文件中执行。 AWK命令行我们可以使用单引号在命令行中指定AWK命令 awk [options] file ... 比如我们有一个包含下面内容的文本文件 marks.txt: 1) Amit Physics 80 2) Rahul Maths 90 3) Shyam Biology 87 4) Kedar English 85 5) Hari History 89 我们可以使用下面的命令显示该文件的完整内容 $ awk &apos;{print}&apos; marks.txt AWK程序文件我们可以使用脚本文件提供AWK命令 awk [options] -f file .... 首先，创建一个包含下面内容的文本文件 command.awk {print} 现在，我们可以让AWK执行该文件中的命令，这里我们实现了和上例同样的结果 $ awk -f command.awk marks.txt AWK标准选项AWK支持下列命令行标准选项 -v 变量赋值选项该选项将一个值赋予一个变量，它会在程序开始之前进行赋值，下面的例子描述了该选项的使用 $ awk -v name=Jerry &apos;BEGIN{printf &quot;Name = %s\\n&quot;, name}&apos; Name = Jerry --dump-variables[=file] 选项该选项会输出排好序的全局变量列表和它们最终的值到文件中，默认的文件是 awkvars.out。 $ awk --dump-variables &apos;&apos; $ cat awkvars.out ARGC: 1 ARGIND: 0 ARGV: array, 1 elements BINMODE: 0 CONVFMT: &quot;%.6g&quot; ERRNO: &quot;&quot; FIELDWIDTHS: &quot;&quot; FILENAME: &quot;&quot; FNR: 0 FPAT: &quot;[^[:space:]]+&quot; FS: &quot; &quot; IGNORECASE: 0 LINT: 0 NF: 0 NR: 0 OFMT: &quot;%.6g&quot; OFS: &quot; &quot; ORS: &quot;\\n&quot; RLENGTH: 0 RS: &quot;\\n&quot; RSTART: 0 RT: &quot;&quot; SUBSEP: &quot;\\034&quot; TEXTDOMAIN: &quot;messages&quot; --help 选项打印帮助信息。 $ awk --help Usage: awk [POSIX or GNU style options] -f progfile [--] file ... Usage: awk [POSIX or GNU style options] [--] &apos;program&apos; file ... POSIX options : GNU long options: (standard) -f progfile --file=progfile -F fs --field-separator=fs -v var=val --assign=var=val Short options : GNU long options: (extensions) -b --characters-as-bytes -c --traditional -C --copyright -d[file] --dump-variables[=file] -e &apos;program-text&apos; --source=&apos;program-text&apos; -E file --exec=file -g --gen-pot -h --help -L [fatal] --lint[=fatal] -n --non-decimal-data -N --use-lc-numeric -O --optimize -p[file] --profile[=file] -P --posix -r --re-interval -S --sandbox -t --lint-old -V --version --lint[=fatal] 选项该选项允许检查程序的不兼容性或者模棱两可的代码，当提供参数 fatal的时候，它会对待Warning消息作为Error。 $ awk --lint &apos;&apos; /bin/ls awk: cmd. line:1: warning: empty program text on command line awk: cmd. line:1: warning: source file does not end in newline awk: warning: no program text at all! --posix 选项该选项开启严格的POSIX兼容。 --profile[=file]选项该选项会输出一份格式化之后的程序到文件中，默认文件是 awkprof.out。 $ awk --profile &apos;BEGIN{printf&quot;---|Header|--\\n&quot;} {print} END{printf&quot;---|Footer|---\\n&quot;}&apos; marks.txt &gt; /dev/null $ cat awkprof.out # gawk 配置, 创建 Wed Oct 26 15:05:49 2016 # BEGIN 块 BEGIN { printf &quot;---|Header|--\\n&quot; } # 规则 { print $0 } # END 块 END { printf &quot;---|Footer|---\\n&quot; } --traditional 选项该选项会禁止所有的gawk规范的扩展。 --version 选项输出版本号 $ awk --version GNU Awk 3.1.7 版权所有 © 1989, 1991-2009 自由软件基金会(FSF)。 该程序为自由软件，你可以在自由软件基金会发布的 GNU 通用公共许可证(GPL)第 3版或以后版本下修改或重新发布。 该程序之所以被发布是因为希望他能对你有所用处，但我们不作任何担保。这包含 但不限于任何商业适售性以及针对特定目的的适用性的担保。详情参见 GNU 通用公 共许可证(GPL)。 你应该收到程序附带的一份 GNU 通用公共许可证(GPL)。如果没有收到，请参看 http://www.gnu.org/licenses/ 。 You have new mail in /var/spool/mail/root 基本使用示例本部分会讲述一些有用的AWK命令和它们的使用示例，所有的例子都是以下面的文本文件 marks.txt 为基础的 1) Amit Physics 80 2) Rahul Maths 90 3) Shyam Biology 87 4) Kedar English 85 5) Hari History 89 打印某列或者字段AWK可以只打印输入字段中的某些列。 $ awk &apos;{print $3 &quot;\\t&quot; $4}&apos; marks.txt Physics 80 Maths 90 Biology 87 English 85 History 89 在文件marks.txt中，第三列包含了科目名，第四列则是得分，上面的例子中，我们只打印出了这两列，$3 和 $4 代表了输入记录中的第三和第四个字段。 打印所有的行默认情况下，AWK会打印出所有匹配模式的行 $ awk &apos;/a/ {print $0}&apos; marks.txt 2) Rahul Maths 90 3) Shyam Biology 87 4) Kedar English 85 5) Hari History 89 上述命令会判断每一行中是否包含a，如果包含则打印该行，如果BODY部分缺失则默认会执行打印，因此，上述命令和下面这个是等价的 $ awk &apos;/a/&apos; marks.txt 打印匹配模式的列当模式匹配成功时，默认情况下AWK会打印该行，但是也可以让它只打印指定的字段。例如，下面的例子中，只会打印出匹配模式的第三和第四个字段。 $ awk &apos;/a/ {print $3 &quot;\\t&quot; $4}&apos; marks.txt Maths 90 Biology 87 English 85 History 89 任意顺序打印列$ awk &apos;/a/ {print $4 &quot;\\t&quot; $3}&apos; marks.txt 90 Maths 87 Biology 85 English 89 History 统计匹配模式的行数$ awk &apos;/a/{++cnt} END {print &quot;Count = &quot;, cnt}&apos; marks.txt Count = 4 打印超过18个字符的行$ awk &apos;length($0) &gt; 18&apos; marks.txt 3) Shyam Biology 87 4) Kedar English 85 内建变量AWK提供了很多内置的变量，它们在开发AWK脚本的过程中起着非常重要的角色。 标准AWK变量ARGC 命令行参数个数命令行中提供的参数个数 $ awk &apos;BEGIN {print &quot;Arguments =&quot;, ARGC}&apos; One Two Three Four Arguments = 5 ARGV 命令行参数数组存储命令行参数的数组，索引范围从0 - ARGC - 1。 $ awk &apos;BEGIN { for (i = 0; i &lt; ARGC - 1; ++i) { printf &quot;ARGV[%d] = %s\\n&quot;, i, ARGV[i] } }&apos; one two three four ARGV[0] = awk ARGV[1] = one ARGV[2] = two ARGV[3] = three CONVFMT 数字的约定格式代表了数字的约定格式，默认值是%.6g $ awk &apos;BEGIN { print &quot;Conversion Format =&quot;, CONVFMT }&apos; Conversion Format = %.6g ENVIRON 环境变量环境变量的关联数组 $ awk &apos;BEGIN { print ENVIRON[&quot;USER&quot;] }&apos; mylxsw FILENAME 当前文件名$ awk &apos;END {print FILENAME}&apos; marks.txt marks.txt FS 输入字段的分隔符代表了输入字段的分隔符，默认值为空格，可以通过-F选项在命令行选项中修改它。 $ awk &apos;BEGIN {print &quot;FS = &quot; FS}&apos; | cat -vte FS = $ $ awk -F , &apos;BEGIN {print &quot;FS = &quot; FS}&apos; | cat -vte FS = ,$ NF 字段数目代表了当前行中的字段数目，例如下面例子打印出了包含大于两个字段的行 $ echo -e &quot;One Two\\nOne Two Three\\nOne Two Three Four&quot; | awk &apos;NF &gt; 2&apos; One Two Three One Two Three Four NR 行号$ echo -e &quot;One Two\\nOne Two Three\\nOne Two Three Four&quot; | awk &apos;NR &lt; 3&apos; One Two One Two Three FNR 行号（相对当前文件）与NR相似，不过在处理多文件时更有用，获取的行号相对于当前文件。 OFMT 输出格式数字默认值为%.6g $ awk &apos;BEGIN {print &quot;OFMT = &quot; OFMT}&apos; OFMT = %.6g OFS 输出字段分隔符输出字段分隔符，默认为空格 $ awk &apos;BEGIN {print &quot;OFS = &quot; OFS}&apos; | cat -vte OFS = $ ORS 输出行分隔符默认值为换行符 $ awk &apos;BEGIN {print &quot;ORS = &quot; ORS}&apos; | cat -vte ORS = $ $ RLENGTH代表了 match 函数匹配的字符串长度。 $ awk &apos;BEGIN { if (match(&quot;One Two Three&quot;, &quot;re&quot;)) { print RLENGTH } }&apos; 2 RS 输入记录分隔符$ awk &apos;BEGIN {print &quot;RS = &quot; RS}&apos; | cat -vte RS = $ $ RSTARTmatch函数匹配的第一次出现位置 $ awk &apos;BEGIN { if (match(&quot;One Two Three&quot;, &quot;Thre&quot;)) { print RSTART } } 9 SUBSEP 数组子脚本的分隔符数组子脚本的分隔符，默认为\\034 $ awk &apos;BEGIN { print &quot;SUBSEP = &quot; SUBSEP }&apos; | cat -vte SUBSEP = ^\\$ $ 0 代表了当前行代表了当前行 $ awk &apos;{print $0}&apos; marks.txt 1) Amit Physics 80 2) Rahul Maths 90 3) Shyam Biology 87 4) Kedar English 85 5) Hari History 89 $n当前行中的第n个字段 $ awk &apos;{print $3 &quot;\\t&quot; $4}&apos; marks.txt Physics 80 Maths 90 Biology 87 English 85 History 89 GNU AWK的变量ARGIND当前被处理的ARGV的索引 $ awk &apos;{ print &quot;ARGIND = &quot;, ARGIND; print &quot;Filename = &quot;, ARGV[ARGIND] }&apos; junk1 junk2 junk3 ARGIND = 1 Filename = junk1 ARGIND = 2 Filename = junk2 ARGIND = 3 Filename = junk3 BINMODE在非POSIX系统上指定对所有的文件I/O采用二进制模式。 ERRORNO一个代表了getline跳转失败或者是close调用失败的错误的字符串。 $ awk &apos;BEGIN { ret = getline &lt; &quot;junk.txt&quot;; if (ret == -1) print &quot;Error:&quot;, ERRNO }&apos; Error: No such file or directory FIELDWIDTHS设置了空格分隔的字段宽度变量列表的话，GAWK会将输入解析为固定宽度的字段，而不是使用FS进行分隔。 IGNORECASE设置了这个变量的话，AWK会忽略大小写。 $ awk &apos;BEGIN{IGNORECASE = 1} /amit/&apos; marks.txt 1) Amit Physics 80 LINT提供了对–lint选项的动态控制。 $ awk &apos;BEGIN {LINT = 1; a}&apos; awk: cmd. line:1: warning: reference to uninitialized variable `a&apos; awk: cmd. line:1: warning: statement has no effect PROCINFO包含进程信息的关联数组，例如UID，进程ID等 $ awk &apos;BEGIN { print PROCINFO[&quot;pid&quot;] }&apos; 4316 TEXTDOMAIN代表了AWK的文本域，用于查找字符串的本地化翻译。 $ awk &apos;BEGIN { print TEXTDOMAIN }&apos; messages 操作符与其它编程语言一样，AWK也提供了大量的操作符。 算数操作符算数操作符不多说，直接看例子，无非就是+-*/% $ awk &apos;BEGIN { a = 50; b = 20; print &quot;(a + b) = &quot;, (a + b) }&apos; (a + b) = 70 $ awk &apos;BEGIN { a = 50; b = 20; print &quot;(a - b) = &quot;, (a - b) }&apos; (a - b) = 30 $ awk &apos;BEGIN { a = 50; b = 20; print &quot;(a * b) = &quot;, (a * b) }&apos; (a * b) = 1000 $ awk &apos;BEGIN { a = 50; b = 20; print &quot;(a / b) = &quot;, (a / b) }&apos; (a / b) = 2.5 $ awk &apos;BEGIN { a = 50; b = 20; print &quot;(a % b) = &quot;, (a % b) }&apos; (a % b) = 10 增减运算符自增自减与C语言一致。 $ awk &apos;BEGIN { a = 10; b = ++a; printf &quot;a = %d, b = %d\\n&quot;, a, b }&apos; a = 11, b = 11 $ awk &apos;BEGIN { a = 10; b = --a; printf &quot;a = %d, b = %d\\n&quot;, a, b }&apos; a = 9, b = 9 $ awk &apos;BEGIN { a = 10; b = a++; printf &quot;a = %d, b = %d\\n&quot;, a, b }&apos; a = 11, b = 10 $ awk &apos;BEGIN { a = 10; b = a--; printf &quot;a = %d, b = %d\\n&quot;, a, b }&apos; a = 9, b = 10 赋值操作符$ awk &apos;BEGIN { name = &quot;Jerry&quot;; print &quot;My name is&quot;, name }&apos; My name is Jerry $ awk &apos;BEGIN { cnt = 10; cnt += 10; print &quot;Counter =&quot;, cnt }&apos; Counter = 20 $ awk &apos;BEGIN { cnt = 100; cnt -= 10; print &quot;Counter =&quot;, cnt }&apos; Counter = 90 $ awk &apos;BEGIN { cnt = 10; cnt *= 10; print &quot;Counter =&quot;, cnt }&apos; Counter = 100 $ awk &apos;BEGIN { cnt = 100; cnt /= 5; print &quot;Counter =&quot;, cnt }&apos; Counter = 20 $ awk &apos;BEGIN { cnt = 100; cnt %= 8; print &quot;Counter =&quot;, cnt }&apos; Counter = 4 $ awk &apos;BEGIN { cnt = 2; cnt ^= 4; print &quot;Counter =&quot;, cnt }&apos; Counter = 16 $ awk &apos;BEGIN { cnt = 2; cnt **= 4; print &quot;Counter =&quot;, cnt }&apos; Counter = 16 关系操作符$ awk &apos;BEGIN { a = 10; b = 10; if (a == b) print &quot;a == b&quot; }&apos; a == b $ awk &apos;BEGIN { a = 10; b = 20; if (a != b) print &quot;a != b&quot; }&apos; a != b $ awk &apos;BEGIN { a = 10; b = 20; if (a &lt; b) print &quot;a &lt; b&quot; }&apos; a &lt; b $ awk &apos;BEGIN { a = 10; b = 10; if (a &lt;= b) print &quot;a &lt;= b&quot; }&apos; a &lt;= b $ awk &apos;BEGIN { a = 10; b = 20; if (b &gt; a ) print &quot;b &gt; a&quot; }&apos; b &gt; a 逻辑操作符$ awk &apos;BEGIN { num = 5; if (num &gt;= 0 &amp;&amp; num &lt;= 7) printf &quot;%d is in octal format\\n&quot;, num }&apos; 5 is in octal format $ awk &apos;BEGIN { ch = &quot;\\n&quot;; if (ch == &quot; &quot; || ch == &quot;\\t&quot; || ch == &quot;\\n&quot;) print &quot;Current character is whitespace.&quot; }&apos; Current character is whitespace. $ awk &apos;BEGIN { name = &quot;&quot;; if (! length(name)) print &quot;name is empty string.&quot; }&apos; name is empty string. 三元操作符$ awk &apos;BEGIN { a = 10; b = 20; (a &gt; b) ? max = a : max = b; print &quot;Max =&quot;, max}&apos; Max = 20 一元操作符$ awk &apos;BEGIN { a = -10; a = +a; print &quot;a =&quot;, a }&apos; a = -10 $ awk &apos;BEGIN { a = -10; a = -a; print &quot;a =&quot;, a }&apos; a = 10 指数操作符$ awk &apos;BEGIN { a = 10; a = a ^ 2; print &quot;a =&quot;, a }&apos; a = 100 $ awk &apos;BEGIN { a = 10; a ^= 2; print &quot;a =&quot;, a }&apos; a = 100 字符串连接操作符$ awk &apos;BEGIN { str1 = &quot;Hello, &quot;; str2 = &quot;World&quot;; str3 = str1 str2; print str3 }&apos; Hello, World 数组成员操作符$ awk &apos;BEGIN { arr[0] = 1; arr[1] = 2; arr[2] = 3; for (i in arr) printf &quot;arr[%d] = %d\\n&quot;, i, arr[i] }&apos; arr[2] = 3 arr[0] = 1 arr[1] = 2 正则表达式操作符正则表达式操作符使用 ~ 和 !~ 分别代表匹配和不匹配。 $ awk &apos;$0 ~ 9&apos; marks.txt 2) Rahul Maths 90 5) Hari History 89 $ awk &apos;$0 !~ 9&apos; marks.txt 1) Amit Physics 80 3) Shyam Biology 87 4) Kedar English 85 # 匹配正则表达式需要在表达式前后添加反斜线，与js类似吧 $ tail -n 40 /var/log/nginx/access.log | awk &apos;$0 ~ /ip\\[127\\.0\\.0\\.1\\]/&apos; 更多关于正则表达式请看后面的正则表达式部分 正则表达式AWK在处理正则表达式方面是非常强大的，使用简单的正则表达式可以处理非常复杂的问题。 $ echo -e &quot;cat\\nbat\\nfun\\nfin\\nfan&quot; | awk &apos;/f.n/&apos; fun fin fan $ echo -e &quot;This\\nThat\\nThere\\nTheir\\nthese&quot; | awk &apos;/^The/&apos; There Their $ echo -e &quot;knife\\nknow\\nfun\\nfin\\nfan\\nnine&quot; | awk &apos;/n$/&apos; fun fin fan $ echo -e &quot;Call\\nTall\\nBall&quot; | awk &apos;/[CT]all/&apos; Call Tall $ echo -e &quot;Call\\nTall\\nBall&quot; | awk &apos;/[^CT]all/&apos; Ball $ echo -e &quot;Call\\nTall\\nBall\\nSmall\\nShall&quot; | awk &apos;/Call|Ball/&apos; Call Ball $ echo -e &quot;Colour\\nColor&quot; | awk &apos;/Colou?r/&apos; Colour Color $ echo -e &quot;ca\\ncat\\ncatt&quot; | awk &apos;/cat*/&apos; ca cat catt $ echo -e &quot;111\\n22\\n123\\n234\\n456\\n222&quot; | awk &apos;/2+/&apos; 22 123 234 222 $ echo -e &quot;Apple Juice\\nApple Pie\\nApple Tart\\nApple Cake&quot; | awk &apos;/Apple (Juice|Cake)/&apos; Apple Juice Apple Cake 数组AWK支持关联数组，也就是说，不仅可以使用数字索引的数组，还可以使用字符串作为索引，而且数字索引也不要求是连续的。数组不需要声明可以直接使用，语法如下： array_name[index] = value 创建数组的方式非常简单，直接为变量赋值即可 $ awk &apos;BEGIN { fruits[&quot;mango&quot;] = &quot;yellow&quot;; fruits[&quot;orange&quot;] = &quot;orange&quot; print fruits[&quot;orange&quot;] &quot;\\n&quot; fruits[&quot;mango&quot;] }&apos; orange yellow 删除数组元素使用delete语句 $ awk &apos;BEGIN { fruits[&quot;mango&quot;] = &quot;yellow&quot;; fruits[&quot;orange&quot;] = &quot;orange&quot;; delete fruits[&quot;orange&quot;]; print fruits[&quot;orange&quot;] }&apos; 在AWK中，只支持一维数组，但是可以通过一维数组模拟多维，例如我们有一个3x3的三维数组 100 200 300 400 500 600 700 800 900 可以这样操作 $ awk &apos;BEGIN { array[&quot;0,0&quot;] = 100; array[&quot;0,1&quot;] = 200; array[&quot;0,2&quot;] = 300; array[&quot;1,0&quot;] = 400; array[&quot;1,1&quot;] = 500; array[&quot;1,2&quot;] = 600; # print array elements print &quot;array[0,0] = &quot; array[&quot;0,0&quot;]; print &quot;array[0,1] = &quot; array[&quot;0,1&quot;]; print &quot;array[0,2] = &quot; array[&quot;0,2&quot;]; print &quot;array[1,0] = &quot; array[&quot;1,0&quot;]; print &quot;array[1,1] = &quot; array[&quot;1,1&quot;]; print &quot;array[1,2] = &quot; array[&quot;1,2&quot;]; }&apos; array[0,0] = 100 array[0,1] = 200 array[0,2] = 300 array[1,0] = 400 array[1,1] = 500 array[1,2] = 600 流程控制流程控制语句与大多数语言一样，基本格式如下 if (condition) action if (condition) { action-1 action-1 . . action-n } if (condition) action-1 else if (condition2) action-2 else action-3 例如： $ awk &apos;BEGIN { num = 11; if (num % 2 == 0) printf &quot;%d is even number.\\n&quot;, num; else printf &quot;%d is odd number.\\n&quot;, num }&apos; $ awk &apos;BEGIN { a = 30; if (a==10) print &quot;a = 10&quot;; else if (a == 20) print &quot;a = 20&quot;; else if (a == 30) print &quot;a = 30&quot;; }&apos; 循环循环操作与其他C系语言一样，主要包括 for，while，do...while，break，continue 语句，当然，还有一个 exit语句用于退出脚本执行。 for (initialisation; condition; increment/decrement) action while (condition) action do action while (condition) 例子： $ awk &apos;BEGIN { for (i = 1; i &lt;= 5; ++i) print i }&apos; $ awk &apos;BEGIN {i = 1; while (i &lt; 6) { print i; ++i } }&apos; $ awk &apos;BEGIN {i = 1; do { print i; ++i } while (i &lt; 6) }&apos; $ awk &apos;BEGIN { sum = 0; for (i = 0; i &lt; 20; ++i) { sum += i; if (sum &gt; 50) break; else print &quot;Sum =&quot;, sum } }&apos; $ awk &apos;BEGIN { for (i = 1; i &lt;= 20; ++i) { if (i % 2 == 0) print i ; else continue } }&apos; $ awk &apos;BEGIN { sum = 0; for (i = 0; i &lt; 20; ++i) { sum += i; if (sum &gt; 50) exit(10); else print &quot;Sum =&quot;, sum } }&apos; exit用于退出脚本，参数为退出的状态码，可以通过shell中的$?获取 函数内建函数AWK提供了很多方便的内建函数供编程人员使用。由于函数比较多，个人觉得单纯看每个函数的使用也没有什么实际意义，比较容易遗忘，因此，这里只简单的列出常用的一些函数，只需要对其有个印象即可，使用的时候再去 查手册 效果会更好一些吧。 数学函数 atan2(y, x) cos(expr) exp(expr) int(expr) log(expr) rand sin(expr) sqrt(expr) srand([expr]) 字符串函数 asort(arr [, d [, how] ]) asorti(arr [, d [, how] ]) gsub(regex, sub, string) index(str, sub) length(str) match(str, regex) split(str, arr, regex) sprintf(format, expr-list) strtonum(str) sub(regex, sub, string) substr(str, start, l) tolower(str) toupper(str) 时间函数 systime mktime(datespec) strftime([format [, timestamp[, utc-flag]]]) 字节操作函数 and compl lshift rshift or xor 其它 close(expr) 关闭管道文件 请看下面这段代码 $ awk &apos;BEGIN { cmd = &quot;tr [a-z] [A-Z]&quot; print &quot;hello, world !!!&quot; |&amp; cmd close(cmd, &quot;to&quot;) cmd |&amp; getline out print out; close(cmd); }&apos; HELLO, WORLD !!! 是不是感觉很难懂？让我来解释一下 第一个语句cmd = &quot;tr [a-z] [A-Z]&quot;是我们在AWK中要用来建立双向连接的命令。 第二个语句print提供了tr命令的输入，使用 &amp;| 表名建立双向连接。 第三个语句close(cmd, &quot;to&quot;)用于执行完成后关闭to进程 第四个语句cmd |&amp; getline out使用getline函数存储输出到out变量 接下来打印变量out的内容，然后关闭cmd delete 用于删除数组元素 exit 退出脚本执行，并返回状态码参数 fflush getline 该命令让awk读取下一行内容 该命令让awk读取下一行内容，比如 $ awk &apos;{getline; print $0}&apos; marks.txt 2) Rahul Maths 90 4) Kedar English 85 5) Hari History 89 使用getline var &lt; file可以从file中读取输入，存储到变量var中 { if (NF == 2 &amp;&amp; $1 == &quot;@include&quot;) { while ((getline line &lt; $2) &gt; 0) print line # 这里的close确保如果文件中两个@include，可以让其读取两次 close($2) } else print } 命令的输出也可以通过管道输入到getline，使用command | getline这种方式。在这种情况下，字符串命令会作为shell命令执行，其标准输出会通过管道传递个awk作为其输入，这种形式的getline会从管道中一次读取一条记录。例如下面的命令会从输入中逐行读取，如果遇到@execute，则将该行作为命令执行，将命令的输出作为最终的输出内容 { if ($1 == &quot;@execute&quot;) { tmp = substr($0, 10) # Remove &quot;@execute&quot; while ((tmp | getline) &gt; 0) # 这里实际上设置了$0为这一行的内容 print close(tmp) } else print } 如果文件包含以下内容 foo bar baz @execute who bletch 则会输出 foo bar baz arnold ttyv0 Jul 13 14:22 miriam ttyp0 Jul 13 14:23 (murphy:0) bill ttyp1 Jul 13 14:23 (murphy:0) bletch 使用command | getline var可以实现将命令的输出写入到变量var。 BEGIN { &quot;date&quot; | getline current_time close(&quot;date&quot;) print &quot;Report printed on &quot; current_time } getline使用管道读取输入是一种单向的操作，在某些场景下，你可能希望发送数据到另一个进程，然后从这个进程中读取处理后的结果， 这就用到了协同进程，我们可以使用|&amp;打开一个双向管道。 print &quot;some query&quot; |&amp; &quot;db_server&quot; &quot;db_server&quot; |&amp; getline 同样，我们也可以使用command |&amp; getline var将协同进程的输出写入到变量var。 next nextfile return 用于用户自定义函数的返回值。 首先，创建一个functions.awk文件，包含下面的awk命令 function addition(num1, num2) { result = num1 + num2 return result } BEGIN { res = addition(10, 20) print &quot;10 + 20 = &quot; res } 执行上述代码，输出 10 + 20 = 30 system 该函数用于执行指定的命令并且返回它的退出状态，返回状态码0表示命令成功执行。 $ awk &apos;BEGIN { ret = system(&quot;date&quot;); print &quot;Return value = &quot; ret }&apos; 2016年 10月 27日 星期四 22:08:36 CST Return value = 0 用户自定义函数函数是程序基本的组成部分，AWK允许我们自己创建自定义的函数。一个大型的程序可以被划分为多个函数，每个函数之间可以独立的开发和测试，提供可重用的代码。 下面是用户自定义函数的基本语法 function function_name(argument1, argument2, ...) { function body } 例如，我们创建一个名为functions.awk的文件，包含下面的代码 # Returns minimum number function find_min(num1, num2){ if (num1 &lt; num2) return num1 return num2 } # Returns maximum number function find_max(num1, num2){ if (num1 &gt; num2) return num1 return num2 } # Main function function main(num1, num2){ # Find minimum number result = find_min(10, 20) print &quot;Minimum =&quot;, result # Find maximum number result = find_max(10, 20) print &quot;Maximum =&quot;, result } # Script execution starts here BEGIN { main(10, 20) } 执行上述代码，会得到下面的输出 Minimum = 10 Maximum = 20 输出重定向重定向操作符到目前为止，我们所有的程序都是直接显示数据到了标准输出流，其实，我们也可以将输出重定向到文件。重定向操作符跟在print和printf函数的后面，与shell中的用法基本一致。 print DATA &gt; output-file print DATA &gt;&gt; output-file 例如，下面两条命令输出是一致的 $ echo &quot;Hello, World !!!&quot; &gt; /tmp/message.txt $ awk &apos;BEGIN { print &quot;Hello, World !!!&quot; &gt; &quot;/tmp/message.txt&quot; }&apos; 与shell中一样，&gt;用于将输出写入到指定的文件中，如果文件中有内容则覆盖，而&gt;&gt;则为追加模式写入。 $ awk &apos;BEGIN { print &quot;Hello, World !!!&quot; &gt;&gt; &quot;/tmp/message.txt&quot; }&apos; $ cat /tmp/message.txt 管道除了将输出重定向到文件之外，我们还可以将输出重定向到其它程序，与shell中一样，我们可以使用管道操作符|。 $ awk &apos;BEGIN { print &quot;hello, world !!!&quot; | &quot;tr [a-z] [A-Z]&quot; }&apos; HELLO, WORLD !!! AWK中可以使用|&amp;进行双向连接，那么什么是双向连接呢？一种常见的场景是我们发送数据到另一个程序处理，然后读取处理结果，这种场景下就需要打开一个到另外一个进程的双向管道了。第二个进程会与gawk程序并行执行，这里称其为 协作进程。与单向连接使用|操作符不同的是，双向连接使用|&amp;操作符。 do { print data |&amp; &quot;subprogram&quot; &quot;subprogram&quot; |&amp; getline results } while (data left to process) close(&quot;subprogram&quot;) 第一次I/O操作使用了|&amp;操作符，gawk会创建一个到运行其它程序的子进程的双向管道，print的输出被写入到了subprogram的标准输入，而这个subprogram的标准输出在gawk中使用getline函数进行读取。 注意：目前协同进程的标准错误输出将会和gawk的标准错误输出混杂在一起，无法单独获取标准错误输出。另外，I/O缓冲可能存在问题，gawk程序会自动的刷新所有输出到下游的协同进程的管道。但是，如果协同进程没有刷新其标准输出的话，gawk将可能会在使用getline函数从协同进程读取输出的时候挂起，这就可能引起死锁。 我们可以使用close函数关闭双向管道的to或者from一端，这两个字符串值告诉gawk发送数据到协同进程完成时或者从协同进程读取完毕时关闭管道。在使用系统命令sort的时候是这样做是非常必要的，因为它必须等所有输出都读取完毕时才能进行排序。 BEGIN { command = &quot;LC_ALL=C sort&quot; n = split(&quot;abcdefghijklmnopqrstuvwxyz&quot;, a, &quot;&quot;) for (i = n; i &gt; 0; i--) print a[i] |&amp; command close(command, &quot;to&quot;) while ((command |&amp; getline line) &gt; 0) print &quot;got&quot;, line close(command) } 例如，下面的例子中使用tr命令转换小写为大写。我们的command.awk文件包含以下内容 BEGIN { cmd = &quot;tr [a-z] [A-Z]&quot; print &quot;hello, world !!!&quot; |&amp; cmd close(cmd, &quot;to&quot;) cmd |&amp; getline out print out; close(cmd); } 输出 HELLO, WORLD !!! 上例看起来有些复杂，我们逐行分析一下 首先，第一行 cmd = “tr [a-z] [A-Z]” 是在AWK中要建立双向连接的命令 第二行的print命令用于为tr命令提供输入，而 |&amp; 用于指出要建立双向连接 第三行用于在上面的语句close(cmd, “to”),在执行完成后关闭其to进程 第四行 cmd |&amp; getline out使用getline函数存储输出到变量out中 最后一行使用close函数关闭命令 美化输出到目前为止，我们已经使用过print和printf函数显示数据到标准输出，但是printf函数实际上要比我们之前使用的情况更加强大得多。该函数是从C语言中借鉴来的，在处理格式化的输出时非常有用。 $ awk &apos;BEGIN { printf &quot;Hello\\nWorld\\n&quot; }&apos; Hello World $ awk &apos;BEGIN { printf &quot;ASCII value 65 = character %c\\n&quot;, 65 }&apos; ASCII value 65 = character A 格式化输出标识有 %c， %d，%s 等，基本与C语言一致，这里就不多赘述了。 执行shell命令在AWK中执行shell命令有两种方式 使用system函数 使用管道 使用system函数system函数用于执行操作系统命令并且返回命令的退出码到awk。 END { system(&quot;date | mail -s &apos;awk run done&apos; root&quot;) } 使用管道如果要执行的命令很多，可以将输出的命令直接用管道传递给“/bin/sh”执行 while (more stuff to do) print command | &quot;/bin/sh&quot; close(&quot;/bin/sh&quot;) 参考 AWK Tutorial The GNU Awk User’s Guide 本文将会持续修正和更新，最新内容请参考我的 GITHUB 上的 程序猿成长计划 项目，欢迎 Star。","categories":[{"name":"Repost","slug":"Repost","permalink":"http://blog.duanxu.tech/categories/Repost/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.duanxu.tech/tags/Linux/"},{"name":"Awk","slug":"Awk","permalink":"http://blog.duanxu.tech/tags/Awk/"}]},{"title":"[转]Java中的反射总结","slug":"2016/2016-12-20-转-Java中的反射总结","date":"2016-12-20T03:48:30.000Z","updated":"2018-12-07T12:36:39.768Z","comments":true,"path":"2016/12/20/2016/2016-12-20-转-Java中的反射总结/","link":"","permalink":"http://blog.duanxu.tech/2016/12/20/2016/2016-12-20-转-Java中的反射总结/","excerpt":"","text":"content{:toc} 原文链接：Java中的反射总结 刚开始学习java的时候真的很难理解反射到底是个什么东西 一些书籍，哪怕是很经典的书籍都解释的让人感觉懵懵的，或许的确是我太笨 况且，网上说在将来学习框架的时候需要经常应用到反射机制，这样一来总让人心里有些不安 就方才偶然又把讲解反射的章节和视频看了一点，觉得能理解一些了 现在决定一鼓作气，边看边写，顺便把一些主要的内容和操作都记载到这里 我想，对于我这么一个笨笨的人来说，学习的最好方法也许就是不断重复 遇到不懂的知识就停下来把以往的重新学一遍，虽然浪费了很多时间，但对我也有些效果 我的理解是：所谓反射，就是根据一个已经实例化了的对象来还原类的完整信息 至少对我而言，我认为它带给我的好处是，让我从下往上的又了解了一遍面向对象 x_x 在此又痛恨一边那些厚部头们，把我的脑细胞搞死一片 1 Class类如果要完成反射，那么必须了解Class类 实例1：通过对象取得包名和类名 12345678910111213package org.siu; class Test &#123; &#125; public class Demo &#123; public static void main(String[] args) &#123; Test t = new Test(); System.out.println(t.getClass()); System.out.println(t.getClass().getName()); &#125;&#125; 编译结果如下，注意包的编译方式即可 此处的getClass()方法是默认继承自Object类的 class cn.com.duanxu.Testcn.com.duanxu.Test 在java中，Object类是所有类的父类，同样，所有类的实例化对象也都是Class类的实例 因此，这样一来就会牵扯到向上转型和向下转型的概念 由于向下转型的不安全因素，在这里泛型也会接踵而来 （不过我想说的是，此处的泛型设计很刺眼！尼玛，整个java的语法设计同样刺眼，超恶心！！！） 实例2：Class类的实例化 由于Class类没有构造方法，所以实例化Class类的方式有点特殊，有三种方式： 对象.getClass( ) 类.Class forName( ) 123456789101112131415161718192021222324252627class Test &#123; &#125; public class Demo &#123; public static void main(String[] args) &#123; //方式一： Test t = new Test(); Class&lt;? extends Test&gt; c1 = t.getClass(); System.out.println(c1); //方式二： //为了避免特殊性，这里不用Test类，而用java库中的String类 Class&lt;String&gt; c2 = String.class; System.out.println(c2); //方式三： //forName()方法会抛出异常 Class&lt;?&gt; c3 = null; try &#123; c3 = Class.forName(\"cn.com.duanxu.Test\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; System.out.println(c3); &#125;&#125; 其中，forName( )方法需要重点掌握，因为它可以在类不确定的情况下实例化Class，更具灵活性 class cn.com.duanxu.Testclass java.lang.Stringclass cn.com.duanxu.Test 2 Class类的应用Class类中有一个方法叫做newInstance( ),它可以用来创建一个Class类对象的新实例 怎么说呢？Class对象包含的内容就是反射好的那个类，我们要构造那个类的新实例（新对象） 实例3：Class类的无参构造对象 12345678910111213141516171819202122232425public class Demo &#123; public static void main(String[] args) &#123; //实例化Class对象，forName()方法会抛异常 Class&lt;?&gt; c = null; try &#123; //这里需要完整的包名和类名 c = Class.forName(\"java.lang.String\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; //生成一个字符串的引用 String s = null; try &#123; //将构造好的对象向下转型为String类 //newInstance()方法会抛异常 s = (String) c.newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; System.out.println(\"字符串长度： \" + s.length()); &#125;&#125; 这样就通过无参数的形式构造了一个新的对象，如同正常模式中 通过无参构造方法来构造新对象一样 字符串长度： 0 我们知道，类中除了有无参构造方法，还会存在有参数的构造方法 那在反射中如何通过有参数的形式构造对象呢？接着看 实例4：Class类的有参构造对象 1234567891011121314151617181920import java.lang.reflect.Constructor; public class Demo &#123; //下面的几个方法抛出来的异常太多，为了代码的紧凑性，这里就直接抛给虚拟机了 public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; c = null; try &#123; c = Class.forName(\"java.lang.String\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; char[] ch = &#123;'h','e','l','l','o'&#125;; String s = null; //获得Class类对象的有参构造方法，括号里面参数的写法是：类型.class Constructor&lt;?&gt; con = c.getConstructor(char[].class); //用此构造方法构造一个新的字符串对象，参数为一个char数组 s = (String) con.newInstance(ch); System.out.println(\"构造的字符串：\" + s); &#125;&#125; 我们还是使用String类做例，因为String类用的比较多，便于理解 这里需要注意的是，构造方法需要使用getConstructor( )方法获得 至于参数类型则是：原有类型.class 构造的字符串：hello 还有一点，无论是有参还是无参，这里所使用的构造方法，原本的类里面必须对应存在 那么，如何才能知道原有类里面的构造方法，普通方法，继承的父类等详细信息呢？接着看 3 获取类的结构要通过反射获取类的结构我们这里要导入一个新的包java.lang.reflect 实例5：取得类的构造方法 123456789101112131415161718import java.lang.reflect.Constructor;import java.util.Arrays; public class Demo &#123; //下面的几个方法抛出来的异常太多，为了代码的紧凑性，这里就直接抛给虚拟机了 public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; c = null; try &#123; c = Class.forName(\"java.lang.Boolean\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; //这里的getConstructors()方法返回的是一个Constructor数组 Constructor&lt;?&gt;[] cons = c.getConstructors(); //打印的方式你可以自己写，为了方便我用Arrays.toString()，凑合着看 System.out.println(Arrays.toString(cons)); &#125;&#125; 我选择了Boolean类来做例，因为Boolean类的构造方法就两个，方便看 [public java.lang.Boolean(boolean), public java.lang.Boolean(java.lang.String)] 实例6：取得类所实现的接口 1234567891011121314import java.util.Arrays; public class Demo &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; c = null; try &#123; c = Class.forName(\"java.lang.Boolean\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Class&lt;?&gt;[] in = c.getInterfaces(); System.out.println(Arrays.toString(in)); &#125;&#125; 没什么好说的，看结果 [interface java.io.Serializable, interface java.lang.Comparable] 实例7：取得父类 12345678910111213public class Demo &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; c = null; try &#123; c = Class.forName(\"java.lang.Boolean\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; //注意了，这里不会是数组，why？ Class&lt;?&gt; su = c.getSuperclass(); System.out.println(su); &#125;&#125; 别忘了，java中是单继承，父类只有一个 class java.lang.Object 实例8：取得类的全部方法 1234567891011121314151617import java.lang.reflect.Method; public class Demo &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; c = null; try &#123; c = Class.forName(\"java.lang.Boolean\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Method[] m = c.getMethods(); //好吧，这次我就大发慈悲的写个打印列表出来 for (int i = 0; i &lt; m.length; i++) &#123; System.out.println(m[i]); &#125; &#125;&#125; 截取一部分，看看，意思下就行了……这几个例子都比较简单 public boolean java.lang.Boolean.equals(java.lang.Object)public java.lang.String java.lang.Boolean.toString()public static java.lang.String java.lang.Boolean.toString(boolean)public static int java.lang.Boolean.hashCode(boolean)public int java.lang.Boolean.hashCode()public int java.lang.Boolean.compareTo(java.lang.Boolean)public int java.lang.Boolean.compareTo(java.lang.Object)public static boolean java.lang.Boolean.getBoolean(java.lang.String)public boolean java.lang.Boolean.booleanValue()public static java.lang.Boolean java.lang.Boolean.valueOf(java.lang.String)public static java.lang.Boolean java.lang.Boolean.valueOf(boolean)public static int java.lang.Boolean.compare(boolean,boolean)public static boolean java.lang.Boolean.parseBoolean(java.lang.String)public static boolean java.lang.Boolean.logicalAnd(boolean,boolean)public static boolean java.lang.Boolean.logicalOr(boolean,boolean)public static boolean java.lang.Boolean.logicalXor(boolean,boolean)public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionpublic final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionpublic final void java.lang.Object.wait() throws java.lang.InterruptedExceptionpublic final native java.lang.Class java.lang.Object.getClass()public final native void java.lang.Object.notify()public final native void java.lang.Object.notifyAll() 实例9：取得本类的全部属性 123456789101112131415161718192021import java.lang.reflect.Field; class Person &#123; private String name; private int age;&#125; public class Demo &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; c = null; try &#123; c = Class.forName(\"Person\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Field[] f = c.getDeclaredFields(); for (int i = 0; i &lt; f.length; i++) &#123; System.out.println(f[i]); &#125; &#125;&#125; getDeclaredFielsd()方法可以获取全部属性，getFields()只能获取公共属性 private java.lang.String Person.nameprivate int Person.age 实例10：获取本类中属性的值 1234567891011121314151617181920212223242526272829303132import java.lang.reflect.Field; class Person &#123; public String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125; public class Demo &#123; public static void main(String[] args) throws Exception &#123; Person p = new Person(\"zhangsan\",12); Class&lt;?&gt; c = p.getClass(); //获取公共属性的值 Field f1 = c.getField(\"name\"); //get(p)表明要获取是哪个对象的值 String str = (String) f1.get(p); System.out.println(\"姓名： \" + str); //获取私有属性的值 Field f2 = c.getDeclaredField(\"age\"); //age是私有属性，所以要设置安全检查为true f2.setAccessible(true); int age = (int) f2.get(p); System.out.println(\"年龄： \" + age); &#125;&#125; 要注意的是：setAccessible()方法可以设置是否访问和修改私有属性 姓名： zhangsan年龄： 12 坦白说，java学到现在我还没发现什么能亮瞎我钛金眼的知识在里边 每次都是写一堆繁琐的语法实现个小玩意儿，不然就是拼命调用API，拼命的抛异常 让本身显得不够紧凑的代码变得愈发累赘 如果我喜欢一门语言，在我利用它做出东西来之前，它本身的特性必须能够打动我 显然，java并不让我快乐，也许很多程序员跟我一样是被迫使用java的 仅以此来安抚我那颗孤独编码的心，下面接着看内容 4 反射的应用实例11：通过反射修改属性 12345678910111213141516171819202122232425262728import java.lang.reflect.Field; class Person &#123; private String name; public Person(String name) &#123; this.name = name; &#125; public String toString() &#123; return \"姓名： \" + this.name; &#125;&#125; public class Demo &#123; public static void main(String[] args) throws Exception &#123; Person p = new Person(\"王二狗\"); System.out.println(p); Class&lt;?&gt; c = p.getClass(); //定义要修改的属性 Field f = c.getDeclaredField(\"name\"); f.setAccessible(true); //修改属性，传入要设置的对象和值 f.set(p, \"张二蛋\"); System.out.println(p); &#125;&#125; 几个方法都是有联系的，如果看不懂就先熟悉上面几个例子 姓名： 王二狗姓名： 张二蛋 实例12：通过反射调用方法 123456789101112131415161718192021222324252627import java.lang.reflect.Method; class Person &#123; public void print(int i) &#123; System.out.println(\"我在写数字： \" + i); &#125; public static void say(String str) &#123; System.out.println(\"我在说： \" + str); &#125;&#125; public class Demo &#123; public static void main(String[] args) throws Exception &#123; Person p = new Person(); Class&lt;?&gt; c = p.getClass(); //getMethod()方法需要传入方法名，和参数类型 Method m1 = c.getMethod(\"print\", int.class); //invoke()表示调用的意思，需要传入对象和参数 m1.invoke(p, 10); Method m2 = c.getMethod(\"say\", String.class); //这里的null表示不由对象调用，也就是静态方法 m2.invoke(null, \"你妹\"); &#125;&#125; 这里演示了一个普通的有参方法和一个静态方法 我在写数字： 10我在说： 你妹 既然有参数的都写出来了，那么无参的就更简单了，直接传入一个对象即可 实例13：通过反射操作数组 123456789101112131415161718192021import java.lang.reflect.Array; public class Demo &#123; public static void main(String[] args) throws Exception &#123; int[] arr = &#123;1,2,3,4,5&#125;; Class&lt;?&gt; c = arr.getClass().getComponentType(); System.out.println(\"数组类型： \" + c.getName()); int len = Array.getLength(arr); System.out.println(\"数组长度： \" + len); System.out.print(\"遍历数组： \"); for (int i = 0; i &lt; len; i++) &#123; System.out.print(Array.get(arr, i) + \" \"); &#125; System.out.println(); //修改数组 System.out.println(\"修改前的第一个元素： \" + Array.get(arr, 0)); Array.set(arr, 0, 3); System.out.println(\"修改后的第一个元素： \" + Array.get(arr, 0)); &#125;&#125; 这里要注意一点，getComponentType( )返回的是数组元素的Class 数组类型： int数组长度： 5遍历数组： 1 2 3 4 5修改前的第一个元素： 1修改后的第一个元素： 3 暂时就写这么多，我看的书中还有反射在工厂模式中的应用 无非是用forName()方法替换一下，没什么可说的 我是个java初级黑，我恨java那种恶心的语法和设计 这都是为了Android，为了打基础，为了适应以后的工作 Fuck java……","categories":[{"name":"Repost","slug":"Repost","permalink":"http://blog.duanxu.tech/categories/Repost/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.duanxu.tech/tags/Java/"},{"name":"Reflect","slug":"Reflect","permalink":"http://blog.duanxu.tech/tags/Reflect/"}]},{"title":"[转]Python爬虫实战 抓取图书馆借阅信息 ","slug":"2016/2016-12-19-转-Python爬虫实战-抓取图书馆借阅信息","date":"2016-12-19T01:48:30.000Z","updated":"2018-12-07T12:36:35.359Z","comments":true,"path":"2016/12/19/2016/2016-12-19-转-Python爬虫实战-抓取图书馆借阅信息/","link":"","permalink":"http://blog.duanxu.tech/2016/12/19/2016/2016-12-19-转-Python爬虫实战-抓取图书馆借阅信息/","excerpt":"","text":"content{:toc} 原文链接：Python爬虫实战—抓取图书馆借阅信息 前段时间在图书馆借了很多书，借得多了就容易忘记每本书的应还日期，老是担心自己会违约，影响日后借书，而自己又懒得总是登录到学校图书馆借阅系统查看，于是就打算写一个爬虫来抓取自己的借阅信息，把每本书的应还日期给爬下来，并写入txt文件，这样每次忘了就可以打开该txt文件查看，每次借阅信息改变了，只要再重新运行一遍该程序，原txt文件就会被新文件覆盖，里面的内容得到更新。 1 用到的技术 Python版本是 2.7 ，同时用到了urllib2、cookielib、re三个模块。urllib2用于创建请求(request)，并抓取网页信息，返回一个类似于文件类型的response对象；cookielib用于储存cookie对象，以实现模拟登录功能；re模块提供对正则表达式的支持，用于对抓取到的页面信息进行匹配，以得到自己想要的信息。 2 抓取一个页面 使用urllib2简单抓取一个网页的过程非常简单： 123import urllib2response = urllib2.urlopen(\"http://www.baidu.com\")html = response.read() urllib2中的urlopen()方法，看其字面意思就知道是打开一个URL(uniform resource locator)地址，上面例子传入的时百度首页的地址，遵循HTTP协议，除了http协议外，urlopen()方法还可以打开遵循ftp、file协议的地址，如： 1response = urllib2.urlopen(\"ftp://example.com\") 除URL参数外，urlopen()方法还接受data和timeout参数： 1response = urllib2.urlopen(url ,data ,timeout) 其中data是打开一个网页时需要传入的数据，比如打开一个登录界面时往往需要传入用户名和密码等信息，在下文登录图书馆系统时将会看到其用法；timeout是设置超时时间，即超过一定时间页面无响应即报错；在urlopen()方法中，data和timeout不是必须的，即可填可不填，注意：当页面需要有数据传入时，data是必需的。 可以看到，在打开一个网页时，有时往往需要传入多个参数，再加上HTTP协议是基于请求(request)和应答(response)的，即客户端发出请求(request)，服务器端返回应答(response)，所以在使用urlopen()方法时，往往是构造一个request对象作为参数传入，该request对象包括url、data、timeout、headers等信息： 1234import urllib2request = urllib2.Request(\"http://www.baidu.com\")response = urllib2.urlopen(request)html = response.read() 这段代码得到的结果和上面得到的结果一样，但是在逻辑上显得更明确、清晰。 3 Cookie的使用 在访问某些网站时，该网站需要在客户端本地储存一些数据、信息(经过加密)，并在接下来的请求(request)中返回给服务器，否则服务器将拒绝该请求，这些数据即存储在本地的cookie中。例如，访问学校图书馆系统时，需进行登录，等登录完成之后，服务器端将会在本地储存一些经过加密的数据在cookie中，当客户端发送查询借阅信息的请求(request)时，会连带cookie里面的数据一起发送给服务器，服务器确定cookie信息后允许访问，否则拒绝该请求。 Cookielib模块提供了CookieJar类用于捕捉和储存HTTP 的cookie数据，所以要创建一个cookie只要创建一个CookieJar实例即可： 12import cookielibcookie = coolielib.CookieJar() 创建cookie了就万事大吉了吗？没那么简单，我们要完成的操作是发送登录请求、记录cookie、再发送读取借阅信息的请求并向服务器反馈cookie信息，要完成这一系列的操作，原来的urlopen()方法已不能胜任，幸运的是，urllib2模块还提供了一个OpenerDirector类，可以接受一个cookie处理器为参数，实现上述功能，而这个cookie处理器则可以通过HTTPCookieProcessor类接受一个cookie对象实例化后得到。即先通过HTTPCookieProcessor实例化得到一个cookie处理器handler，再将此处理器headler作为参数传入OpenDirector实例化得到一个能捕捉cookie数据的opener，代码如下： 1234567import urllib2import cookielibcookie = cookielib.CookieJar()handler = urllib2.HTTPCookieProcessor(cookie)opener = urllib2.build_opener(handler)response = opener.open(\"http://www.baidu.com\") 4 登录图书馆系统 至此，我们就可以进行图书馆借阅信息的抓取了。来看看HIT图书馆登录界面： 首先，在Firefox浏览器下，借助httpfox插件进行网络监听，看看登录此页面需要向服务器发送哪些数据： 输入登录账号和密码，打开httpfox插件，点击start开始监听，然后点击登陆按钮进行登陆： 上图便是登陆之后的页面，以及整个登陆过程捕捉到的信息。选择第一条捕捉到的信息，点击下方数据头(Headers)选项卡，可以看见登录此页面需要发送的一些数据。有一些网站，对于访问它们的请求需要检查数据头(Headers)，只有数据头信息符合要求才允许访问。在登录图书馆系统时，可以先尝试不发数据头，如果能顺利访问则说明没有Headers检查这一环节。数据发送的方法为GET，即只需要将要发送的数据信息加在登陆请求的后面。在Headers选项卡的Request-Line属性中，问号前面的即为登陆请求”GET /lib/opacAction.do”，加上IP地址之后真实的请求URL为”http://202.118.250.131/lib/opacAction.do&quot;，问号后面的即为登陆需要的数据，包括账号、密码等信息。 接下来点开QueryString选项卡，查看由GET方法传送的数据： 需要传送的数据包括5项，以字典类型将其储存，经过urlencode()方法编码之后直接加在登陆URL之后即可，所以最后向服务器发送的请求(request)为： 1234567891011import urllib loginURL = 'http://202.118.250.131/lib/opacAction.do'queryString = urllib.urlencode(&#123; 'method':'DoAjax', 'dispatch':'login', 'registerName':'', 'rcardNo':'16S137028 0', 'pwd':'******' &#125;)requestURL = self.loginURL + '?' + self.queryString 得到请求URL之后就可以模拟登陆图书馆系统了，在模拟登陆的过程中需要用到前面讲到的cookie，否则无法进行后续的访问。在编代码过程中，定义一个library类，使访问过程变成一个面向对象的过程，可以根据需要实例化多个library对象，分别对多个实例进行操作。首先分析，该library类应该有一个初始化方法(init)以及一个获取页面的方法(getPage)，在打开网页是，应使用上文提到opener实例，自动捕获并储存cookie: 12345678910111213141516171819202122232425262728import urllibimport urllib2import cookielibimport reclass library: def __init__(self): self.loginURL='http://202.118.250.131/lib/opacAction.do' self.queryString = urllib.urlencode(&#123; 'method':'DoAjax', 'dispatch':'login', 'registerName':'', 'rcardNo':'16S137028 0', 'pwd':'114477yan' &#125;) self.requestURL = self.loginURL + '?' + self.queryString self.cookies=cookielib.CookieJar() self.handler=urllib2.HTTPCookieProcessor(self.cookies) self.opener=urllib2.build_opener(self.handler) def getPage(self): request1 = urllib2.Request(self.requestURL) request2 = urllib2.Request(' http://202.118.250.131/lib/opacAction.do?method=init&amp;seq=301 ') result = self.opener.open(request1) result = self.opener.open(request2) return result.read()lib = library()print lib.getPage() 上述代码中，先是进行登录result = self.opener.open(request1) ,登录没有异常，说明登录过程不用检查数据头；然后再用此self.opener打开借阅查询页面http://202.118.250.131/lib/opacAction.do?method=init&amp;seq=301，所以这段代码将打印借阅查询界面的HTML代码，下图是部分打印结果： 5 获取借阅信息 抓取了页面信息之后，接下来就是根据自己的需要匹配、储存信息了。在匹配页面信息时，这里用的是正则表达式的方式进行匹配，正则表达式的支持由Python的Re模块提供支持，关于如何使用正则表达式，可以参考这里：Python正则表达式指南 使用Re模块进行匹配时，往往先将正则表达式字符串编译(compile)成一个Pattern实例，再利用Re模块中的re.findall(pattern , string)，将字符串string中和正则表达式匹配的数据以列表的形式返回。如果在pattern中有超过一个组(group)，则返回的结果将是一个元组列表，如此正则表达式：1&lt;table.*?id=\"tb.*?width=\"50%\"&gt;&lt;font size=2&gt;(.*?)&lt;/font&gt;.*?&lt;tr&gt;.*?&lt;tr&gt;.*?&lt;font size=2&gt;(.*?)&lt;/font&gt;.*?&lt;font size=2&gt;(.*?)&lt;/font&gt;.*?&lt;/TABLE&gt; 式中，每一个(.*?)代表一个组，即此式中有3个组，则匹配时，返回一个元组列表，其中每一个元组又有3个数据。 在library类中，定义一个获取信息的方法(getInformation)，以通过正则表达式匹配的方式获取所需数据： 12345def getInformation(self): page = self.getPage() pattern = re.compile('&lt;table.*?id=\"tb.*?width=\"50%\"&gt;&lt;font size=2&gt;(.*?)&lt;/font&gt;.*?&lt;tr&gt;.*?&lt;tr&gt;.*?'+ '&lt;font size=2&gt;(.*?)&lt;/font&gt;.*?&lt;font size=2&gt;(.*?)&lt;/font&gt;.*?&lt;/TABLE&gt;',re.S) items = re.findall(pattern,page) 获取所需数据之后，接下来就是将数据写入文本文件(txt)储存，以读写模式(W+)打开一个文件(library.txt)，然后通过write()方法将数据一条一条的写入文件。不过，在信息写入之前，需要对抓取到的信息做一些小处理，刚才说过了，findall()方法返回的是一个元组列表，即[[a,b,c],[d,e,f],[g,h,i]]的形式，write()方法是不能对元组进行操作的，所以需要手动将元组翻译成一条条字符串，再保存到一个列表里，通过遍历将每条字符串写入文件： 12345678910111213141516def getInformation(self): page = self.getPage() pattern = re.compile('&lt;table.*?id=\"tb.*?width=\"50%\"&gt;&lt;font size=2&gt;(.*?)&lt;/font&gt;.*?&lt;tr&gt;.*?&lt;tr&gt;.*?'+ '&lt;font size=2&gt;(.*?)&lt;/font&gt;.*?&lt;font size=2&gt;(.*?)&lt;/font&gt;.*?&lt;/TABLE&gt;',re.S) items = re.findall(pattern,page) contents = [] for item in items: content = item[0]+' from '+item[1]+' to '+item[2]+'\\n' contents.append(content) self.writeData(contents)def writeData(self,contents): file = open('libraryBooks.txt','w+') for content in contents: file.write(content) file.close() 至此，整个爬虫就算完成了，下面贴上完整代码： 6 大功告成12345678910111213141516171819202122232425262728293031323334353637383940414243444546__author__='Victor'#_*_ coding:'utf-8' _*_import urllibimport urllib2import cookielibimport reclass library: def __init__(self): self.loginURL='http://202.118.250.131/lib/opacAction.do' self.queryString = urllib.urlencode(&#123; 'method':'DoAjax', 'dispatch':'login', 'registerName':'', 'rcardNo':'16S137028 0', 'pwd':'******' &#125;) self.requestURL = self.loginURL + '?' + self.queryString self.cookies=cookielib.CookieJar() self.handler=urllib2.HTTPCookieProcessor(self.cookies) self.opener=urllib2.build_opener(self.handler) def getPage(self): request1 = urllib2.Request(self.requestURL) request2 = urllib2.Request('http://202.118.250.131/lib/opacAction.do?method=init&amp;seq=301') result = self.opener.open(request1) result = self.opener.open(request2) return result.read() def getInformation(self): page = self.getPage() pattern = re.compile('&lt;table.*?id=\"tb.*?width=\"50%\"&gt;&lt;font size=2&gt;(.*?)&lt;/font&gt;.*?&lt;tr&gt;.*?&lt;tr&gt;.*?'+ '&lt;font size=2&gt;(.*?)&lt;/font&gt;.*?&lt;font size=2&gt;(.*?)&lt;/font&gt;.*?&lt;/TABLE&gt;',re.S) items = re.findall(pattern,page) contents = [] for item in items: content = item[0]+' from '+item[1]+' to '+item[2]+'\\n' contents.append(content) self.writeData(contents) def writeData(self,contents): file = open('libraryBooks.txt','w+') for content in contents: file.write(content) file.close()lib = library()lib.getInformation() 下面就是抓到的借阅信息，不得不说效果不怎么样，不过还是凑合着看把：","categories":[{"name":"Repost","slug":"Repost","permalink":"http://blog.duanxu.tech/categories/Repost/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.duanxu.tech/tags/Python/"}]},{"title":"[转]用更合理的方式写 JavaScript","slug":"2016/2016-11-23-转-用更合理的方式写 JavaScript","date":"2016-11-23T10:49:30.000Z","updated":"2018-12-07T12:36:30.119Z","comments":true,"path":"2016/11/23/2016/2016-11-23-转-用更合理的方式写 JavaScript/","link":"","permalink":"http://blog.duanxu.tech/2016/11/23/2016/2016-11-23-转-用更合理的方式写 JavaScript/","excerpt":"","text":"content{:toc} Airbnb JavaScript Style Guide() {用更合理的方式写 JavaScript 原文链接 类型 原始值: 存取直接作用于它自身。 string number boolean null undefined 123456var foo = 1;var bar = foo;bar = 9;console.log(foo, bar); // =&gt; 1, 9 复杂类型: 存取时作用于它自身值的引用。 object array function 123456var foo = [1, 2];var bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9 ⬆ 回到顶部 对象 使用直接量创建对象。 12345// badvar item = new Object();// goodvar item = &#123;&#125;; 不要使用保留字作为键名，它们在 IE8 下不工作。更多信息。 1234567891011// badvar superman = &#123; default: &#123; clark: 'kent' &#125;, private: true&#125;;// goodvar superman = &#123; defaults: &#123; clark: 'kent' &#125;, hidden: true&#125;; 使用同义词替换需要使用的保留字。 1234567891011121314// badvar superman = &#123; class: 'alien'&#125;;// badvar superman = &#123; klass: 'alien'&#125;;// goodvar superman = &#123; type: 'alien'&#125;; ⬆ 回到顶部 数组 使用直接量创建数组。 12345// badvar items = new Array();// goodvar items = []; 向数组增加元素时使用 Array#push 来替代直接赋值。 12345678var someStack = [];// badsomeStack[someStack.length] = 'abracadabra';// goodsomeStack.push('abracadabra'); 当你需要拷贝数组时，使用 Array#slice。jsPerf 1234567891011var len = items.length;var itemsCopy = [];var i;// badfor (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// gooditemsCopy = items.slice(); 使用 Array#slice 将类数组对象转换成数组。 1234function trigger() &#123; var args = Array.prototype.slice.call(arguments); ...&#125; ⬆ 回到顶部 字符串 使用单引号 &#39;&#39; 包裹字符串。 1234567891011// badvar name = \"Bob Parr\";// goodvar name = 'Bob Parr';// badvar fullName = \"Bob \" + this.lastName;// goodvar fullName = 'Bob ' + this.lastName; 超过 100 个字符的字符串应该使用连接符写成多行。 注：若过度使用，通过连接符连接的长字符串可能会影响性能。jsPerf &amp; 讨论. 12345678910111213// badvar errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';// badvar errorMessage = 'This is a super long error that was thrown because \\of Batman. When you stop to think about how Batman had anything to do \\with this, you would get nowhere \\fast.';// goodvar errorMessage = 'This is a super long error that was thrown because ' + 'of Batman. When you stop to think about how Batman had anything to do ' + 'with this, you would get nowhere fast.'; 程序化生成的字符串使用 Array#join 连接而不是使用连接符。尤其是 IE 下：jsPerf. 12345678910111213141516171819202122232425262728293031323334353637383940var items;var messages;var length;var i;messages = [&#123; state: 'success', message: 'This one worked.'&#125;, &#123; state: 'success', message: 'This one worked as well.'&#125;, &#123; state: 'error', message: 'This one did not work.'&#125;];length = messages.length;// badfunction inbox(messages) &#123; items = '&lt;ul&gt;'; for (i = 0; i &lt; length; i++) &#123; items += '&lt;li&gt;' + messages[i].message + '&lt;/li&gt;'; &#125; return items + '&lt;/ul&gt;';&#125;// goodfunction inbox(messages) &#123; items = []; for (i = 0; i &lt; length; i++) &#123; // use direct assignment in this case because we're micro-optimizing. items[i] = '&lt;li&gt;' + messages[i].message + '&lt;/li&gt;'; &#125; return '&lt;ul&gt;' + items.join('') + '&lt;/ul&gt;';&#125; ⬆ 回到顶部 函数 函数表达式： 1234567891011121314// 匿名函数表达式var anonymous = function() &#123; return true;&#125;;// 命名函数表达式var named = function named() &#123; return true;&#125;;// 立即调用的函数表达式（IIFE）(function () &#123; console.log('Welcome to the Internet. Please follow me.');&#125;()); 永远不要在一个非函数代码块（if、while 等）中声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但它们的解析表现不一致。 注： ECMA-262 把 块 定义为一组语句。函数声明不是语句。阅读对 ECMA-262 这个问题的说明。 1234567891011121314// badif (currentUser) &#123; function test() &#123; console.log('Nope.'); &#125;&#125;// goodvar test;if (currentUser) &#123; test = function test() &#123; console.log('Yup.'); &#125;;&#125; 永远不要把参数命名为 arguments。这将取代函数作用域内的 arguments 对象。 123456789// badfunction nope(name, options, arguments) &#123; // ...stuff...&#125;// goodfunction yup(name, options, args) &#123; // ...stuff...&#125; ⬆ 回到顶部 属性 使用 . 来访问对象的属性。 12345678910var luke = &#123; jedi: true, age: 28&#125;;// badvar isJedi = luke['jedi'];// goodvar isJedi = luke.jedi; 当通过变量访问属性时使用中括号 []。 12345678910var luke = &#123; jedi: true, age: 28&#125;;function getProp(prop) &#123; return luke[prop];&#125;var isJedi = getProp('jedi'); ⬆ 回到顶部 变量 总是使用 var 来声明变量。不这么做将导致产生全局变量。我们要避免污染全局命名空间。 12345// badsuperPower = new SuperPower();// goodvar superPower = new SuperPower(); 使用 var 声明每一个变量。这样做的好处是增加新变量将变的更加容易，而且你永远不用再担心调换错 ; 跟 ,。 123456789101112131415// badvar items = getItems(), goSportsTeam = true, dragonball = 'z';// bad// （跟上面的代码比较一下，看看哪里错了）var items = getItems(), goSportsTeam = true; dragonball = 'z';// goodvar items = getItems();var goSportsTeam = true;var dragonball = 'z'; 最后再声明未赋值的变量。当你需要引用前面的变量赋值时这将变的很有用。 123456789101112131415161718// badvar i, len, dragonball, items = getItems(), goSportsTeam = true;// badvar i;var items = getItems();var dragonball;var goSportsTeam = true;var len;// goodvar items = getItems();var goSportsTeam = true;var dragonball;var length;var i; 在作用域顶部声明变量。这将帮你避免变量声明提升相关的问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// badfunction () &#123; test(); console.log('doing stuff..'); //..other stuff.. var name = getName(); if (name === 'test') &#123; return false; &#125; return name;&#125;// goodfunction () &#123; var name = getName(); test(); console.log('doing stuff..'); //..other stuff.. if (name === 'test') &#123; return false; &#125; return name;&#125;// bad - 不必要的函数调用function () &#123; var name = getName(); if (!arguments.length) &#123; return false; &#125; this.setFirstName(name); return true;&#125;// goodfunction () &#123; var name; if (!arguments.length) &#123; return false; &#125; name = getName(); this.setFirstName(name); return true;&#125; ⬆ 回到顶部 提升 变量声明会提升至作用域顶部，但赋值不会。 123456789101112131415161718// 我们知道这样不能正常工作（假设这里没有名为 notDefined 的全局变量）function example() &#123; console.log(notDefined); // =&gt; throws a ReferenceError&#125;// 但由于变量声明提升的原因，在一个变量引用后再创建它的变量声明将可以正常工作。// 注：变量赋值为 `true` 不会提升。function example() &#123; console.log(declaredButNotAssigned); // =&gt; undefined var declaredButNotAssigned = true;&#125;// 解释器会把变量声明提升到作用域顶部，意味着我们的例子将被重写成：function example() &#123; var declaredButNotAssigned; console.log(declaredButNotAssigned); // =&gt; undefined declaredButNotAssigned = true;&#125; 匿名函数表达式会提升它们的变量名，但不会提升函数的赋值。 123456789function example() &#123; console.log(anonymous); // =&gt; undefined anonymous(); // =&gt; TypeError anonymous is not a function var anonymous = function () &#123; console.log('anonymous function expression'); &#125;;&#125; 命名函数表达式会提升变量名，但不会提升函数名或函数体。 12345678910111213141516171819202122function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function superPower(); // =&gt; ReferenceError superPower is not defined var named = function superPower() &#123; console.log('Flying'); &#125;;&#125;// 当函数名跟变量名一样时，表现也是如此。function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function var named = function named() &#123; console.log('named'); &#125;&#125; 函数声明提升它们的名字和函数体。 1234567function example() &#123; superPower(); // =&gt; Flying function superPower() &#123; console.log('Flying'); &#125;&#125; 了解更多信息在 JavaScript Scoping &amp; Hoisting by Ben Cherry. ⬆ 回到顶部 比较运算符 &amp; 等号 优先使用 === 和 !== 而不是 == 和 !=. 条件表达式例如 if 语句通过抽象方法 ToBoolean 强制计算它们的表达式并且总是遵守下面的规则： 对象 被计算为 true Undefined 被计算为 false Null 被计算为 false 布尔值 被计算为 布尔的值 数字 如果是 +0、-0 或 NaN 被计算为 false，否则为 true 字符串 如果是空字符串 &#39;&#39; 被计算为 false，否则为 true 1234if ([0]) &#123; // true // 一个数组就是一个对象，对象被计算为 true&#125; 使用快捷方式。 12345678910111213141516171819// badif (name !== '') &#123; // ...stuff...&#125;// goodif (name) &#123; // ...stuff...&#125;// badif (collection.length &gt; 0) &#123; // ...stuff...&#125;// goodif (collection.length) &#123; // ...stuff...&#125; 了解更多信息在 Truth Equality and JavaScript by Angus Croll. ⬆ 回到顶部 块 使用大括号包裹所有的多行代码块。 12345678910111213141516171819// badif (test) return false;// goodif (test) return false;// goodif (test) &#123; return false;&#125;// badfunction () &#123; return false; &#125;// goodfunction () &#123; return false;&#125; 如果通过 if 和 else 使用多行代码块，把 else 放在 if 代码块关闭括号的同一行。 12345678910111213141516// badif (test) &#123; thing1(); thing2();&#125;else &#123; thing3();&#125;// goodif (test) &#123; thing1(); thing2();&#125; else &#123; thing3();&#125; ⬆ 回到顶部 注释 使用 /** ... */ 作为多行注释。包含描述、指定所有参数和返回值的类型和值。 123456789101112131415161718192021222324252627// bad// make() returns a new element// based on the passed in tag name//// @param &#123;String&#125; tag// @return &#123;Element&#125; elementfunction make(tag) &#123; // ...stuff... return element;&#125;// good/** * make() returns a new element * based on the passed in tag name * * @param &#123;String&#125; tag * @return &#123;Element&#125; element */function make(tag) &#123; // ...stuff... return element;&#125; 使用 // 作为单行注释。在评论对象上面另起一行使用单行注释。在注释前插入空行。 12345678910111213141516171819202122232425// badvar active = true; // is current tab// good// is current tabvar active = true;// badfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' var type = this.type || 'no type'; return type;&#125;// goodfunction getType() &#123; console.log('fetching type...'); // set the default type to 'no type' var type = this.type || 'no type'; return type;&#125; 给注释增加 FIXME 或 TODO 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。这将有别于常见的注释，因为它们是可操作的。使用 FIXME -- need to figure this out 或者 TODO -- need to implement。 使用 // FIXME: 标注问题。 1234567function Calculator() &#123; // FIXME: shouldn't use a global here total = 0; return this;&#125; 使用 // TODO: 标注问题的解决方式。 1234567function Calculator() &#123; // TODO: total should be configurable by an options param this.total = 0; return this;&#125; ⬆ 回到顶部 空白 使用 2 个空格作为缩进。 1234567891011121314// badfunction () &#123;∙∙∙∙var name;&#125;// badfunction () &#123;∙var name;&#125;// goodfunction () &#123;∙∙var name;&#125; 在大括号前放一个空格。 123456789101112131415161718192021// badfunction test()&#123; console.log('test');&#125;// goodfunction test() &#123; console.log('test');&#125;// baddog.set('attr',&#123; age: '1 year', breed: 'Bernese Mountain Dog'&#125;);// gooddog.set('attr', &#123; age: '1 year', breed: 'Bernese Mountain Dog'&#125;); 在控制语句（if、while 等）的小括号前放一个空格。在函数调用及声明中，不在函数的参数列表前加空格。 12345678910111213141516171819// badif(isJedi) &#123; fight ();&#125;// goodif (isJedi) &#123; fight();&#125;// badfunction fight () &#123; console.log ('Swooosh!');&#125;// goodfunction fight() &#123; console.log('Swooosh!');&#125; 使用空格把运算符隔开。 12345// badvar x=y+5;// goodvar x = y + 5; 在文件末尾插入一个空行。 1234// bad(function (global) &#123; // ...stuff...&#125;)(this); 12345// bad(function (global) &#123; // ...stuff...&#125;)(this);↵↵ 1234// good(function (global) &#123; // ...stuff...&#125;)(this);↵ 在使用长方法链时进行缩进。使用前面的点 . 强调这是方法调用而不是新语句。 12345678910111213141516171819202122232425262728293031323334// bad$('#items').find('.selected').highlight().end().find('.open').updateCount();// bad$('#items'). find('.selected'). highlight(). end(). find('.open'). updateCount();// good$('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount();// badvar leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true) .attr('width', (radius + margin) * 2).append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led);// goodvar leds = stage.selectAll('.led') .data(data) .enter().append('svg:svg') .classed('led', true) .attr('width', (radius + margin) * 2) .append('svg:g') .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')') .call(tron.led); 在块末和新语句前插入空行。 1234567891011121314151617181920212223242526272829303132// badif (foo) &#123; return bar;&#125;return baz;// goodif (foo) &#123; return bar;&#125;return baz;// badvar obj = &#123; foo: function () &#123; &#125;, bar: function () &#123; &#125;&#125;;return obj;// goodvar obj = &#123; foo: function () &#123; &#125;, bar: function () &#123; &#125;&#125;;return obj; ⬆ 回到顶部 逗号 行首逗号: 不需要。 1234567891011121314151617181920212223242526272829// badvar story = [ once , upon , aTime];// goodvar story = [ once, upon, aTime];// badvar hero = &#123; firstName: 'Bob' , lastName: 'Parr' , heroName: 'Mr. Incredible' , superPower: 'strength'&#125;;// goodvar hero = &#123; firstName: 'Bob', lastName: 'Parr', heroName: 'Mr. Incredible', superPower: 'strength'&#125;; 额外的行末逗号：不需要。这样做会在 IE6/7 和 IE9 怪异模式下引起问题。同样，多余的逗号在某些 ES3 的实现里会增加数组的长度。在 ES5 中已经澄清了 (source)： Edition 5 clarifies the fact that a trailing comma at the end of an ArrayInitialiser does not add to the length of the array. This is not a semantic change from Edition 3 but some implementations may have previously misinterpreted this. 123456789101112131415161718192021// badvar hero = &#123; firstName: 'Kevin', lastName: 'Flynn',&#125;;var heroes = [ 'Batman', 'Superman',];// goodvar hero = &#123; firstName: 'Kevin', lastName: 'Flynn'&#125;;var heroes = [ 'Batman', 'Superman']; ⬆ 回到顶部 分号 使用分号。 1234567891011121314151617// bad(function () &#123; var name = 'Skywalker' return name&#125;)()// good(function () &#123; var name = 'Skywalker'; return name;&#125;)();// good (防止函数在两个 IIFE 合并时被当成一个参数;(function () &#123; var name = 'Skywalker'; return name;&#125;)(); 了解更多. ⬆ 回到顶部 类型转换 在语句开始时执行类型转换。 字符串： 12345678910111213// =&gt; this.reviewScore = 9;// badvar totalScore = this.reviewScore + '';// goodvar totalScore = '' + this.reviewScore;// badvar totalScore = '' + this.reviewScore + ' total score';// goodvar totalScore = this.reviewScore + ' total score'; 使用 parseInt 转换数字时总是带上类型转换的基数。 12345678910111213141516171819var inputValue = '4';// badvar val = new Number(inputValue);// badvar val = +inputValue;// badvar val = inputValue &gt;&gt; 0;// badvar val = parseInt(inputValue);// goodvar val = Number(inputValue);// goodvar val = parseInt(inputValue, 10); 如果因为某些原因 parseInt 成为你所做的事的瓶颈而需要使用位操作解决性能问题时，留个注释说清楚原因和你的目的。 1234567// good/** * parseInt was the reason my code was slow. * Bitshifting the String to coerce it to a * Number made it a lot faster. */var val = inputValue &gt;&gt; 0; 注： 小心使用位操作运算符。数字会被当成 64 位值，但是位操作运算符总是返回 32 位的整数（source）。位操作处理大于 32 位的整数值时还会导致意料之外的行为。讨论。最大的 32 位整数是 2,147,483,647： 1232147483647 &gt;&gt; 0 //=&gt; 21474836472147483648 &gt;&gt; 0 //=&gt; -21474836482147483649 &gt;&gt; 0 //=&gt; -2147483647 布尔: 12345678910var age = 0;// badvar hasAge = new Boolean(age);// goodvar hasAge = Boolean(age);// goodvar hasAge = !!age; ⬆ 回到顶部 命名规则 避免单字母命名。命名应具备描述性。 123456789// badfunction q() &#123; // ...stuff...&#125;// goodfunction query() &#123; // ..stuff..&#125; 使用驼峰式命名对象、函数和实例。 123456789// badvar OBJEcttsssss = &#123;&#125;;var this_is_my_object = &#123;&#125;;var o = &#123;&#125;;function c() &#123;&#125;// goodvar thisIsMyObject = &#123;&#125;;function thisIsMyFunction() &#123;&#125; 使用帕斯卡式命名构造函数或类。 1234567891011121314151617// badfunction user(options) &#123; this.name = options.name;&#125;var bad = new user(&#123; name: 'nope'&#125;);// goodfunction User(options) &#123; this.name = options.name;&#125;var good = new User(&#123; name: 'yup'&#125;); 不要使用下划线前/后缀。 为什么？JavaScript 并没有私有属性或私有方法的概念。虽然使用下划线是表示「私有」的一种共识，但实际上这些属性是完全公开的，它本身就是你公共接口的一部分。这种习惯或许会导致开发者错误的认为改动它不会造成破坏或者不需要去测试。长话短说：如果你想要某处为「私有」，它必须不能是显式提出的。 1234567// badthis.__firstName__ = 'Panda';this.firstName_ = 'Panda';this._firstName = 'Panda';// goodthis.firstName = 'Panda'; 不要保存 this 的引用。使用 Function#bind。 123456789101112131415161718192021222324252627282930// badfunction () &#123; var self = this; return function () &#123; console.log(self); &#125;;&#125;// badfunction () &#123; var that = this; return function () &#123; console.log(that); &#125;;&#125;// badfunction () &#123; var _this = this; return function () &#123; console.log(_this); &#125;;&#125;// goodfunction () &#123; return function () &#123; console.log(this); &#125;.bind(this);&#125; 给函数命名。这在做堆栈轨迹时很有帮助。 123456789// badvar log = function (msg) &#123; console.log(msg);&#125;;// goodvar log = function log(msg) &#123; console.log(msg);&#125;; 注： IE8 及以下版本对命名函数表达式的处理有些怪异。了解更多信息到 http://kangax.github.io/nfe/。 如果你的文件导出一个类，你的文件名应该与类名完全相同。 123456789101112131415// file contentsclass CheckBox &#123; // ...&#125;module.exports = CheckBox;// in some other file// badvar CheckBox = require('./checkBox');// badvar CheckBox = require('./check_box');// goodvar CheckBox = require('./CheckBox'); ⬆ 回到顶部 存取器 属性的存取函数不是必须的。 如果你需要存取函数时使用 getVal() 和 setVal(&#39;hello&#39;)。 1234567891011// baddragon.age();// gooddragon.getAge();// baddragon.age(25);// gooddragon.setAge(25); 如果属性是布尔值，使用 isVal() 或 hasVal()。 123456789// badif (!dragon.age()) &#123; return false;&#125;// goodif (!dragon.hasAge()) &#123; return false;&#125; 创建 get() 和 set() 函数是可以的，但要保持一致。 12345678910111213function Jedi(options) &#123; options || (options = &#123;&#125;); var lightsaber = options.lightsaber || 'blue'; this.set('lightsaber', lightsaber);&#125;Jedi.prototype.set = function set(key, val) &#123; this[key] = val;&#125;;Jedi.prototype.get = function get(key) &#123; return this[key];&#125;; ⬆ 回到顶部 构造函数 给对象原型分配方法，而不是使用一个新对象覆盖原型。覆盖原型将导致继承出现问题：重设原型将覆盖原有原型！ 1234567891011121314151617181920212223function Jedi() &#123; console.log('new jedi');&#125;// badJedi.prototype = &#123; fight: function fight() &#123; console.log('fighting'); &#125;, block: function block() &#123; console.log('blocking'); &#125;&#125;;// goodJedi.prototype.fight = function fight() &#123; console.log('fighting');&#125;;Jedi.prototype.block = function block() &#123; console.log('blocking');&#125;; 方法可以返回 this 来实现方法链式使用。 1234567891011121314151617181920212223242526272829// badJedi.prototype.jump = function jump() &#123; this.jumping = true; return true;&#125;;Jedi.prototype.setHeight = function setHeight(height) &#123; this.height = height;&#125;;var luke = new Jedi();luke.jump(); // =&gt; trueluke.setHeight(20); // =&gt; undefined// goodJedi.prototype.jump = function jump() &#123; this.jumping = true; return this;&#125;;Jedi.prototype.setHeight = function setHeight(height) &#123; this.height = height; return this;&#125;;var luke = new Jedi();luke.jump() .setHeight(20); 写一个自定义的 toString() 方法是可以的，但是确保它可以正常工作且不会产生副作用。 123456789101112function Jedi(options) &#123; options || (options = &#123;&#125;); this.name = options.name || 'no name';&#125;Jedi.prototype.getName = function getName() &#123; return this.name;&#125;;Jedi.prototype.toString = function toString() &#123; return 'Jedi - ' + this.getName();&#125;; ⬆ 回到顶部 事件 当给事件附加数据时（无论是 DOM 事件还是私有事件），传入一个哈希而不是原始值。这样可以让后面的贡献者增加更多数据到事件数据而无需找出并更新事件的每一个处理器。例如，不好的写法： 12345678// bad$(this).trigger('listingUpdated', listing.id);...$(this).on('listingUpdated', function (e, listingId) &#123; // do something with listingId&#125;); 更好的写法： 12345678// good$(this).trigger('listingUpdated', &#123; listingId : listing.id &#125;);...$(this).on('listingUpdated', function (e, data) &#123; // do something with data.listingId&#125;); ⬆ 回到顶部 模块 模块应该以 ! 开始。这样确保了当一个不好的模块忘记包含最后的分号时，在合并代码到生产环境后不会产生错误。详细说明 文件应该以驼峰式命名，并放在同名的文件夹里，且与导出的名字一致。 增加一个名为 noConflict() 的方法来设置导出的模块为前一个版本并返回它。 永远在模块顶部声明 &#39;use strict&#39;;。 123456789101112131415161718// fancyInput/fancyInput.js!function (global) &#123; 'use strict'; var previousFancyInput = global.FancyInput; function FancyInput(options) &#123; this.options = options || &#123;&#125;; &#125; FancyInput.noConflict = function noConflict() &#123; global.FancyInput = previousFancyInput; return FancyInput; &#125;; global.FancyInput = FancyInput;&#125;(this); ⬆ 回到顶部 jQuery 使用 $ 作为存储 jQuery 对象的变量名前缀。 12345// badvar sidebar = $('.sidebar');// goodvar $sidebar = $('.sidebar'); 缓存 jQuery 查询。 12345678910111213141516171819202122// badfunction setSidebar() &#123; $('.sidebar').hide(); // ...stuff... $('.sidebar').css(&#123; 'background-color': 'pink' &#125;);&#125;// goodfunction setSidebar() &#123; var $sidebar = $('.sidebar'); $sidebar.hide(); // ...stuff... $sidebar.css(&#123; 'background-color': 'pink' &#125;);&#125; 对 DOM 查询使用层叠 $(&#39;.sidebar ul&#39;) 或 父元素 &gt; 子元素 $(&#39;.sidebar &gt; ul&#39;)。 jsPerf 对有作用域的 jQuery 对象查询使用 find。 1234567891011121314// bad$('ul', '.sidebar').hide();// bad$('.sidebar').find('ul').hide();// good$('.sidebar ul').hide();// good$('.sidebar &gt; ul').hide();// good$sidebar.find('ul').hide(); ⬆ 回到顶部 ECMAScript 5 兼容性 参考 Kangax 的 ES5 兼容表. ⬆ 回到顶部 测试 Yup. 123function () &#123; return true;&#125; ⬆ 回到顶部 性能 On Layout &amp; Web Performance String vs Array Concat Try/Catch Cost In a Loop Bang Function jQuery Find vs Context, Selector innerHTML vs textContent for script text Long String Concatenation Loading… ⬆ 回到顶部 资源推荐阅读 Annotated ECMAScript 5.1 工具 Code Style Linters JSHint - Airbnb Style .jshintrc JSCS - Airbnb Style Preset 其它风格指南 Google JavaScript Style Guide jQuery Core Style Guidelines Principles of Writing Consistent, Idiomatic JavaScript JavaScript Standard Style 其它风格 Naming this in nested functions - Christian Johansen Conditional Callbacks - Ross Allen Popular JavaScript Coding Conventions on Github - JeongHoon Byun Multiple var statements in JavaScript, not superfluous - Ben Alman 进一步阅读 Understanding JavaScript Closures - Angus Croll Basic JavaScript for the impatient programmer - Dr. Axel Rauschmayer You Might Not Need jQuery - Zack Bloom &amp; Adam Schwartz ES6 Features - Luke Hoban Frontend Guidelines - Benjamin De Cock 书籍 JavaScript: The Good Parts - Douglas Crockford JavaScript Patterns - Stoyan Stefanov Pro JavaScript Design Patterns - Ross Harmes and Dustin Diaz High Performance Web Sites: Essential Knowledge for Front-End Engineers - Steve Souders Maintainable JavaScript - Nicholas C. Zakas JavaScript Web Applications - Alex MacCaw Pro JavaScript Techniques - John Resig Smashing Node.js: JavaScript Everywhere - Guillermo Rauch Secrets of the JavaScript Ninja - John Resig and Bear Bibeault Human JavaScript - Henrik Joreteg Superhero.js - Kim Joar Bekkelund, Mads Mobæk, &amp; Olav Bjorkoy JSBooks - Julien Bouquillon Third Party JavaScript - Ben Vinegar and Anton Kovalyov Effective JavaScript: 68 Specific Ways to Harness the Power of JavaScript - David Herman Eloquent JavaScript - Marijn Haverbeke You Don’t Know JS - Kyle Simpson 博客 DailyJS JavaScript Weekly JavaScript, JavaScript… Bocoup Weblog Adequately Good NCZOnline Perfection Kills Ben Alman Dmitry Baranovskiy Dustin Diaz nettuts 播客 JavaScript Jabber ⬆ 回到顶部 谁在使用 这是一个使用本风格指南的组织列表。给我们发 pull request 或开一个 issue 让我们将你增加到列表上。 Aan Zee: AanZee/javascript Adult Swim: adult-swim/javascript Airbnb: airbnb/javascript Apartmint: apartmint/javascript Avalara: avalara/javascript Billabong: billabong/javascript Compass Learning: compasslearning/javascript-style-guide DailyMotion: dailymotion/javascript Digitpaint digitpaint/javascript Evernote: evernote/javascript-style-guide ExactTarget: ExactTarget/javascript Flexberry: Flexberry/javascript-style-guide Gawker Media: gawkermedia/javascript General Electric: GeneralElectric/javascript GoodData: gooddata/gdc-js-style Grooveshark: grooveshark/javascript How About We: howaboutwe/javascript InfoJobs: InfoJobs/JavaScript-Style-Guide Intent Media: intentmedia/javascript Jam3: Jam3/Javascript-Code-Conventions JSSolutions: JSSolutions/javascript Kinetica Solutions: kinetica/javascript Mighty Spring: mightyspring/javascript MinnPost: MinnPost/javascript ModCloth: modcloth/javascript Money Advice Service: moneyadviceservice/javascript Muber: muber/javascript National Geographic: natgeo/javascript National Park Service: nationalparkservice/javascript Nimbl3: nimbl3/javascript Nordic Venture Family: CodeDistillery/javascript Orion Health: orionhealth/javascript Peerby: Peerby/javascript Razorfish: razorfish/javascript-style-guide reddit: reddit/styleguide/javascript REI: reidev/js-style-guide Ripple: ripple/javascript-style-guide SeekingAlpha: seekingalpha/javascript-style-guide Shutterfly: shutterfly/javascript StudentSphere: studentsphere/javascript Super: SuperJobs/javascript SysGarage: sysgarage/javascript-style-guide Target: target/javascript TheLadders: TheLadders/javascript T4R Technology: T4R-Technology/javascript VoxFeed: VoxFeed/javascript-style-guide Weggo: Weggo/javascript Zillow: zillow/javascript ZocDoc: ZocDoc/javascript 翻译 这份风格指南也提供了其它语言的版本： br](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Brazil.png) **Brazilian Portuguese**: [armoucar/javascript-style-guide bg](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Bulgaria.png) **Bulgarian**: [borislavvv/javascript ca](https://raw.githubusercontent.com/fpmweb/javascript-style-guide/master/img/catala.png) **Catalan**: [fpmweb/javascript-style-guide tw](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Taiwan.png) **Chinese(Traditional)**: [jigsawye/javascript cn](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/China.png) **Chinese(Simplified)**: [sivan/javascript fr](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/France.png) **French**: [nmussy/javascript-style-guide de](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Germany.png) **German**: [timofurrer/javascript-style-guide it](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Italy.png) **Italian**: [sinkswim/javascript-style-guide jp](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Japan.png) **Japanese**: [mitsuruog/javacript-style-guide kr](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/South-Korea.png) **Korean**: [tipjs/javascript-style-guide pl](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Poland.png) **Polish**: [mjurczyk/javascript ru](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Russia.png) **Russian**: [uprock/javascript es](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Spain.png) **Spanish**: [paolocarrasco/javascript-style-guide th](https://raw.githubusercontent.com/gosquared/flags/master/flags/flags/shiny/24/Thailand.png) **Thai**: [lvarayut/javascript-style-guide JavaScript 风格指南说明 Reference 与我们讨论 JavaScript Find us on gitter. 贡献者 View Contributors 许可(The MIT License) Copyright (c) 2014 Airbnb Permission is hereby granted, free of charge, to any person obtaininga copy of this software and associated documentation files (the‘Software’), to deal in the Software without restriction, includingwithout limitation the rights to use, copy, modify, merge, publish,distribute, sublicense, and/or sell copies of the Software, and topermit persons to whom the Software is furnished to do so, subject tothe following conditions: The above copyright notice and this permission notice shall beincluded in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ‘AS IS’, WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OFMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANYCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THESOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ⬆ 回到顶部 };","categories":[{"name":"Repost","slug":"Repost","permalink":"http://blog.duanxu.tech/categories/Repost/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.duanxu.tech/tags/JavaScript/"},{"name":"Style Guide","slug":"Style-Guide","permalink":"http://blog.duanxu.tech/tags/Style-Guide/"}]},{"title":"树莓派手记(1) 查找并连接","slug":"2016/2016-11-02-树莓派手记(1)-查找并连接","date":"2016-11-02T10:49:30.000Z","updated":"2018-12-07T12:51:58.558Z","comments":true,"path":"2016/11/02/2016/2016-11-02-树莓派手记(1)-查找并连接/","link":"","permalink":"http://blog.duanxu.tech/2016/11/02/2016/2016-11-02-树莓派手记(1)-查找并连接/","excerpt":"","text":"content{:toc} 由于不使用GUI交互，只能通过SSH登陆树莓派，所以首先我们需要知道树莓派的IP地址。对于局域网，可以通过 arp-scan 来获取树莓派的 IP 地址。 1 获取本机网络设备号首先，查看本地网卡设备号： 12345678910111213141516171819202122$ ifconfigenp0s25 Link encap:Ethernet HWaddr FF:FF:FF:FF:FF:FF inet addr:255.255.255.255 Bcast:255.255.255.255 Mask:255.255.224.0 inet6 addr: ffff::ffff:ffff:ffff:ffff/64 Scope:Link inet6 addr: ffff:ffff:ffff:ffff::ffff:ffff/128 Scope:Global UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:179004 errors:0 dropped:0 overruns:0 frame:0 TX packets:495691 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:66530981 (66.5 MB) TX bytes:587144597 (587.1 MB) Interrupt:19 Memory:f0000000-f0020000 lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:3776 errors:0 dropped:0 overruns:0 frame:0 TX packets:3776 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1 RX bytes:591518 (591.5 KB) TX bytes:591518 (591.5 KB) 其中 enp0s25 就是我们的有限网路设备的设备号，而 lo 是本地回环设备号。将 enp0s25 记下来用于 arp-scan 使用。 2 安装 arp-scan如果已经安装此软件包，直接跳过即可。 12$ sudo apt install arp-scan 3 获取树莓派 IP由于树莓派的Mac地址都是b8:27:3b开头的，所以在 arp-scan 中，以 b8:27:3b 开头的 Mac 地址对应的 IP 即为内网树莓派的 IP 地址。 1234$ sudo arp-scan --interface enp0s25 --localnet | grep b8:27:eb2XX.X.XX.XXX b8:27:eb:FF:FF:FF (Unknown) 4 SSH 登录树莓派1234567891011121314$ ssh 2XX.X.XX.XXXXXX@2XX.X.XX.XXX's password: Welcome to Ubuntu 16.04.1 LTS (GNU/Linux 4.1.19-v7+ armv7l) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage0 packages can be updated.0 updates are security updates.Last login: Wed Nov 2 18:20:58 2016 from 2XX.X.XX.XXX","categories":[{"name":"Raspberry","slug":"Raspberry","permalink":"http://blog.duanxu.tech/categories/Raspberry/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.duanxu.tech/tags/Linux/"},{"name":"Raspberry","slug":"Raspberry","permalink":"http://blog.duanxu.tech/tags/Raspberry/"}]},{"title":"Ubuntu+Django+Nginx+uWSGI+Mysql搭建Python Web服务器","slug":"2016/2016-10-27-Ubuntu+Django+Nginx+uWSGI+Mysql搭建Python Web服务器","date":"2016-10-27T14:09:30.000Z","updated":"2018-12-07T12:51:53.484Z","comments":true,"path":"2016/10/27/2016/2016-10-27-Ubuntu+Django+Nginx+uWSGI+Mysql搭建Python Web服务器/","link":"","permalink":"http://blog.duanxu.tech/2016/10/27/2016/2016-10-27-Ubuntu+Django+Nginx+uWSGI+Mysql搭建Python Web服务器/","excerpt":"","text":"content{:toc} 本文转载自SegmentFault 前不久为了部署Django项目，在百度上到处找教程，找到的教程因为这样那样的原因，总是失败，可能是因为作者水平比较高吧，有些细节的东西估计没写出来，造成我这种初学者想照着做都做不成。百度不行就用Google吧，中文不行就找英文的，最后，给我误打误撞的部署成功了。为了加深印象，我用虚拟机再重新部署一次。 1 准备工作我使用的系统是Ubuntu14.04.5 LTS(Trusty Tahr) server i386版，官网下载地址：http://releases.ubuntu.com/14.04.4/ubuntu-14.04.5-server-i386.iso 安装的时候全部选择英文，记得以前选择中文的时候安装时出了问题，服务器组件一个不选，Ubuntu安装做的很贴心，基本上是一路回车，就不详细说明了。装好以后，首先要更新apt-get，貌似我的ubuntu镜像是在国内站下载的，所以源是国内的地址，所以就不用更换源了。 1.1 更新apt-get12sudo apt-get updatesudo apt-get upgrade 1.2 安装SSH1sudo apt-get install ssh 装好以后，用ifconfig查看一下IP地址 可以看到IP地址是192.168.0.154，下面我们就使用XSHELL连接192.168.0.154进行操作了。 1.3 安装Git这一步不是必须的，因为我的测试项目是放在git.oschina.com上的，安装git获取项目代码就很方便了 1sudo apt-get install git 2 安装配置MySQL2.1 安装1sudo apt-get install mysql-server 安装过程中会提示让你设置root密码 2.2 配置2.2.1 数据库初始化： 1sudo mysql_install_db 2.2.2 运行数据库Mysql安全配置向导 1sudo mysql_secure_installation 输入root密码 是否修改root密码，因为前面已经设置过了，选n 是否移除匿名用户,肯定是要选y的 是否允许远程登陆，如果选n的话，只能在本机访问数据库，建议选y 是否移除test数据库，建议选是 重新加载权限表，选y All done! 3 安装配置Python环境3.1 安装python-dev包1sudo apt-get install python-dev 3.2 安装pip1sudo apt-get install python-pip 3.3 更换pip源因为国内使用默认的pip源速度很慢，所以需要更换,在用户根目录下新建.pip目录，在该目录下新建pip.conf文件 12sudo mkdir ~/.pipsudo vi ~/.pip/pip.conf 然后在文件里写上： 12345[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com 3.4 安装配置VirtualEnv和VirtualEnvWrapperVirtualEnv可以管理多个开发环境，VirtualEnvWrapper使得VirtualEnv变得更好用 1sudo pip install virtualenv virtualenvwrapper 安装完成以后，需要在环境变量中加入一些配置：下面这句话是使用python3才需要执行的，python2不需要 1echo \"export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3\" &gt;&gt; ~/.bashrc 不管python是什么版本，都要执行下面两句： 12echo \"export WORKON_HOME=~/Env\" &gt;&gt; ~/.bashrcecho \"source /usr/local/bin/virtualenvwrapper.sh\" &gt;&gt; ~/.bashrc 可以重启系统激活，也可以运行： 1source ~/.bashrc 然后就可以开始建立一个虚拟环境： 1mkvirtualenv first 你会发现，提示符变成(first)user@hostname:~$,表示现在已经进入first的虚拟环境，在此环境下进行的pip等操作，只会在当前环境下生效,当前虚拟环境在/home/siva/Env/first目录下 4 Django项目配置4.1 安装django我使用选择版本来安装： 1pip install django==1.10.1 4.2 下载或拷贝项目安装完成以后，使用git把项目clone下来,此处填写你自己的地址： 1git clone https://git.oschina.net/xxx/Siva_First.git 此例子的项目名称是Siva_First，路径是在/home/siva/下 4.3 配置django用Mysql建好项目的数据库，然后进入Siva_First目录，用django应用数据模型： 12python manage.py makemigrationspython manage.py migrate 建立后台超级用户： 1python manage.py createsuperuser 静态文件安置： 1python manage.py collectstatic 4.4 测试项目运行开发服务器测试一下是否可以正常运行： 1python manage.py runserver 0.0.0.0:8000 这时，用浏览器打开http://192.168.0.154:8000/可以看到网站 4.5 退出虚拟环境因为当前是在first虚拟环境下，为了下一步的安装，必须退出当前的虚拟环境： 1deactivate 5 uWSGI安装和配置5.1 安装uWSGIpip下安装很简单： 1sudo pip install uwsgi 我们可以测试一下uwsgi是否安装成功 1uwsgi --http :8000 --home /home/siva/Env/first --chdir /home/siva/Siva_First -w Siva_First.wsgi 上面的命令是使用8000端口，虚拟环境在/home/siva/Env/first，项目在/home/siva/Siva_First下 5.2 配置uWSGI使用上面的命令行来部署网站肯定是不行的，我们需要使用“Emperor mode”，建立一个目录来放配置文件： 12sudo mkdir -p /etc/uwsgi/sitescd /etc/uwsgi/sites 以项目名称来命名这个配置文件： 1sudo vi Siva_First.ini 内容如下： 1234567891011121314[uwsgi]project = Siva_Firstbase = /home/sivachdir = %(base)/%(project)home = %(base)/Env/%(project)module = %(project).wsgi:applicationmaster = trueprocesses = 5socket = %(base)/%(project)/%(project).sockchmod-socket = 664vacuum = true project是项目名称，base是项目所在位置 现在，配置文件建好了，但是uwsgi还不能自动运行我们需要在/etc/init目录中建一个启动脚本： 1sudo vi /etc/init/uwsgi.conf 内容如下： 123456789description \"uWSGI application server in Emperor mode\"start on runlevel [2345]stop on runlevel [!2345]setuid sivasetgid www-dataexec /usr/local/bin/uwsgi --emperor /etc/uwsgi/sites 这一步完成以后，uwsgi还是不能正常启动，是因为www-data用户组还没有创建，等我们装完nginx以后就可以了。 6 反向代理：Nginx的安装和配置6.1 安装1sudo apt-get install nginx 6.2 创建配置文件1sudo vi /etc/nginx/sites-available/Siva_First 内容如下： 1234567891011121314server &#123; listen 80; server_name 192.168.0.154; location = /favicon.ico &#123; access_log off; log_not_found off; &#125; location /static/ &#123; root /home/siva/Siva_First; &#125; location / &#123; include uwsgi_params; uwsgi_pass unix:/home/siva/Siva_First/Siva_First.sock; &#125;&#125; 然后把这个配置文件链接到sites-enabled目录下 1sudo ln -s /etc/nginx/sites-available/Siva_First /etc/nginx/sites-enabled/ 检查一下配置文件的语法是否有问题 1sudo service nginx configtest 如果没问题，那么重启一下nginx和uwsgi的服务就可以访问了 12sudo service nginx restartsudo service uwsgi restart","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://blog.duanxu.tech/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://blog.duanxu.tech/tags/Ubuntu/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.duanxu.tech/tags/MySQL/"},{"name":"Django","slug":"Django","permalink":"http://blog.duanxu.tech/tags/Django/"},{"name":"Nginx","slug":"Nginx","permalink":"http://blog.duanxu.tech/tags/Nginx/"},{"name":"Python Web","slug":"Python-Web","permalink":"http://blog.duanxu.tech/tags/Python-Web/"}]},{"title":"MySQL时区问题","slug":"2016/2016-10-10-MySQL时区问题 ","date":"2016-10-10T10:57:30.000Z","updated":"2018-12-07T12:51:50.436Z","comments":true,"path":"2016/10/10/2016/2016-10-10-MySQL时区问题 /","link":"","permalink":"http://blog.duanxu.tech/2016/10/10/2016/2016-10-10-MySQL时区问题 /","excerpt":"","text":"content{:toc} 1 问题描述Java连接MySQL的出现错误： ERROR: The server time zone value ‘�й���׼ʱ��’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. 提示说服务器时区设置错误，首先，查看原编码： 123456789mysql&gt; show variables like '%time_zone%';+------------------+--------+ | Variable_name | Value | +------------------+--------+ | system_time_zone | | | time_zone | SYSTEM | +------------------+--------+ 2 rows in set (0.00 sec) 发现，system_time_zone一栏为空，需要修改系统时区设置。 2 解决方法2.1 临时解决方法那么将system_time_zone改成正确的值即可： 12mysql&gt; set system_time_zone='+8:00'; 之后，便可以正常连接。 123456789mysql&gt; show variables like '%time_zone%';+------------------+--------+ | Variable_name | Value | +------------------+--------+ | system_time_zone | CST | | time_zone | +08:00 | +------------------+--------+ 2 rows in set (0.00 sec) 2.2 一劳永逸解决方法上述解决方法有个缺陷，就是在每次数据库重启之后，所有的工作都丢失了，会发现再次连接依然会提示错误。于是有了如下方案，直接修改 MySQL 的配置文件： 2.2.1 Linux 环境在 Ubuntu 16.04 + MySQL 5.7 环境下，修改 /etc/mysql/my.cnf 配置文件： 12345sudo vim /etc/mysql/my.cnf----------------------------------[mysqld]default-time-zone = '+8:00' 之后重启数据库即可： 12sudo service mysql restart 2.2.2 Windows 环境在 Windows + MySQL 5.7 环境下，修改 %PROGRAMDATA%\\MySQL\\MySQL Server 5.7\\my.ini 配置文件： 这里的 %PROGRAMDATA% 一般为：C:\\ProgramData\\，可以通过echo %PROGRAMDATA%查看。 123[mysqld]default-time-zone = '+8:00' 之后重启数据库即可： 123net stop mysqlnet start mysql","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://blog.duanxu.tech/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://blog.duanxu.tech/tags/Ubuntu/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.duanxu.tech/tags/MySQL/"}]},{"title":"MySQL中文乱码问号问题","slug":"2016/2016-10-10-MySQL中文乱码问号问题","date":"2016-10-10T10:25:30.000Z","updated":"2018-12-07T12:51:47.211Z","comments":true,"path":"2016/10/10/2016/2016-10-10-MySQL中文乱码问号问题/","link":"","permalink":"http://blog.duanxu.tech/2016/10/10/2016/2016-10-10-MySQL中文乱码问号问题/","excerpt":"","text":"content{:toc} 有时候，向MySQL数据库表插入中文，然后在查找的时候 会出现中文文字变成问号（？？？）的情况。这是由于数据库编码问题导致的。 1 问题描述向表内插入数据，然后再 select 的时候，发现中文都变成了问号。 首先，查看原编码： 1234567891011121314mysql&gt; show variables like 'character%';+--------------------------+----------------------------+ | Variable_name | Value | +--------------------------+----------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | latin1 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | latin1 | | character_set_system | utf8 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+ 发现，character_set_database 和 character_set_server 使用的都是 latin1 编码，因此导致中文在存取过程中的编码错误。 2 解决方法2.1 临时解决方法既然上述两个变量值错误，那么将其改成正确的值即可： 123mysql&gt; set character_set_database=utf8;mysql&gt; set character_set_server=utf8; 之后，将乱码的表drop，然后重新插入即可。 如果还是乱码，就： 12mysql&gt; SET NAMES 'utf8'; 然后，应该可以得到正确的结果： 1234567891011121314mysql&gt; show variables like 'character%';+--------------------------+----------------------------------------+| Variable_name | Value |+--------------------------+----------------------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/local/mysql/share/mysql/charsets/ |+--------------------------+----------------------------------------+ 问题一般会得到解决。 2.2 一劳永逸解决方法上述解决方法有个缺陷，就是在每次数据库重启之后，所有的工作都丢失了，会发现查找的表依旧是乱码。于是有了如下方案，直接修改 MySQL 的配置文件： 2.2.1 Linux 环境在 Ubuntu 16.04 + MySQL 5.7 环境下，修改 /etc/mysql/my.cnf 配置文件： 123456789101112sudo vim /etc/mysql/my.cnf----------------------------------[client]default-character-set=utf8[mysqld]character-set-server=utf8[mysql]no-auto-rehashdefault-character-set=utf8 之后重启数据库，然后重新导入数据即可： 12sudo service mysql restart 2.2.2 Windows 环境在 Windows + MySQL 5.7 环境下，修改 %PROGRAMDATA%\\MySQL\\MySQL Server 5.7\\my.ini 配置文件： 这里的 %PROGRAMDATA% 一般为：C:\\ProgramData\\，可以通过echo %PROGRAMDATA%查看。 12345678910[client]default-character-set=utf8[mysqld]character-set-server=utf8[mysql]no-auto-rehashdefault-character-set=utf8 之后重启数据库，然后重新导入数据即可： 123net stop mysqlnet start mysql","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://blog.duanxu.tech/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://blog.duanxu.tech/tags/Ubuntu/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.duanxu.tech/tags/MySQL/"}]},{"title":"Ubuntu 16.04 配置 openCV 环境","slug":"2016/2016-09-16-Ubuntu16.04-配置openCV环境","date":"2016-09-16T07:03:30.000Z","updated":"2018-12-07T12:54:20.261Z","comments":true,"path":"2016/09/16/2016/2016-09-16-Ubuntu16.04-配置openCV环境/","link":"","permalink":"http://blog.duanxu.tech/2016/09/16/2016/2016-09-16-Ubuntu16.04-配置openCV环境/","excerpt":"","text":"content{:toc} 本问主要描述了在 Ubuntu 16.04(x64) 环境下配置openCV，以及运行示例程序的过程。 1 安装 openCV1.1 下载 openCV首先下载 openCV-2.4.13 安装包，并解压到任意目录 1.2 安装依赖环境编译 openCV包的时候需要安装相应的依赖： 12345sudo apt-get install build-essential libgtk2.0-dev libjpeg-dev libtiff5-dev libjasper-dev libopenexr-dev cmake python-devpython-numpy python-tk libtbb-dev libeigen3-dev yasm libfaac-dev libopencore-amrnb-dev libopencore-amrwb-dev libtheora-dev libvorbis-dev libxvidcore-dev libx264-dev libqt4-dev libqt4-opengl-dev sphinx-common texlive-latex-extra libv4l-dev libdc1394-22-dev libavcodec-dev libavformat-dev libswscale-dev default-jdk ant libvtk5-qt4-dev 1.3 编译选项12345mkdir buildcd buildcmake -D WITH_TBB=ON -D BUILD_NEW_PYTHON_SUPPORT=ON -D WITH_V4L=ON -D INSTALL_C_EXAMPLES=ON -D INSTALL_PYTHON_EXAMPLES=ON -D BUILD_EXAMPLES=ON -D WITH_QT=ON -D WITH_OPENGL=ON -D WITH_VTK=ON .. 1.4 编译安装123makemake install 此时，如果提示“无法创建目录 /usr/local/include/opencv2”，那么需要以管理员权限安装： 123makesudo make install 1.5 添加 library path123sudo touch /etc/ld.so.conf.d/opencv.confsudo vi /etc/ld.so.conf.d/opencv.conf 文件内容为： /usr/local/lib 最后应用配置即可： 12sudo ldconfig 2 运行示例程序首先关闭终端，开启一个新的终端并进入“…/opencv-2.4.13/samples/c”目录下。 这个目录下面有个“build_all.sh”脚本文件，功能是编译链接该目录下的所有 c/cpp 文件，生成二进制可执行程序。 首先执行此脚本，如果提示不可执行的话，需要对脚本加权限： 123chmod +x build_all.sh./build_all.sh 等待编译完成之后，便可执行测试程序。 3 使用 IDE 编译在使用 IDE 编译 openCV 程序的时候，需要修改“CMakeLists.txt”文件，向程序添加 openCV 库的支持： 12345678910111213141516171819cmake_minimum_required(VERSION 3.5)project(openCV)# 添加openCVFIND_PACKAGE(OpenCV REQUIRED)set(CMAKE_CXX_FLAGS \"$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11\")# 设置可执行文件生成路径set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/bin)set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/bin)set(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/bin)set(SOURCE_FILES main.cpp)add_executable(openCV $&#123;SOURCE_FILES&#125;)# 添加openCVtarget_link_libraries(openCV $&#123;OpenCV_LIBS&#125;) 需要添加的两行在上面已经注释出来了，添加了库支持之后，便不会提示相应的头文件找不到之类的编译错误了。 最后，使用编译器自带的编译功能便可运行程序了。","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://blog.duanxu.tech/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://blog.duanxu.tech/tags/Ubuntu/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://blog.duanxu.tech/tags/OpenCV/"}]},{"title":"JUnit学习(2) JUnit API","slug":"2016/2016-08-09-JUnit-学习(2)-JUnit-API","date":"2016-08-09T12:27:30.000Z","updated":"2018-12-07T12:51:31.016Z","comments":true,"path":"2016/08/09/2016/2016-08-09-JUnit-学习(2)-JUnit-API/","link":"","permalink":"http://blog.duanxu.tech/2016/08/09/2016/2016-08-09-JUnit-学习(2)-JUnit-API/","excerpt":"","text":"content{:toc} 3 JUnit API引自“极客学院” JUnit 中比较重要的类有四个： |:—:|:—:|:—:||序号|类的名称|类的功能||1|Assert|assert方法的集合||2|TestCase|定义了运行多重测试的固定装置||3|TestResult|TestResult 集合了执行测试样例的所有结果||4|TestSuit|TestSuite 是测试的集合| 3.1 Assert类这个类提供了一系列的编写测试的有用的声明方法。只有失败的声明方法才会被记录。Assert 类的重要方法列式如下： |:—:|:—:|:—:||序号|方法|描述||1|void assertEquals(boolean expected, boolean actual)|检查两个变量或者等式是否平衡||2|void assertFalse(boolean condition)|检查条件是假的||3|void assertNotNull(Object object)|检查对象不是空的||4|void assertNull(Object object)|检查对象是空的||5|void assertTrue(boolean condition)|检查条件为真||6|void fail()|在没有报告的情况下使测试不通过| 测试类用法如下： 123456789101112131415161718192021import org.junit.Test;import static org.junit.Assert.*;public class TestJunit1 &#123; @Test public void testAdd() &#123; //test data int num= 5; String temp= null; String str= \"Junit is working fine\"; //check for equality assertEquals(\"Junit is working fine\", str); //check for false condition assertFalse(num &gt; 6); //check for not null value assertNotNull(str); &#125;&#125; 3.2 TestCase类测试样例定义了运行多重测试的固定格式。TestCase 类的一些重要方法列式如下： |:—:|:—:|:—:||序号|方法|描述||1|int countTestCases()|为被run(TestResult result) 执行的测试案例计数||2|TestResult createResult()|创建一个默认的 TestResult 对象||3|String getName()|获取 TestCase 的名称||4|TestResult run()|一个运行这个测试的方便的方法，收集由TestResult 对象产生的结果||5|void run(TestResult result)|在 TestResult 中运行测试案例并收集结果||6|void setName(String name)|设置 TestCase 的名称||7|void setUp()|创建固定装置，例如，打开一个网络连接||8|void tearDown()|拆除固定装置，例如，关闭一个网络连接||9|String toString()|返回测试案例的一个字符串表示| 测试类用法如下： 1234567891011121314151617181920212223242526272829303132import junit.framework.TestCase;import org.junit.Before;import org.junit.Test;public class TestJunit2 extends TestCase &#123; protected double fValue1; protected double fValue2; @Before public void setUp() &#123; fValue1= 2.0; fValue2= 3.0; &#125; @Test public void testAdd() &#123; //count the number of test cases System.out.println(\"No of Test Case = \"+ this.countTestCases()); //test getName String name= this.getName(); System.out.println(\"Test Case Name = \"+ name); //test setName this.setName(\"testNewAdd\"); String newName= this.getName(); System.out.println(\"Updated Test Case Name = \"+ newName); &#125; //tearDown used to close the connection or clean up activities public void tearDown( ) &#123; &#125;&#125; 3.3 TestResult类测试样例定义了运行多重测试的固定格式。TestCase 类的一些重要方法列式如下： |:—:|:—:|:—:||序号|方法|描述||1|void addError(Test test, Throwable t)|在错误列表中加入一个错误||2|void addFailure(Test test, AssertionFailedError t)|在失败列表中加入一个失败||3|void endTest(Test test)|显示测试被编译的这个结果||4|int errorCount()|获取被检测出错误的数量||5|Enumeration errors()|返回错误的详细信息||6|int failureCount()|获取被检测出的失败的数量||7|void run(TestCase test)|运行 TestCase||8|int int runCount()|获得运行测试的数量||9|void startTest(Test test)|声明一个测试即将开始||10|void stop()|标明测试必须停止| 测试类用法如下： 12345678910111213141516171819202122232425import org.junit.Test;import junit.framework.AssertionFailedError;import junit.framework.TestResult;public class TestJunit3 extends TestResult &#123; // add the error public synchronized void addError(Test test, Throwable t) &#123; super.addError((junit.framework.Test) test, t); &#125; // add the failure public synchronized void addFailure(Test test, AssertionFailedError t) &#123; super.addFailure((junit.framework.Test) test, t); &#125; @Test public void testAdd() &#123; // add any test &#125; // Marks that the test run should stop. public synchronized void stop() &#123; //stop the test here &#125;&#125; 3.4 TestSuit类TestSuite 类是测试的组成部分。它运行了很多的测试案例。TestSuite 类的一些重要方法列式如下： |:—:|:—:|:—:||序号|方法|描述||1|void addTest(Test test)|在套中加入测试。||2|void addTestSuite(Class&lt;? extends TestCase&gt; testClass)|将已经给定的类中的测试加到套中。||3|int countTestCases()|对这个测试即将运行的测试案例进行计数。||4|String getName()|返回套的名称。||5|void run(TestResult result)|在 TestResult 中运行测试并收集结果。||6|void setName(String name)|设置套的名称。||7|Test testAt(int index)|在给定的目录中返回测试。||8|int testCount()|返回套中测试的数量。||9|static Test warning(String message)|返回会失败的测试并且记录警告信息。| 测试类用法如下： 1234567891011import junit.framework.*;public class JunitTestSuite &#123; public static void main(String[] a) &#123; // add the test's in the suite TestSuite suite = new TestSuite(TestJunit1.class, TestJunit2.class, TestJunit3.class ); TestResult result = new TestResult(); suite.run(result); System.out.println(\"Number of test cases = \" + result.runCount()); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.duanxu.tech/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.duanxu.tech/tags/Java/"},{"name":"JUnit","slug":"JUnit","permalink":"http://blog.duanxu.tech/tags/JUnit/"}]},{"title":"JUnit学习(1) 初识JUnit","slug":"2016/2016-08-04-JUnit-学习(1)-初识JUnit","date":"2016-08-04T12:21:30.000Z","updated":"2018-12-07T12:51:20.193Z","comments":true,"path":"2016/08/04/2016/2016-08-04-JUnit-学习(1)-初识JUnit/","link":"","permalink":"http://blog.duanxu.tech/2016/08/04/2016/2016-08-04-JUnit-学习(1)-初识JUnit/","excerpt":"","text":"content{:toc} 1 JUnit简介引自“百度百科” JUnit是一个Java语言的单元测试框架。它由Kent Beck和Erich Gamma建立，逐渐成为源于Kent Beck的sUnit的xUnit家族中最为成功的一个。 JUnit有它自己的JUnit扩展生态圈。多数Java的开发环境都已经集成了JUnit作为单元测试的工具。JUnit是由 Erich Gamma 和 Kent Beck 编写的一个回归测试框架（regression testing framework）。Junit测试是程序员测试，即所谓白盒测试，因为程序员知道被测试的软件如何（How）完成功能和完成什么样（What）的功能。Junit是一套框架，继承TestCase类，就可以用Junit进行自动测试了。 2 基础测试2.1 测试函数测试工具是一整套固定的工具用于基线测试。测试工具的目的是为了确保测试能够在共享且固定的环境中运行，因此保证测试结果的可重复性。它包括： 在所有测试调用指令发起前的 setUp() 方法。 在测试方法运行后的 tearDown() 方法。 所以，我们可以在 setUp() 方法内编写测试的初始化方法，之后在测试函数内部编写测试代码。 测试程序在执行的时候，会自动识别类内部名称为 test* 的方法，并执行相应的测试。本例中，在 setUp() 方法内部将私有成员初始化，之后在 testInitial 方法内测试初始化的结果。 12345678910111213141516package science.duanxu;import junit.framework.*;public class JUnitStudyFunction extends TestCase &#123; private int value; protected void setUp() &#123; value = 100; &#125; public void testInitial() &#123; assertTrue(value == 100); &#125;&#125; 2.2 测试类首先，我们编写一个具有功能的 Complex 类，其中只是最简单的实现了复数相加的功能。 1234567891011121314151617181920212223242526package science.duanxu;public class Complex &#123; // 为了省去get set方法，这里我们把rel和img设为private public double rel, img; public Complex() &#123; rel = img = 0; &#125; public Complex(double rel, double img) &#123; this.rel = rel; this.img = img; &#125; public Complex add(Complex complex) &#123; return new Complex(this.rel + complex.rel, this.img + complex.img); &#125; @Override public boolean equals(Object object) &#123; Complex complex = (Complex)object; return this.rel == complex.rel &amp;&amp; this.img == complex.img; &#125;&#125; 之后，我们就可以对这个复数类编写测试类，用来测复数类的执行。本例中，由于只有一个 add 方法，所以我们仅测试这一个方法的执行结果： 123456789101112131415161718package test;import org.junit.Test;import science.duanxu.Complex;import static org.junit.Assert.assertEquals;public class TestComplex &#123; @Test public void testAdd() &#123; Complex x = new Complex(1,2); Complex y = new Complex(3,4); assertEquals(new Complex(4,6), x.add(y)); &#125;&#125; 其中，在测试执行的时候，进入测试类 TestComplex，然后执行 @Test 注解的 testAdd() 方法。进入testAdd() 方法之后，通过 assertEquals 方法返回测试结果（调用了Complex类内部的 equals 方法）。 2.3 批量测试有些时候，我们需要同时测试很多类的执行情况，于是分别给这些类编写了相应的测试类，之后我们便可以通过“测试套件”的方法来统一测试这些类。 以上面编写的 JUnitStudyFunction 类和 TestComplex 类为例。 123456789101112131415package test;import org.junit.runner.RunWith;import org.junit.runners.Suite;import science.duanxu.JUnitStudyFunction;@RunWith(Suite.class)@Suite.SuiteClasses(&#123; TestComplex.class, JUnitStudyFunction.class,&#125;)public class TestAll &#123;&#125; 我们将所有的类名加入到 SuitClasses 列表内部，然后执行类 TestAll 即可自动完成所有的测试工作。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.duanxu.tech/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.duanxu.tech/tags/Java/"},{"name":"JUnit","slug":"JUnit","permalink":"http://blog.duanxu.tech/tags/JUnit/"}]},{"title":"FreeMarker 学习（Java）","slug":"2016/2016-07-29-FreeMarker-学习","date":"2016-07-29T04:10:23.000Z","updated":"2018-12-07T12:51:17.032Z","comments":true,"path":"2016/07/29/2016/2016-07-29-FreeMarker-学习/","link":"","permalink":"http://blog.duanxu.tech/2016/07/29/2016/2016-07-29-FreeMarker-学习/","excerpt":"","text":"content{:toc} 1 FreeMarker简介引自“百度百科” FreeMarker是一款模板引擎： 即一种基于模板和要改变的数据，并用来生成输出文本（HTML网页、电子邮件、配置文件、源代码等）的通用工具。它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入他们所开发产品的组件。FreeMarker是免费的，基于Apache许可证2.0版本发布。其模板编写为FreeMarker Template Language（FTL），属于简单、专用的语言。需要准备数据在真实编程语言中来显示，比如数据库查询和业务运算，之后模板显示已经准备好的数据。在模板中，主要用于如何展现数据，而在模板之外注意于要展示什么数据。 2 导入FreeMarkerFreeMarker提供了一个jar包，在Java工程里，只要引入这个jar包即可： 点击“Add as Library”便可以在程序中使用FreeMarker的各种功能了。 3 FreeMarker基本语法FreeMarker在使用过程中主要包含两部分，一部分是模板文件，另一部分就是程序执行代码。首先编写一个符合FreeMarker语法的模板文件，然后在Java程序中编译这个模板文件，即可生成我们需要的文件。 FreeMarker模板文件主要由如下4个部分组成: 文本:直接输出的部分 注释:&lt;#– … –&gt;格式部分,不会输出 插值:即${…}或#{…}格式的部分,将使用数据模型中的部分替代输出 FTL指令:FreeMarker指定,和HTML标记类似,名字前加#予以区分,不会输出 3.1 插值规则插值有如下两种类型: (1)通用插值${expr} : 如果，expr==10，那么插值“${expr}”，将被直接替换成“10”。 (2)数字格式化插值${expr;format} : format基本格式为“mXMY”，分别代表小数部分最少为X位，小数部分最大为Y位。即如果，expr==10，那么插值“${expr;m1}”，将被直接替换成“10.0”。 3.2 FTL指令FreeMarker使用FTL标签来使用指令其标签和HTML标签类似： 开始标签:&lt;#oper arg&gt; 结束标签:&lt;/#oper&gt; 空标签:&lt;#oper arg/&gt; 4 以编写JavaBean为例本小结中，将通过模板文件生成一个JavaBeans。 4.1 模板文件首先，是JavaBeans的基本结构。JavaBeans是Java中一种特殊的类，可以将多个对象封装到一个对象（bean）中。特点是可序列化，提供无参构造器，提供getter方法和setter方法访问对象的属性。 基本结构如下： 12345678910package 包名;public class 类名 &#123; private 类型 名称; public 类名() &#123;&#125; public 类型 get名称() &#123;&#125; public void set名称(类型 参数) &#123;&#125;&#125; 根据此我们可以编写模板如下（其中cap_first意为将字符串首字符改为大写）： 1234567891011121314151617181920212223package $&#123;package&#125;;public class $&#123;class&#125; &#123; &lt;#list attrs as attr&gt; private $&#123;attr.type&#125; $&#123;attr.name&#125;; &lt;/#list&gt; // default constructor public $&#123;class&#125;() &#123; &#125; &lt;#list attrs as attr&gt; public $&#123;attr.type&#125; get$&#123;attr.name?cap_first&#125;() &#123; return this.$&#123;attr.name&#125;; &#125; public void set$&#123;attr.name?cap_first&#125;($&#123;attr.type&#125; $&#123;attr.name&#125;) &#123; this.$&#123;attr.name&#125; = $&#123;attr.name&#125;; &#125; &lt;/#list&gt;&#125; 4.2 程序文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package science.duanxu;import freemarker.template.Configuration;import freemarker.template.DefaultObjectWrapper;import freemarker.template.Template;import java.io.File;import java.io.FileOutputStream;import java.io.OutputStreamWriter;import java.io.Writer;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class Main &#123; public static void main(String[] args)&#123; try &#123; Configuration conf = new Configuration(); conf.setDirectoryForTemplateLoading(new File(\".\")); conf.setObjectWrapper(new DefaultObjectWrapper()); //conf.setDefaultEncoding(\"UTF-8\"); Template template = conf.getTemplate(\"./Student.ftl\"); // parms 中存贮的key值即为模板中可以直接获取的值 Map&lt;String, Object&gt; parms = new HashMap&lt;&gt;(); parms.put(\"package\", \"science.duanxu\"); parms.put(\"class\", \"Student\"); // 获取子属性值需要通过一个 JavaBean 来获取 List&lt;Attr&gt; attrs = new ArrayList&lt;&gt;(); attrs.add(new Attr(\"String\", \"name\")); attrs.add(new Attr(\"String\", \"address\")); attrs.add(new Attr(\"Integer\", \"age\")); parms.put(\"attrs\", attrs); Writer writer = new OutputStreamWriter(new FileOutputStream(\"Student.java\")); template.process(parms, writer); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static class Attr &#123; private String type; private String name; public Attr() &#123; &#125; public Attr(String type, String name) &#123; this.type = type; this.name = name; &#125; public void setType(String type) &#123; this.type = type; &#125; public String getType() &#123; return this.type; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125; &#125;&#125; 4.3 输出结果12345678910111213141516171819202122232425262728293031323334353637package science.duanxu;public class Student &#123; private String name; private String address; private Integer age; // default constructor public Student() &#123; &#125; public String getName() &#123; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return this.address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public Integer getAge() &#123; return this.age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 5 总结 FreeMarker可以很方便的根据模板构造输出文件 还有很多更加灵活的使用技巧，需要学习如何使用。 上述实例中，可以将一些路径信息和成员变量信息事先写入到一个配置文件内，通过读取配置文件，便可以更加方便的输出文件。 在实际应用中，通过FreeMarker可以很方便的编写自动测试花用例，从而提高测试效率。 …","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.duanxu.tech/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.duanxu.tech/tags/Java/"},{"name":"FreeMarker","slug":"FreeMarker","permalink":"http://blog.duanxu.tech/tags/FreeMarker/"}]},{"title":"Ubuntu 双屏分辨率设置","slug":"2016/2016-07-26-Ubuntu-双屏分辨率设置","date":"2016-07-26T12:07:23.000Z","updated":"2018-12-07T12:50:28.090Z","comments":true,"path":"2016/07/26/2016/2016-07-26-Ubuntu-双屏分辨率设置/","link":"","permalink":"http://blog.duanxu.tech/2016/07/26/2016/2016-07-26-Ubuntu-双屏分辨率设置/","excerpt":"","text":"content{:toc} 问题描述：在使用Ubuntu写代码的时候，使用双屏会更爽一些，但是这也带来了很多问题。比如在显卡驱动支持性不是很好的时候，第二块显示器有时的分辨率不是很理想，会出现分辨率低于显示器标准分辨率的情况。在设置选项里面，第二块显示器识别为“未知的显示器”。在这种情况下，需要我们手工设置显示器的分辨率。 解决方案：主要通过 xrandr 命令假设我们现有的两块显示器分辨率均为“1920*1080” 首先，直接运行xrandr查看下分辨率的情况： $ xrandrScreen 0: minimum 320 x 200, current 3360 x 1050, maximum 8192 x 8192DisplayPort-0 connected primary 1680x1050+0+0 (normal left inverted right x axis y axis) 0mm x 0mm 1024x768 60.00 800x600 60.32 56.25 848x480 60.00 640x480 59.94 1440x900 59.89DVI-0 connected 1680x1050+1680+0 (normal left inverted right x axis y axis) 473mm x 296mm 1680x1050 59.95+ 1600x1000 60.01 1280x1024 75.02 60.02 1440x900 59.89 1280x960 60.00 1152x864 75.00 1024x768 75.08 60.00 832x624 74.55 800x600 75.00 60.32 640x480 75.00 60.00 720x400 70.08 发现，我们接在 DP接口上显示器没有工作在正常的分辨率上（其中标星号的是我们正在使用的分辨率）。 $ xrandrScreen 0: minimum 320 x 200, current 3360 x 1050, maximum 8192 x 8192DisplayPort-0 connected primary 1680x1050+0+0 (normal left inverted right x axis y axis) 0mm x 0mm 1024x768 60.00 800x600 60.32 56.25 848x480 60.00 640x480 59.94 1440x900_60.00 59.89 1680x1050_60.00 59.95DVI-0 connected 1680x1050+1680+0 (normal left inverted right x axis y axis) 473mm x 296mm 1680x1050 59.95+ 1600x1000 60.01 1280x1024 75.02 60.02 1440x900 59.89 1280x960 60.00 1152x864 75.00 1024x768 75.08 60.00 832x624 74.55 800x600 75.00 60.32 640x480 75.00 60.00 720x400 70.08 写成脚本上述方法有个问题，就是每次重启之后需要再次设置分辨率，这里我们将其写为脚本，每次设置的时候只要运行一下脚本即可： 首先新建一个脚本文件： vi display.sh 然后将命令写入脚本文件： 12345678#!/bin/bash# set screen resolution to 1400 * 900xrandr --newmode \"1680x1050_60.00\" 146.25 1680 1784 1960 2240 1050 1053 1059 1089 -hsync +vsync;xrandr --addmode DisplayPort-0 \"1680x1050_60.00\";xrandr --output DisplayPort-0 --mode 1680x1050_60.00;xrandr --output DisplayPort-0 --right-of --down DVI-0; 至此，每次修改分辨率的时候，只要执行 display.sh 脚本即可自动修改。另外将其加入开机启动项，那么每次开机的时候便会自动执行。","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.duanxu.tech/categories/Other/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://blog.duanxu.tech/tags/Ubuntu/"},{"name":"双屏","slug":"双屏","permalink":"http://blog.duanxu.tech/tags/双屏/"},{"name":"分辨率","slug":"分辨率","permalink":"http://blog.duanxu.tech/tags/分辨率/"}]},{"title":"LeetCode 72. Edit Distance(HARD)","slug":"2016/2016-05-31-LeetCode-72-EditDistance","date":"2016-05-31T13:56:00.000Z","updated":"2018-12-07T12:50:12.674Z","comments":true,"path":"2016/05/31/2016/2016-05-31-LeetCode-72-EditDistance/","link":"","permalink":"http://blog.duanxu.tech/2016/05/31/2016/2016-05-31-LeetCode-72-EditDistance/","excerpt":"","text":"content{:toc} 此题为求最短编辑距离，类似的题目有很多： LeetCode Edit-Distance NowCoder 计算字符串的相似度 NowCoder 计算字符串的距离 Discription:Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.) You have the following 3 operations permitted on a word: Insert a character Delete a character Replace a character 题目描述：给定两个单词 word1 和 word2，计算从 word1 转化到 word2 所需的最短编辑距离，每次操作就算作一次编辑距离。 允许的操作有3种： 插入一个字符 删除一个字符 替换一个字符 算法思想：思路一：考虑到两个游标 $$ i $$ 指向 $$ word1 $$ 中的位置， $$ j $$ 指向 $$ word2 $$ 中的位置。当 $$ i $$ 和 $$ j $$ 分别指向字符串末尾时，计算出的 $$ count $$ 值便为最终的最短编辑距离。于是可以考虑动态规划来解决此问题。$$ dp[i][j] $$ 表示 $$ word1(0,i) $$ 和 $$ word2(0,j) $$ 这两个字串的最短编辑距离。 最优子结构：由于字符串的特殊性，$$ dp[i][j] $$ 的状态只取决于 $$ dp[i-1][j-1], dp[i-1][j], dp[i][j-1] $$ 这三者的状态转移。这三者状态转移后的最优状态必是问题的解，可见问题具有最优子结构性质。 子问题重叠：在计算 $$ dp[i+1][j+1], dp[i+1][j], dp[i][j+1] $$ 都要用到 $$ dp[i][j] $$ 的状态转移，可见问题具有自问题重叠性质。 边界情况：当 $$ i = 0 $$ 时，最短编辑距离显然为 $$ j $$ ，$$ j = 0 $$ 时，最短编辑距离为 $$ i $$。 经过上述分析，可以得到状态转移方程： $$\\begin{equation} dp[i][j] = \\begin{cases} i &amp; ,j = 0 \\ j &amp; ,i = 0 \\ dp[i-1][j-1] &amp; ,word1[i]==word2[j] \\ min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1]) &amp; ,word1[i]!=word2[j] \\ \\end{cases} \\end{equation}$$ 代码（C++）：12345678910111213141516171819202122232425262728293031/* 思路一 &amp;&amp; 头文件省略 */class Solution&#123;public: int minDistance(string word1, string word2) &#123; int m = (int)word1.length(), n = (int)word2.length(); if(m == 0 || n == 0) return m + n; vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; m; i++) for(int j = 0; j &lt; n; j++) if(word1[i] == word2[j]) dp[i][j] = i&amp;&amp;j ? dp[i-1][j-1] : i + j; else dp[i][j] = min(i&amp;&amp;j ? dp[i-1][j-1] : i+j, min(i ? dp[i-1][j] : j, j ? dp[i][j-1] : i)) + 1; return dp[m-1][n-1]; &#125;&#125;;int main()&#123; string word1, word2; Solution solution; while(cin &gt;&gt; word1 &gt;&gt; word2) &#123; cout &lt;&lt; solution.minDistance(word1, word2) &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.duanxu.tech/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.duanxu.tech/tags/LeetCode/"},{"name":"ACM","slug":"ACM","permalink":"http://blog.duanxu.tech/tags/ACM/"}]},{"title":"LeetCode 188. Best Time to Buy and Sell Stock IV(HARD)","slug":"2016/2016-05-16-LeetCode-188-BestTimeToBuyAndSellStockIV","date":"2016-05-16T13:33:00.000Z","updated":"2018-12-07T12:50:10.097Z","comments":true,"path":"2016/05/16/2016/2016-05-16-LeetCode-188-BestTimeToBuyAndSellStockIV/","link":"","permalink":"http://blog.duanxu.tech/2016/05/16/2016/2016-05-16-LeetCode-188-BestTimeToBuyAndSellStockIV/","excerpt":"","text":"content{:toc} 更多内容参考 121. Best Time to Buy and Sell Stock 更多内容参考 122. Best Time to Buy and Sell Stock II 更多内容参考 123. Best Time to Buy and Sell Stock III Discription:Say you have an array for which the $$ i^{th} $$ element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题目描述：假设给定一个数组，数组的第 i 个元素是第 i 天股票的价格。 设计一个算法使得盈利最大化。你最多可以进行 k 次交易。 注意：你不能在同一时间同时存在多次交易（比如你在购买股票之前将其售出）。 算法思想（思路一）：参考123. Best Time to Buy and Sell Stock III的解题过程，可以得到类似的解法： 首先假设我们初始金币为 0。 $$ buy[j] $$ 意味着我们需要从别人那借钱来买股票。我们需要保证利润最大化，所以应当尽可能少的去借钱。 $$ sell[j] $$ 意味着我们想要出售股票，在出售之后，我们的获得了当天股票的价格 $$ price[j] $$ ，之后还回一开始借来的钱，所以最后总的利润是 $$ price[j] - | buy[j] | = prices[j] + buy[j] $$。我们的目的是保证利润最大化。 $$ buy[j] $$ 更新过程中，如果要买另外一只股票，这时我们已经拥有了 $$ sell[j-1] $$ 的钱，所以在购买 $$ buy[j] $$ 之后，我们还剩有 $$ buy[j] = sell[j-1] - price[i] $$。需要尽可能多的省钱，所以需要保证 $$ buy[j] $$ 最大化。 $$ sell[j] $$ 意味着我们想要出售股票 $$ j $$ ，在出售之后，我们的获得了当天股票的价格 $$ price[j] $$ ，由于之前已经有了 $$ buy[j] $$ 那么多余钱，所以 $$ sell[j] = buy[j] + prices[j] $$ 是最终的利润。保证 $$ sell[j] $$ 最大化。 最后，更新 $$ k $$ 轮之后，$$ sell[k] $$即为得到的最终利润，作为返回结果即可。 注意：有可能 $$ k $$ 的值很大，当 $$ k $$ 的值大于天数的一半时，意味着我们可以在每个上涨周期内都交易股票，此时最大利润即为每个上涨利润之和。 代码（C++）：123456789101112131415161718192021222324252627282930313233class Solution&#123;public: int maxProfit(int k, vector&lt;int&gt; &amp;prices) &#123; if (k == 0) return 0; if (k &gt;= prices.size() / 2) // 如果买卖次数大于天数一半 &#123; // 可以获得每个上涨周期的利润 int sum = 0; for (int i = 1; i &lt; prices.size(); i++) &#123; if (prices[i] &gt; prices[i - 1]) // 如果价格上涨 &#123; sum += prices[i] - prices[i - 1]; // 利润加入总利润 &#125; &#125; return sum; &#125; vector&lt;int&gt; buy(k+1, INT_MIN), sell(k+1, 0); for (int i = 0; i != prices.size(); i++) &#123; for (int j = 1; j &lt;= k; j++) // k 轮循环得到最大利润 &#123; buy[j] = max(buy[j], sell[j - 1] - prices[i]); // j 轮借的钱和上一轮剩下的钱 sell[j] = max(sell[j], prices[i] + buy[j]); // j 轮的总利润 &#125; &#125; return sell[k]; &#125;&#125;; 算法思想（思路二）：思路一主要考虑递推公式的方法，这是一种间接的动态规划。现在如果直接考虑动态规划的方法来做。 假设 $$ dp[i, j] $$ 表示遍历到 $$ prices[j] $$ 时候，进行 $$ i $$ 次交易的最大利润。 $$ dp[0, j] = 0 $$ 表示进行 0 次交易，利润为 0。 $$ dp[i, 0] = 0 $$ 表示只有 1 个价格数据，无法交易，所以利润为 0。 交易的最大利润和前面若干天交易均有关。(1)前一天交易的最大利润，(2)前一轮交易中，第jj天的交易利润去掉那天的股票价格然后加上当前天的价格，即为前一轮交易中到当前天的最大利润。取这两者的最大值即为本轮交易中当前天的最大利润。 $$ \\begin{align} dp[i, j] &amp;= max(dp[i, j-1], prices[j] - prices[jj] + dp[i-1, jj]), 0 ≤ jj ≤ j -1 \\ &amp;= max(dp[i, j-1], prices[j] + \\max_{ 0 ≤ jj ≤ j -1 } \\left(dp[i-1, jj] - prices[jj]\\right)) \\end{align}$$ 代码（C++）：12345678910111213141516171819202122232425262728293031323334class Solution&#123;public: int maxProfit(int k, vector&lt;int&gt; &amp;prices) &#123; if (k == 0) return 0; // 当交易次数为0时，直接返回0 int n = prices.size(); if (k &gt;= n / 2) // 交易次数大于总数据一半时，可以交易每个涨区间 &#123; int sum = 0; for (int i = 1; i &lt; n; i++) &#123; if (prices[i] &gt; prices[i - 1]) &#123; sum += prices[i] - prices[i - 1]; // 累加每个涨区间 &#125; &#125; return sum; &#125; vector&lt;vector&lt;int&gt;&gt; dp(k + 1, vector&lt;int&gt;(n, 0)); for (int i = 1; i &lt;= k; i++) &#123; int localMax = dp[i - 1][0] - prices[0]; // 单次交易的最大利润 for (int j = 1; j &lt; n; j++) &#123; dp[i][j] = max(dp[i][j - 1], prices[j] + localMax); localMax = max(localMax, dp[i - 1][j] - prices[j]); &#125; &#125; return dp[k][n - 1]; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.duanxu.tech/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.duanxu.tech/tags/LeetCode/"},{"name":"ACM","slug":"ACM","permalink":"http://blog.duanxu.tech/tags/ACM/"}]},{"title":"LeetCode 123. Best Time to Buy and Sell Stock III(HARD)","slug":"2016/2016-05-16-LeetCode-123-BestTimeToBuyAndSellStockIII","date":"2016-05-16T13:33:00.000Z","updated":"2018-12-07T12:50:07.814Z","comments":true,"path":"2016/05/16/2016/2016-05-16-LeetCode-123-BestTimeToBuyAndSellStockIII/","link":"","permalink":"http://blog.duanxu.tech/2016/05/16/2016/2016-05-16-LeetCode-123-BestTimeToBuyAndSellStockIII/","excerpt":"","text":"content{:toc} 更多内容参考 121. Best Time to Buy and Sell Stock 更多内容参考 122. Best Time to Buy and Sell Stock II Discription:Say you have an array for which the $$ i^{th} $$ element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题目描述：假设给定一个数组，数组的第 i 个元素是第 i 天股票的价格。 设计一个算法使得盈利最大化。你最多可以进行两次交易。 注意：你不能在同一时间同时存在多次交易（比如你在购买股票之前将其售出）。 算法思想：首先假设我们初始金币为 0。 所以 $$ buy1 $$ 意味着我们需要从别人那借钱来买股票。我们需要保证利润最大化，所以应当尽可能少的去借钱。 $$ sell1 $$ 意味着我们想要出售股票，在出售之后，我们的获得了当天股票的价格 $$ price[i] $$，之后还回一开始借来的钱，所以最后总的利润是 $$ price[i] - |buy1| = prices[i] + buy1 $$ 。我们的目的是保证利润最大化。 $$ buys2 $$ 意味着我们要买另外一只股票，这时我们已经拥有了 $$ sell1 $$ 的钱，所以在购买 $$ buy2 $$ 之后，我们还剩有 $$ buy2 = sell1 - price[i] $$ 。需要尽可能多的省钱，所以需要保证 $$ buy2 $$ 最大化。 $$ sell2 $$ 意味着我们想要出售股票2，在出售之后，我们的获得了当天股票的价格 $$ price[i] $$ ，由于之前已经有了 $$ buy2 $$ 那么多余钱，所以 $$ sell2 = buy2 + prices[i] $$ 是最终的利润。保证 $$ sell2 $$ 最大化，然后作为返回结果即可。 代码（C++）：12345678910111213141516class Solution&#123;public: int maxProfit(vector&lt;int&gt; &amp;prices) &#123; int buy1 = INT_MIN, sell1 = 0, buy2 = INT_MIN, sell2 = 0; for(int i = 0; i != prices.size(); i++) &#123; buy1 = max(buy1 , -prices[i]); // buy1 尽可能少借钱买股票 sell1 = max(sell1, (prices[i] + buy1)); // 尽可能多的获取股票1得到的利润 buy2 = max(buy2 , (sell1 - prices[i])); // 拥有 buy1 的余钱，然后尽可能花少的钱买 buy2 sell2 = max(sell2, (prices[i] + buy2)); // 保证 sell2 利润最大化 &#125; return sell2; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.duanxu.tech/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.duanxu.tech/tags/LeetCode/"},{"name":"ACM","slug":"ACM","permalink":"http://blog.duanxu.tech/tags/ACM/"}]},{"title":"LeetCode 122. Best Time to Buy and Sell Stock II(MEDIUM)","slug":"2016/2016-05-16-LeetCode-122-BestTimeToBuyAndSellStockII","date":"2016-05-16T13:31:00.000Z","updated":"2018-12-07T12:50:05.930Z","comments":true,"path":"2016/05/16/2016/2016-05-16-LeetCode-122-BestTimeToBuyAndSellStockII/","link":"","permalink":"http://blog.duanxu.tech/2016/05/16/2016/2016-05-16-LeetCode-122-BestTimeToBuyAndSellStockII/","excerpt":"","text":"content{:toc} 更多内容参考 121. Best Time to Buy and Sell Stock Discription:Say you have an array for which the $$ i^{th} $$ element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题目描述：假设给定一个数组，数组的第 i 个元素是第 i 天股票的价格。 设计一个算法使得盈利最大化。你可以随意进行交易（比如，可以多次购买和售出同一只股票）。但是，你不能在同一时间同时存在多次交易（比如你在购买股票之前将其售出）。 算法思想：由于我们可以多次买卖，那么就采取这样的策略：股票价格上涨就不动，赚取上涨的差价。股票价格下降就立即售出，保证我们可以避免损失。也就是说，在理想情况下，我们可以赚取每次价格上涨带来的盈利而不蒙受任何损失。所以可得代码如下： 代码（C++）：1234567891011121314class Solution&#123;public: int maxProfit(vector&lt;int&gt; &amp;prices) &#123; int maxProf = 0; // 最大盈利 for (int i = 1; i &lt; prices.size(); i++) &#123; if (prices[i] &gt; prices[i - 1]) // 如果价格上涨了，就可以赚取其差价 maxProf += (prices[i] - prices[i - 1]); &#125; return maxProf; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.duanxu.tech/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.duanxu.tech/tags/LeetCode/"},{"name":"ACM","slug":"ACM","permalink":"http://blog.duanxu.tech/tags/ACM/"},{"name":"Medium","slug":"Medium","permalink":"http://blog.duanxu.tech/tags/Medium/"}]},{"title":"LeetCode 121. Best Time to Buy and Sell Stock(EASY)","slug":"2016/2016-05-16-LeetCode-121-BestTimeToBuyAndSellStock","date":"2016-05-16T13:28:00.000Z","updated":"2018-12-07T12:50:03.945Z","comments":true,"path":"2016/05/16/2016/2016-05-16-LeetCode-121-BestTimeToBuyAndSellStock/","link":"","permalink":"http://blog.duanxu.tech/2016/05/16/2016/2016-05-16-LeetCode-121-BestTimeToBuyAndSellStock/","excerpt":"","text":"content{:toc} Discription:Say you have an array for which the $$ i^{th} $$ element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. 题目描述：假设给定一个数组，数组的第 i 个元素是第 i 天股票的价格。 如果只允许你进行一次交易（比如购买和出售一只股票），设计一个算法使盈利最大化。 算法思想：既然只能进行一次交易，那么就应该在序列中找到两个数 $$ a $$ 和 $$ b $$，使得 $$ a $$ 位于 $$ b $$ 之前， $$ a &lt; b $$ 且其差值最大。于是我们可以这样考虑，在遍历数组的时候存储一个已经遍历的最小值，然后用当前遍历的值对其求差，将差值记录下来，这个就是最后返回的最大化的盈利。 代码（C++）：12345678910111213141516class Solution&#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.size() == 0) return 0; // 数组为空的情况 int min = prices[0], maxProf = 0; for(int i = 1; i != prices.size(); i++) &#123; min = min &lt; prices[i] ? min : prices[i]; maxProf = (prices[i] - min) &gt; maxProf ? (prices[i] - min) : maxProf; &#125; return maxProf; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.duanxu.tech/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.duanxu.tech/tags/LeetCode/"},{"name":"ACM","slug":"ACM","permalink":"http://blog.duanxu.tech/tags/ACM/"},{"name":"Easy","slug":"Easy","permalink":"http://blog.duanxu.tech/tags/Easy/"}]},{"title":"LeetCode 313. Super Ugly Number(MEDIUM)","slug":"2016/2016-05-15-LeetCode-313-SuperUglyNumber","date":"2016-05-15T11:35:00.000Z","updated":"2018-12-07T12:49:59.687Z","comments":true,"path":"2016/05/15/2016/2016-05-15-LeetCode-313-SuperUglyNumber/","link":"","permalink":"http://blog.duanxu.tech/2016/05/15/2016/2016-05-15-LeetCode-313-SuperUglyNumber/","excerpt":"","text":"content{:toc} 更多内容参考 263. Ugly Number 更多内容参考 264. Ugly Number II Discription:Write a program to find the nth super ugly number. Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. For example, [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32] is the sequence of the first 12 super ugly numbers given primes = [2, 7, 13, 19] of size 4. Note: 1 is a super ugly number for any given primes. The given numbers in primes are in ascending order. $$ 0 &lt; k ≤ 100, 0 &lt; n ≤ 10^6, 0 &lt; primes[i] &lt; 1000 $$. 题目描述：写一个程序来计算第n个超级丑数的值。 超级丑数是一个正整数，它的左右因子只包含给定的k个质数。例如：给定大小为4的质数序列：primes = [2, 7, 13, 19]，前12个超级丑数的序列为：[1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]。 注意： 1是一个特殊的丑数。 给定的质数序列是递增序列。 $$ 0 &lt; k ≤ 100, 0 &lt; n ≤ 10^6, 0 &lt; primes[i] &lt; 1000 $$. 算法思想： 申请一个长度为 n 的数组 ugly，用于从小到大顺序存储 n 个超级丑数，数组中的首项为 1 ，即第一个超级丑数为 1 申请一个长度和 primes 相同的数组 index，用于存储下标，初始值均为 0 找出数组对于 index 内的每个下标 j，计算 ugly[index[j]]*primes[j] 的最小值，最小值即为下一个超级丑数，同时更新最小值对应的下标，如果多个数字同时为最小值，则它们的下标都要更新 找到第 n 个超级丑数时，循环结束，返回最后一个超级丑数 代码（C++）：1234567891011121314151617181920class Solution&#123;public: int nthSuperUglyNumber(int n, vector&lt;int&gt; &amp;primes) &#123; int len = primes.size(); // 质数的个数 vector&lt;int&gt; index(len, 0), ugly(n, INT_MAX); ugly[0] = 1; // 第一个超级丑数为 1 for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; len; j++) // 找到 ugly[index[j]]×primes[j] 的最小值 ugly[i] = min(ugly[i], ugly[index[j]] * primes[j]); for (int j = 0; j &lt; len; j++) // 更新下标 index[j] += (ugly[i] == ugly[index[j]] * primes[j]); &#125; return ugly[n - 1]; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.duanxu.tech/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.duanxu.tech/tags/LeetCode/"},{"name":"ACM","slug":"ACM","permalink":"http://blog.duanxu.tech/tags/ACM/"},{"name":"Medium","slug":"Medium","permalink":"http://blog.duanxu.tech/tags/Medium/"}]},{"title":"LeetCode 264. Ugly Number II(MEDIUM)","slug":"2016/2016-05-15-LeetCode-264-UglyNumberII","date":"2016-05-15T11:20:00.000Z","updated":"2018-12-07T12:49:14.898Z","comments":true,"path":"2016/05/15/2016/2016-05-15-LeetCode-264-UglyNumberII/","link":"","permalink":"http://blog.duanxu.tech/2016/05/15/2016/2016-05-15-LeetCode-264-UglyNumberII/","excerpt":"","text":"content{:toc} 更多内容参考 263. Ugly Number Discription:Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note that 1 is typically treated as an ugly number. 题目描述：写一个程序来计算第n个丑数的值。 丑数是一个正整数，它的左右因子只包含2、3、5。例如：1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前10个丑数的序列 。 注意，1是一个特殊的丑数。 算法思想： 申请一个长度为n的数组uglyNumbers，用于从小到大顺序存储n个丑数，数组中的首项为1，即第一个丑数为1 设置三个变量idx2、idx3、idx5存储下标，初始值都为0 找出数组uglyNumbers[idx2]2、uglyNumbers[idx3]3、uglyNumbers[idx5]*5的最小值，最小值即为下一个丑数，同时更新最小值对应的下标，如果多个数字同时为最小值，则它们的下标都要更新 找到第n个丑数时，循环结束 代码（C++）：12345678910111213141516171819class Solution &#123;public: int nthUglyNumber(int n) &#123; if(n &lt;= 0) return 0; if(n == 1) return 1; int t2 = 0, t3 = 0, t5 = 0; vector&lt;int&gt; k(n); k[0] = 1; for(int i = 1; i &lt; n ; i ++) &#123; k[i] = min(k[t2]*2,min(k[t3]*3,k[t5]*5)); if(k[i] == k[t2]*2) t2++; if(k[i] == k[t3]*3) t3++; if(k[i] == k[t5]*5) t5++; &#125; return k[n-1]; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.duanxu.tech/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.duanxu.tech/tags/LeetCode/"},{"name":"ACM","slug":"ACM","permalink":"http://blog.duanxu.tech/tags/ACM/"},{"name":"Medium","slug":"Medium","permalink":"http://blog.duanxu.tech/tags/Medium/"}]},{"title":"LeetCode 263. Ugly Number(EASY)","slug":"2016/2016-05-15-LeetCode-263-UglyNumber","date":"2016-05-15T11:13:00.000Z","updated":"2018-12-07T12:49:04.263Z","comments":true,"path":"2016/05/15/2016/2016-05-15-LeetCode-263-UglyNumber/","link":"","permalink":"http://blog.duanxu.tech/2016/05/15/2016/2016-05-15-LeetCode-263-UglyNumber/","excerpt":"","text":"content{:toc} Discription:Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7. Note that 1 is typically treated as an ugly number. 题目描述：写一个程序来检查一个数是否为丑数。 丑数是一个正整数，它的左右因子只包含2、3、5。例如，6和8是丑数，但是14不是丑数（因为它包含了因子7）。 注意，1是一个特殊的丑数。 算法思想：如果 n 不为 0 的话，就将它分别除以 2、3、5。 代码（C++）：1234567891011class Solution&#123;public: bool isUgly(int num) &#123; for (int i=2; i&lt;6 &amp;&amp; num; i++) while (num % i == 0) num /= i; return num == 1; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.duanxu.tech/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.duanxu.tech/tags/LeetCode/"},{"name":"ACM","slug":"ACM","permalink":"http://blog.duanxu.tech/tags/ACM/"},{"name":"Easy","slug":"Easy","permalink":"http://blog.duanxu.tech/tags/Easy/"}]},{"title":"LeetCode 316. Remove Duplicate Letters(HARD)","slug":"2016/2016-05-15-LeetCode-316-RemoveDuplicateLetters","date":"2016-05-15T06:16:00.000Z","updated":"2018-12-07T12:50:01.911Z","comments":true,"path":"2016/05/15/2016/2016-05-15-LeetCode-316-RemoveDuplicateLetters/","link":"","permalink":"http://blog.duanxu.tech/2016/05/15/2016/2016-05-15-LeetCode-316-RemoveDuplicateLetters/","excerpt":"","text":"content{:toc} Discription:Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Example: Given “bcabc”Return “abc” Given “cbacdcbc”Return “acdb” 题目描述：给定一个只包含小写字母的字符串，移除所有的重复字母，使得字符串中的所有字母出现且仅出现一次。你必须确保你得到的解，是所有满足条件结果中处于字典序最小的那个。 输入 “bcabc”输出 “abc” 输入 “cbacdcbc”输出 “acdb” 算法思想： 首先，仅出现一次的字符是必选的。称其为独立字符。 如果一个字符出现多次，在独立字符前后都有出现，那么，选择后面的丢掉前面的（为了字典序更小）。 由于独立字符必选，且字典序最小。所以，以独立字符为界将字符串分段的话，应尽量使前面的段更小，满足贪心的性质。 在每一小段内，段最后是仅出现一次的独立字符，其余均为出现多次的字符。应当保证最后选取的字符均小于独立字符，且选取的字符单调递增。如果不这样的话，将破坏单调性的字符放到后面段内选择，字典序会更优。 如果段内存在相同的字符，则根据其后面是否出现比其小的字符，如果有选后面的，如果没有选择前面的。比如“abacf”选择前面的“a”(“abcf”)，“ebecf”选择后面的“e”(“becf”)。 于是可得算法如下（栈来存储当前选择的字符）： 首先进行一次遍历计数，统计每个字符出现的次数。然后，从头开始遍历字符串。如果当前字符未被选择，当前的字符串为首字符或者大于最后选择的字符（栈顶字符），那么就将其放到栈中，并其计数-1，标记已经选择。否则，如果当前字符小于或等于最后选择字符，就将大于当前字符的非独立字符都出栈（当等于的时候，如果当前字符未被选择，说明存在小于其的字符，但也可能存在大于其的字符，所以按照普通情况对待）。对于栈中的字符，出栈的时候遇到独立字符，那么意味着遇到了分界，否则栈非空的时候一直出栈。然后，将当前字符入栈，更新信息。如果当前字符已经被选择，意味着可以直接跳过。 算法复杂度 O(n)，LeetCode 4ms 代码（C++）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution&#123;public: string removeDuplicateLetters(string s) &#123; if(s.length() == 0 || s.length() == 1) return s; // 如果串长度为0或者1，直接返回此串 int count[26] = &#123;0&#125;, len = s.length(); // 计数数组 bool isSelect[26] = &#123;false&#125;; // 某个字符是否被选择 for(int i = 0; i &lt; len; i++) count[s[i] - 'a']++; // 初始化计数数组 stack&lt;char&gt; stack; // 用来存储选择的字符 stack.push(s[0]); // 处理首个字符 count[s[0] - 'a']--; isSelect[s[0] - 'a'] = true; for(int curr = 1; curr &lt; len; curr++) // 对除了首字符的所有字符进行处理 &#123; // curr 代表当前字符位置 if(!isSelect[s[curr] - 'a']) // 如果当前字符未被选择 &#123; if(s[curr] &gt; stack.top()) // 如果当前字符大于最后选择的字符 &#123; // 那么就将其放到栈中，并其计数-1，标记已经选择 stack.push(s[curr]); count[s[curr] - 'a']--; isSelect[s[curr] - 'a'] = true; &#125; else // 如果当前字符小于或等于最后选择的字符 &#123; while(!stack.empty() &amp;&amp; stack.top() &gt; s[curr] &amp;&amp; count[stack.top() - 'a'] &gt;= 1) &#123; isSelect[stack.top() - 'a'] = false;// 将此字符标记为未选择后出栈 stack.pop(); &#125; stack.push(s[curr]); // 当前字符未被选择，入栈 count[s[curr] - 'a']--; // 此时栈中以独立字符为界，后面的所有字符到新入栈的当前字符 isSelect[s[curr] - 'a'] = true; // 应当保持单调递增顺序 &#125; &#125; else count[s[curr] - 'a']--; // 当前字符已经被选择的话，无条件计数-1，跳过。 &#125; string str; // 将栈中的字符按照出栈顺序倒序插入string中，作为返回串 while(!stack.empty()) &#123; str.insert(str.begin(), stack.top()); stack.pop(); &#125; return str; &#125;&#125;;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.duanxu.tech/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://blog.duanxu.tech/tags/LeetCode/"},{"name":"ACM","slug":"ACM","permalink":"http://blog.duanxu.tech/tags/ACM/"},{"name":"Hard","slug":"Hard","permalink":"http://blog.duanxu.tech/tags/Hard/"}]},{"title":"为 HTC ONE X 编译 CyanogenMod","slug":"2016/2016-05-04-为HTC_ONE_X编译CyanogenMod","date":"2016-05-04T04:06:00.000Z","updated":"2018-12-07T12:48:31.171Z","comments":true,"path":"2016/05/04/2016/2016-05-04-为HTC_ONE_X编译CyanogenMod/","link":"","permalink":"http://blog.duanxu.tech/2016/05/04/2016/2016-05-04-为HTC_ONE_X编译CyanogenMod/","excerpt":"","text":"content{:toc} 本文翻译自CyanogenMod Wiki。 1.简介 这个教程将帮助你从一个解锁了 bootloader 的 HTC ONE X （以下简称 HOX）开始，然后下载必要的工具和基于谷歌安卓系统的最新的 CyanogenMod 源代码。通过这些，你可以从源代码编译 CyanogenMod 和 CyanogenMod Recovery 镜像，然后将其安装到你的手机。 很难讲清楚顺利完成这个教程需要多少经验。这个教程显然不是为了纯小白准备的，但是你也不需要一个软件工程的博士学位。一些读者可以无障碍的顺利完成此教程。另一些人可能需要在基本操作上进行一些探索。因为每个人的经历、背景和经验都是不同的。每进行一步都弄清楚你是否理解并正确执行了是很重要的。 记住，你可能遇到很多困难，但是克服这些困难是值得的！在自己家中就能够为你的手机安装一个全新的操作系统，这是很令人愉快的。一旦你成为一个安卓大神，你就不需要等待每日编译版（nightly）。因为你具备了从源代码编译安装完整操作系统的能力。为了成为一个大神，你可能需要增加一个功能、修复一个BUG、添加语言支持、学习编译一个新的 APP或者将源码编译到一个新的设备，这完全取决于你自己喜好。 1.1 你将需要的 一台 HTC ONE X 一台较新的电脑（Linux，OS X，或者 Windows），拥有可观的 RAM 和 100GB 以上的可用空间（如果你开启了 ccache 或者为多台设备构造，你可能需要更多）。RAM 越小编译时间越久（推荐 8GB 或更多）。使用 SSD 会显著提升编译的速度。 一根和 HOX 兼容的 USB 数据线。 熟悉基本的安卓系统和终端的操作。如果你安装过自定义的 ROM，或者你熟悉 recovery，这会是很有帮助的。了解基本的终端命令也是很有用的，比如 cd(change directory)。 学习使用 Linux 很有挑战，如果你不熟悉 Linux 的使用，那么就下载一个虚拟机软件，比如 VirtualBox，然后在其中安装 Ubuntu 来学习 Linux。任何最近的64位版本都能得到很好的支持，但是我们推荐使用最新的版本。 注意：你需要使用64位的系统，一个32位的环境只支持编译 CyanogenMod 6 或者更早的系统。对于 CyanogenMod 10.1 如果你遇到了64位主机问题，你可以在你的环境中设置 “BUILD_HOST_32bit=1”。这通常是不需要的，尤其是在 CyanogenMod 10.2 或更新的版本中。 使用一个虚拟机可以在你的现有系统内再运行一个系统。如果你对任何版本的 Linux 都觉得厌烦，你总是可以卸载和删除所有的东西。设置一个 Ubuntu 虚拟机的教程满世界都找得到，对此不在赘述。 好，我们现在开始把！ 2.编译 CyanogenMod 和 CyanogenMod Recovery2.1 准备编译环境 注意：你仅仅在第一次编译的时候需要做这些，如果你已经准备好了环境，然后下载了 CyanogenMod 源代码，请移步“准备设备专用代码”。 2.1.1 安装 SDK 如果你之前没有安装 adb 和 fastboot，请安装 Android SDK。SDK(Software Developer Kit)，软件开发包。其中包括一些有用的工具，通过这些工具，你可以刷新软件、查看系统时间、截图等等。所有的这些都通过电脑来完成。 注意：SDK包含很多不同的工具，adb 和 fastboot 是最有用的工具之一，位于 /platform-tools 目录下。 2.1.2 安装依赖包 要想编译 CyanogenMod，需要几个依赖包，你可以通过包管理器安装。 注意：Linux 的包管理器用于安装或者卸载软件（通常通过网络安装），对于 Ubuntu，你可以使用 Ubuntu 软件中心。或者，你可以使用 apt-get install 命令直接在终端中安装软件。 对于32位和64位系统，都需要： bison build-essential curl flex git gnupg gperf libesd0-dev liblz4-tool libncurses5-dev libsdl1.2-dev libwxgtk2.8-dev libxml2 libxml2-utils lzop maven openjdk-7-jdk openjdk-7-jre pngcrush schedtool squashfs-tools xsltproc zip zlib1g-dev 除了以上的依赖包，64位系统还需要： g++-multilib gcc-multilib lib32ncurses5-dev lib32readline-gplv2-dev lib32z1-dev 查询此网页可以看到详细的列表：依赖列表 2.2 建立目录 你需要在编译环境中新建一个目录： 12$ mkdir -p ~/bin$ mkdir -p ~/android/system 2.3 安装 repo 命令 输入下列命令下载“repo”二进制文件，并将其设置为可执行： 12$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo$ chmod a+x ~/bin/repo 2.4 将 ~/bin 目录加入到执行目录 在较新版本的 Ubuntu 中，~/bin 目录应该已经位于 PATH 内，你可以使用文本编辑器打开 ~/.profile 文件来检查以下代码是否存在： 1234# set PATH so it includes user's private bin if it existsif [ -d \"$HOME/bin\" ] ; then PATH=\"$HOME/bin:$PATH\"fi 2.5 初始化 CyanogenMod repository 输入下列代码来初始化 CyanogenMod repository。确保此处的 cm 分支是你想编译的，同时支持你的设备。 12$ cd ~/android/system/$ repo init -u https://github.com/CyanogenMod/android.git -b cm-12.1 2.6 下载源代码 开始下载源代码： 1$ repo sync CM 清单包含了一个默认的 repo 配置，我们强烈推荐你使用默认的配置（比如对 sync 不添加任何的参数）。举例来说，我们的默认配置是 “-j 4” 和 “-c”。“-j 4”意味着将会建立4个虚拟链接。如果你遇到了链接错误，你可以降低此链接数“-j 3”或者“-j 2”。“-c”意味着请求 repo 仅仅更新当前分支的最新状态，而不是整个 CM 历史版本。 下载将花费您很长时间，请耐心等待。 注意：repo sync 命令用来从 CyanogenMod 和 Google 更新最新的源代码。记住，你可以每隔几天更新一次以便保持你的源代码为最新状态。 2.7 获取预编译的APP（适用于CM11和更低版本） 输入： 1$ cd ~/android/system/vendor/cm 然后： 1$ ./get-prebuilts 你将不会看到任何确认信息，这将导致一些预编译的应用被加载和安装到源代码内。一旦完成之后，将不需要做第二次。 2.8 准备设备专用代码 完成下载源代码之后，确保你在源代码根目录下（cd ~/android/system），然后键入： 12$ source build/envsetup.sh$ breakfast endeavoru 这会下载设备专用代码和设备内核代码。 一个可选的使用 breakfast 命令的方式是编译本地列表。为了完成这个，需要你下载CM Github上列出的所有定义在 cm.dependencies 内的 repo，下载到你的本地列表内。 注意： breakfast 期间的错误 不同的维护者设计他们设备的继承规则是不同的，有些需要首先完成供应商目录后才可以进行 breakfast。如果你在供应商 makefiles 时得到一个错误，那么就跳转到下一节“提取所有的 blobs 文件”。首先确保 breakfast 被成功推送到了设备树中，并且提取 blobs 脚本应处于可用状态。在完成这个部分之后，你可以重新运行 breakfast endeavoru。 如果你想了解更多关于“source build/envsetup.sh”做了什么，或者了解 breakfast、brunch、lunch命令，单机此链接：Envsetup help。 为了方便每次返回源码根目录都需要键入“cd ~/android/system”，你可以使用 croot。为了使用此命令，你必须首先从“~/android/system”运行“source build/envsetup.sh”。 2.9 提取所有的blobs文件 现在确保你的 HOX 已经通过 USB 连接线连接到你的电脑，并且你位于“~/android/system/device/htc/endeavoru”目录，如果需要的话你可以通过“cd ~/android/system/device/htc/endeavoru”来返回。然后运行以下脚本： 1$ ./extract-files.sh 你将会在“~/android/system/vendor/htc”目录下看到从你设备中提取出来的“blobs”文件。如果你看到类似adb不能提取出文件的错误，可能是因为adb的路径没有添加到环境变量的原因，如果是这样的话，你可以查看这个关于处理”command not found”的错误信息的链接：adb。 注意：1、为了让 extract-files.sh 脚本正常工作，你的设备应当已经在运行 CyanogenMod 的某个编译版本。2、使用 extract-files.sh 脚本将所有的文件释放到“~/android/system/vendor/htc”目录是很重要的。同时会生成 Makefiles 文件来确保 blobs 文件被拷贝到设备内。如果没有这些 blobs 文件，编译 CyanogenMod 时不会出现任何错误，但是你可能丢失一些重要的功能，比如设备可能因为图形库的丢失而不显示任何东西。 2.10 开启缓存来优化编译速度 你可以加快编译速度，添加“export USE_CCACHE=1”到你的“~/.bashrc”文件。然后指定 ccache 可用的磁盘空间： 1prebuilts/misc/linux-x86/ccache/ccache -M 50G 这里的 50G 指的是缓存的空间，这只需要做一次，然后此设置将被记住。从 25GB 到 100GB 范围的缓存将显著影响编译的速度（比如一小时的编译过程可能被缩短到20分钟）。如果你只是为一个设备构造，那么25GB-50GB的空间就足够了，如果你为多个设备构造，而且不同的设备间不共享相同的内核源码，那么你需要分配75GB-100GB的空间。这些缓存空间将被永久的在你得驱动器上被占用。了解更多关于 ccahche 的信息。 注意：如果你是一名非常活跃的开发者，不仅仅工作在Android项目上，你可能倾向于将你的 Android ccahce 独立出来，因为它占用空间巨大，而且可能会降低其他项目的效率。那么就从 CyanogenMod 12.1 开始，你可以通过环境变量指定缓存的地址和大小：export ANDROID_CCACHE_DIR=”$HOME/android/.ccache”export ANDROID_CCACHE_SIZE=”50G” 2.11 开始编译 现在到了编译的时候了，输入： 12$ croot$ brunch endeavoru 然后编译将开始自动执行。 注意：1、如果编译没有开始，尝试 lunch 然后从菜单中选择你的设备。如果这仍然不工作，尝试 breakfast 然后从菜单选择，然后 make endeavoru 将开始工作。2、再次注意，如果在使用 croot、brunch、lunch 的时候提示“command not found”的错误，请确认你已经在终端中的“~/android/system”目录下执行了下面这个脚本：“.build/envsetup.sh”。 2.12 如果编译中断… 如果你遇到类似内存不足的错误： 1ERROR: signapk.jar failed: return code 1make: *** \\[out/target/product/endeavoru/cm_endeavoru-ota-eng.root.zip\\] Error 1 你可能需要做如下改动：打开“~/android/system/build/tools/releasetools/common.py”文件，查找“-Xmx2048m”（可能出现在“OPTIONS.java_args”下面，或者出现在“signapk.jar”附近）。然后将其更改为：“-Xmx1024m”或者“-Xmx512m”。然后重新编译。 如果你会突然看到什么无缘无故的被“killed”的消息，那么你的虚拟机可能内存溢出或者空间不足，请分配更多的资源，然后重试。 3.安装构建 假设编译顺利完成，在同一个终端键入“$ cd $OUT”。在这你会看到生成的所有的文件，在“/system”目录下的我们称为system，在root目录下的将会成为你的ramdisk，在kernel目录下将会成为你的kernel…. 这些只是后台信息，下面的两个文件是我们最需要关注的：(1)recovery.img,它包含了 CyanogenMod 的 Recovery, (2)cm-[something].zip，它包含了 CyanogenMod 安装包。 4.使用fastboot安装Recovery 单击此链接获得更多关于自定义Recovery的帮助。 确保你的电脑安装有 fastboot 和 adb。 通过 USB 连接你的 HOX 到电脑。 确保可执行的 fastboot 程序位于 PATH 内，并且 Recovery 镜像和 fastboot 位于同一目录。 打开终端，将手机重启至 fastboot 模式：“adb reboot bootloader”。或者通过手机特殊按键组合重启至此模式。 一旦你的设备重启到 fastboot 模式，确认你的PC是否可以识别设备：“fastboot devices”。 如果你没有看到设备号，只看到“”，说明 fastboot 没有正确安装配置，点此查看更多帮助。 如果你看到“no permissions fastboot”，确保 UDEV 规则被正确的配置了。 将 Recovery 安装到设备：“fastboot flash recovery your_recovery_image.img”。其中文字部分是 Recovery 镜像的名字。 一旦安装完成，将设备重启到 Recovery 来确认安装是否成功。 有些 ROM 在安装时会覆盖 Recovery，所以请注意你的设备 ROM 是否存在这个问题。 4.1 安装 CyanogenMod 返回“$OUT”目录，你应该看到某个文件名类似于：“cm-13.0-20160504-UNOFFICIAL-endeavoru.zip”。现在你可以像正常安装 ROM 那样在 Recovery 中安装。在此之前，请确保已经备份了重要的文件，同时备份当前系统，以防止在安装过程中出现错误。由于 CyanogenMod 没有备份功能，所以你可以选择其他 Recovery 来完成此工作，或者使用类似于 Titanium 之类的工具（需要 root 权限）。 4.2 成功！接下来… 你成功了，欢迎加入自编译的精英俱乐部，你已经从头到尾编译了你的系统…希望你能在移植的过程中学到东西，并尝到一些乐趣。 现在你已经为你的设备成功编译 CyanogenMod，这个链接是一些关于下一步该做什么的建议：一些关于下一步该做什么的建议。 此外，请在开发者主题的开发者中心上查看关于这个wiki各种详细的信息：收集logs信息，知道源代码目录里有些什么，提交你的贡献，移植CygogenMod到新设备和其它更多的内容。再次祝贺你！","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.duanxu.tech/categories/Other/"}],"tags":[{"name":"ROM","slug":"ROM","permalink":"http://blog.duanxu.tech/tags/ROM/"},{"name":"Recovery","slug":"Recovery","permalink":"http://blog.duanxu.tech/tags/Recovery/"},{"name":"CyanogenMod","slug":"CyanogenMod","permalink":"http://blog.duanxu.tech/tags/CyanogenMod/"}]},{"title":"C#开发基于Http的LaTeX数学公式转换器","slug":"2016/2016-05-03-LaTeX-CSharp-HTTP","date":"2016-05-03T01:00:00.000Z","updated":"2018-12-07T12:48:02.073Z","comments":true,"path":"2016/05/03/2016/2016-05-03-LaTeX-CSharp-HTTP/","link":"","permalink":"http://blog.duanxu.tech/2016/05/03/2016/2016-05-03-LaTeX-CSharp-HTTP/","excerpt":"","text":"content{:toc} 本文将讲解如何通过codecogs.com和Google.com提供的API接口来将LaTeX数学函数表达式转化为图片形式。具体思路如下： （1）通过TextBox获取用户输入的LaTeX数学表达式，然后对表达式格式化使之便于网络传输。 （2）将格式化之后的字符串，通过Http请求发送至codecogs.com或者Google.com。 （3）获取网站返回的数据流，将其转化为图片，并显示在PictureBox上。 具体过程为： 首先，我们在这个网站输入LaTeX数学公式然后返回图片时，即“http://latex.codecogs.com/gif.latex?“后面跟上我们输入的公式内容。比如”http://latex.codecogs.com/gif.latex?\\alpha”就显示一个希腊字母 $$ \\alpha $$ 。所以我们可以在其后加上我们希望转换的公式即可。但是需要注意的是，网络URL中的空格有时候会自动转化为加号”+“。所以，我们在传输的时候需要将空格去掉。或者将其转换为”%20“。 建立如图所示的Form。一个TextBox，六个Button和一个PictureBox。 用例为著名的“薛定谔方程”： $$ i\\hbar\\frac{\\partial \\psi}{\\partial {t}} = \\frac{-\\hbar^2}{2m} \\left( \\frac{\\partial^2}{\\partial {x^2}} +\\frac{\\partial^2}{\\partial {y^2}} + \\frac{\\partial^2}{\\partial {z^2}} \\right) \\psi + V \\psi $$ i\\hbar\\frac{\\partial\\psi}{\\partial{t}}=\\frac{-\\hbar^2}{2m}\\left(\\frac{\\partial^2}{\\partial{x^2}}+\\frac{\\partial^2}{\\partial{y^2}}+\\frac{\\partial^2}{\\partial{z^2}}\\right)\\psi+V\\psi “粘贴文本”按钮添加如下单击事件。 1234567891011121314private void btnPasteText_Click(object sender, EventArgs e)&#123; string content = Clipboard.GetText(); // 获取剪切板文本信息 textBox.Text = content; // 将信息显示到TextBox&#125;private bool check()&#123; if(textBox.Text.Trim() == \"\") // 如果TextBox为空 &#123; MessageBox.Show(this, \"请填写 LaTeX 函数代码！\"); return false; &#125; return true;&#125; “Google预览”按钮添加如下事件。 123456789101112private void btnPreviewGoogle_Click(object sender, EventArgs e)&#123; if (check()) &#123; // 首先将文本信息格式化，作为URL信息。 string ImgUrl = String.Format(PicUrlGoogle, HttpUtility.UrlPathEncode(textBox.Text)); pictureBox.ImageLocation = ImgUrl; // 加载网络图片到PictureBox btnCopyImg.Enabled = true; // 使“复制图像”按钮可用 &#125; else btnCopyImg.Enabled = false; // 否则使“复制图像”按钮不可用&#125; “Cogs预览”按钮添加如下事件。 123456789101112private void btnPreviewCogs_Click(object sender, EventArgs e)&#123; if (check()) &#123; // 首先将文本信息格式化，作为URL信息。 string ImgUrl = String.Format(PicUrlCogs, HttpUtility.UrlPathEncode(textBox.Text)); pictureBox.ImageLocation = ImgUrl; // 加载网络图片到PictureBox btnCopyImg.Enabled = true; // 使“复制图像”按钮可用 &#125; else btnCopyImg.Enabled = false; // 否则使“复制图像”按钮不可用&#125; “复制图像”按钮添加如下单击事件。 12345private void btnCopyImg_Click(object sender, EventArgs e)&#123; if(pictureBox.Image != null) Clipboard.SetImage(pictureBox.Image); // 将Picture图片复制到剪切板&#125; “显示帮助”按钮添加如下事件。 1234567private void btnHelp_Click(object sender, EventArgs e)&#123; textBox.Text = \"1、LaTex 公式前后无需 $ 符号；\\r\\n\" + \"2、需要联网，Google丑，Cogs慢；\\r\\n\" + \"3、尽量多使用 &#123;&#125; 将字段括起来；\\r\\n\" + \"4、于 2015年11月13日。\";&#125; “退出”按钮添加如下事件。 1234private void btnExit_Click(object sender, EventArgs e)&#123; System.Environment.Exit(0); // 退出程序&#125; 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172using System;using System.Windows.Forms;using System.Web; namespace LaTeX_Win&#123; public partial class Form1 : Form &#123; private static string PicUrlGoogle = @\"http://chart.apis.google.com/chart?cht=tx&amp;chl=&#123;0&#125;\"; private static string PicUrlCogs = @\"http://latex.codecogs.com/gif.latex?&#123;0&#125;\"; public Form1() &#123; InitializeComponent(); &#125; private void btnPasteText_Click(object sender, EventArgs e) &#123; string content = Clipboard.GetText(); textBox.Text = content; &#125; private void btnPreviewGoogle_Click(object sender, EventArgs e) &#123; if (check()) &#123; string ImgUrl = String.Format(PicUrlGoogle, HttpUtility.UrlPathEncode(textBox.Text)); pictureBox.ImageLocation = ImgUrl; btnCopyImg.Enabled = true; &#125; else btnCopyImg.Enabled = false; &#125; private void btnPreviewCogs_Click(object sender, EventArgs e) &#123; if (check()) &#123; string ImgUrl = String.Format(PicUrlCogs, HttpUtility.UrlPathEncode(textBox.Text)); pictureBox.ImageLocation = ImgUrl; btnCopyImg.Enabled = true; &#125; else btnCopyImg.Enabled = false; &#125; private void btnCopyImg_Click(object sender, EventArgs e) &#123; if(pictureBox.Image != null) Clipboard.SetImage(pictureBox.Image); &#125; private bool check() &#123; if(textBox.Text.Trim() == \"\") &#123; MessageBox.Show(this, \"请填写 LaTeX 函数代码！\"); return false; &#125; return true; &#125; private void btnExit_Click(object sender, EventArgs e) &#123; System.Environment.Exit(0); &#125; private void btnHelp_Click(object sender, EventArgs e) &#123; textBox.Text = \"1、LaTex 公式前后无需 $ 符号；\\r\\n\" + \"2、需要联网，Google丑，Cogs慢；\\r\\n\" + \"3、尽量多使用 &#123;&#125; 将字段括起来；\\r\\n\" + \"4、于 2015年11月13日。\"; &#125; &#125;&#125;","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.duanxu.tech/categories/Other/"}],"tags":[{"name":"LaTeX","slug":"LaTeX","permalink":"http://blog.duanxu.tech/tags/LaTeX/"},{"name":"Math","slug":"Math","permalink":"http://blog.duanxu.tech/tags/Math/"},{"name":"Equation","slug":"Equation","permalink":"http://blog.duanxu.tech/tags/Equation/"},{"name":"C#","slug":"C","permalink":"http://blog.duanxu.tech/tags/C/"}]},{"title":"LaTeX 中插入数学公式","slug":"2016/2016-04-25-LaTeX-MathEquation","date":"2016-04-24T08:18:00.000Z","updated":"2018-12-07T12:33:20.431Z","comments":true,"path":"2016/04/24/2016/2016-04-25-LaTeX-MathEquation/","link":"","permalink":"http://blog.duanxu.tech/2016/04/24/2016/2016-04-25-LaTeX-MathEquation/","excerpt":"","text":"content{:toc} 一、常用的数学符号1、小写希腊字母 小写希腊字母 LaTeX表达式 小写希腊字母 LaTeX表达式 $$ \\alpha $$ \\alpha $$ \\nu $$ \\nu $$ \\beta $$ \\beta $$ \\xi $$ \\xi $$ \\gamma $$ \\gamma $$ o $$ o $$ \\delta $$ \\delta $$ \\pi $$ \\pi $$ \\epsilon $$ \\epsilon $$ \\rho $$ \\rho $$ \\zeta $$ \\zeta $$ \\sigma $$ \\sigma $$ \\eta $$ \\eta $$ \\tau $$ \\tau $$ \\theta $$ \\theta $$ \\upsilon $$ \\upsilon $$ \\iota $$ \\iota $$ \\phi $$ \\phi $$ \\kappa $$ \\kappa $$ \\chi $$ \\chi $$ \\lambda $$ \\lambda $$ \\psi $$ \\psi $$ \\mu $$ \\mu $$ \\omega $$ \\omega 2、大写希腊字母 大写希腊字母 LaTeX表达式 大写希腊字母 LaTeX表达式 $$ \\Gamma $$ \\Gamma $$ \\Lambda $$ \\Lambda $$ \\Sigma $$ \\Sigma $$ \\Psi $$ \\Psi $$ \\Delta $$ \\Delta $$ \\Upsilon $$ \\Upsilon $$ \\Omega $$ \\Omega $$ \\Theta $$ \\Theta $$ \\Xi $$ \\Xi $$ \\Pi $$ \\Pi $$ \\Phi $$ \\Phi 3、运算符 对于加减除，对应键盘上便可打出来，但是对于乘法，键盘上没有这个符号，所以我们应该输入 \\times 来显示一个 $$ \\times $$ 号。 普通字符在数学公式中含义一样，除了 # $ % &amp; ~ _ ^ \\ { } 若要在数学环境中表示这些符号# $ % &amp; _ { }，需要分别表示为# \\$ \\% \\&amp; _ { }，即在个字符前加上\\。 二、简单格式1、上下标 上标：$ f(x) = x^2 $ 或者 $ f(x) = {x}^{2} $ 均可表示 $$ f(x)=x^2 $$。 下标：$ f(x) = x_2 $ 或者 $ f(x) = {x}_{2} $ 均可表示 $$ f(x)=x_2 $$。 上下标可以级联：$ f(x) = x_1^2 + {x}_{2}^{2} $ -&gt; $$ f(x)=x_1^2+{x}_{2}^{2} $$。 2、加粗和倾斜 加粗：$ f(x) = \\textbf{x}^2 $ -&gt; $$ f(x)=\\textbf{x}^2 $$。 文本：$ f(x) = x^2 \\mbox{abcd} $ -&gt; $$ f(x)=x^2\\mbox{abcd}$$。 倾斜：$ f(x) = x^2 \\mbox{\\emph{abcd} defg} $ -&gt; $$ f(x)=x^2\\mbox{\\emph{abcd}defg} $$。 3、分数1$ f(x,y) = \\frac&#123;x^2&#125;&#123;y^3&#125; $ $$ f(x,y)=\\frac{x^2}{y^3} $$ 4、开根号1$ f(x,y) = \\sqrt[n]&#123;x^2 y^3&#125; $ $$ f(x,y)=\\sqrt[n]{x^2y^3} $$ 5、省略号1$ f(x_1, x_2, \\ldots, x_n) = x_1 + x_2 + \\cdots + x_n $ $$ f(x_1,x_2,\\ldots,x_n)=x_1+x_2+\\cdots+x_n $$ 6、括号和分隔符 公式高度比较低的话直接从键盘输入括号即可，但是对于公式高度比较高的情形，需要特殊的运算。 1$ &#123;f&#125;&apos;(x) = (\\frac&#123;df&#125;&#123;dx&#125;) $ $$ {f}’(x)=(\\frac{df}{dx}) $$ 1$ &#123;f&#125;&apos;(x) = \\left( \\frac&#123;df&#125;&#123;dx&#125; \\right) $ $$ {f}’(x)=\\left(\\frac{df}{dx}\\right) $$ 可以看出，通过将 \\left( 和 \\right) 结合使用，可以将括号大小随着其内容变化。[ ] 和 { } 同理。 1$ &#123;f&#125;&apos;(0)=\\left.\\frac&#123;df&#125;&#123;dx&#125;\\right|_&#123;x=0&#125; $ $$ {f}’(0)=\\left.\\frac{df}{dx}\\right|_{x=0} $$ 三、矩阵和行列式1234$ A=\\left[ \\begin&#123;matrix&#125; a &amp; b \\\\ c &amp; d \\\\ \\end&#123;matrix&#125; \\right] $ $$ A=\\left[\\begin{matrix}a&amp;b\\c&amp;d\\\\end{matrix}\\right] $$ 1234$ \\chi (\\lambda)=\\left\\| \\\\begin&#123;matrix&#125; \\lambda - a &amp; -b \\\\ -c &amp; \\lambda - d \\\\ \\end&#123;matrix&#125; \\right| $ $$ \\chi(\\lambda)=\\left|\\begin{matrix}\\lambda-a&amp;-b\\-c&amp;\\lambda-d\\\\end{matrix}\\right| $$ 四、求和与连乘1$ \\sum_&#123;k=1&#125;^n k^2 = \\frac&#123;1&#125;&#123;2&#125; n (n+1) $ $$ \\sum_{k=1}^nk^2=\\frac{1}{2}n(n+1) $$ 1$ \\prod_&#123;k=1&#125;^n k = n! $ $$ \\prod_{k=1}^nk=n! $$ 五、导数、极限、积分1、导数 导数的表示用一对花括号将被导函数括起来，然后加上一个英文的引号即可。 1$ &#123;f&#125;&apos;(x) = x^2 + x $ $$ {f}’(x)=x^2+x $$ 2、极限1$ \\lim_&#123;x \\to 0&#125; \\frac&#123;3x^2 +7x^3&#125;&#123;x^2 +5x^4&#125; = 3 $ $$ \\lim_{x\\to0}\\frac{3x^2+7x^3}{x^2+5x^4}=3 $$ 3、积分 积分中，需要注意的是，在多重积分内 dx 和 dy 之间 使用一个斜杠加一个逗号 \\, 来增大稍许间距。同样，在两个积分号之间使用一个斜杠加一个感叹号 ! 来减小稍许间距。使之更美观。 1$ \\int_a^b f(x)\\,dx $ $$ \\int_a^bf(x)\\,dx $$ 1$ \\int_0^&#123;+\\infty&#125; x^n e^&#123;-x&#125; \\,dx = n! $ $$ \\int_0^{+\\infty}x^ne^{-x}\\,dx=n! $$ 1$ \\int_&#123;x^2 + y^2 \\leq R^2&#125; f(x,y)\\,dx\\,dy = \\int_&#123;\\theta=0&#125;^&#123;2\\pi&#125; \\int_&#123;r=0&#125;^R f(r\\cos\\theta,r\\sin\\theta) r\\,dr\\,d\\theta $ $$ \\int_{x^2 + y^2 \\leq R^2} f(x,y)\\,dx\\,dy = \\int_{\\theta=0}^{2\\pi} \\int_{r=0}^R f(r\\cos\\theta,r\\sin\\theta) r\\,dr\\,d\\theta $$ 12$ \\int \\!\\!\\! \\int_D f(x,y)\\,dx\\,dy \\int \\int_D f(x,y)\\,dx\\,dy $ $$ \\int !!! \\int_D f(x,y)\\,dx\\,dy\\int \\int_D f(x,y)\\,dx\\,dy $$ 在加入了 ! 之后，距离的改变还是很明显的。 12$ i\\hbar\\frac&#123;\\partial \\psi&#125;&#123;\\partial &#123;t&#125;&#125; = \\frac&#123;-\\hbar^2&#125;&#123;2m&#125; \\left( \\frac&#123;\\partial^2&#125;&#123;\\partial x^2&#125; + \\frac&#123;\\partial^2&#125;&#123;\\partial y^2&#125; + \\frac&#123;\\partial^2&#125;&#123;\\partial z^2&#125; \\right) \\psi + V \\psi $ $$ i\\hbar\\frac{\\partial \\psi}{\\partial {t}} = \\frac{-\\hbar^2}{2m} \\left( \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2} + \\frac{\\partial^2}{\\partial z^2} \\right) \\psi + V \\psi $$ 1$ \\frac&#123;d&#125;&#123;dt&#125; \\int \\!\\!\\! \\int \\!\\!\\! \\int_&#123;\\textbf&#123;R&#125;^3&#125; \\left| \\psi(\\mathbf&#123;r&#125;,t) \\right|^2\\,dx\\,dy\\,dz = 0 $ $$ \\frac{d}{dt}\\int!!!\\int!!!\\int_{\\textbf{R}^3}\\left|\\psi(\\mathbf{r},t)\\right|^2\\,dx\\,dy\\,dz=0 $$","categories":[{"name":"Other","slug":"Other","permalink":"http://blog.duanxu.tech/categories/Other/"}],"tags":[{"name":"LaTeX","slug":"LaTeX","permalink":"http://blog.duanxu.tech/tags/LaTeX/"},{"name":"Math","slug":"Math","permalink":"http://blog.duanxu.tech/tags/Math/"},{"name":"Equation","slug":"Equation","permalink":"http://blog.duanxu.tech/tags/Equation/"}]},{"title":"Android开发手记(32) 使用摄像头拍照","slug":"2015/2015-11-22-Android-Study-32-Camera","date":"2015-11-22T14:27:00.000Z","updated":"2018-12-07T12:47:28.988Z","comments":true,"path":"2015/11/22/2015/2015-11-22-Android-Study-32-Camera/","link":"","permalink":"http://blog.duanxu.tech/2015/11/22/2015/2015-11-22-Android-Study-32-Camera/","excerpt":"","text":"content{:toc} 在Android中，使用摄像头拍照一般有两种方法， 一种是调用系统自带的Camera，另一种是自己写一个摄像的界面。 我们要添加如下权限： 12&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt;&lt;uses-permission android:name=\"android.permission.CAMERA\"/&gt; 1、调用系统Camera 调用系统自带的Camera主要的步骤为： （1）构造图片存储的路径名 （2）使用Intent启动Camera Activity （3）将拍摄的图片写入到文件 （4）将图片显示在MainActivity中 首先，构造图片名： 123456789101112File filePath = new File(Environment.getExternalStorageDirectory(), \"myCamera\");if(!filePath.exists())&#123; filePath.mkdirs();&#125;fileName = new File(filePath, System.currentTimeMillis() + \".jpg\");try&#123; if(!fileName.exists())&#123; fileName.createNewFile(); &#125;&#125;catch (Exception e)&#123; e.printStackTrace();&#125; 然后，启动Camera Activity： 123456// intent用来启动系统自带的Camera Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);// 将系统Camera的拍摄结果写入到文件 intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(fileName));// 启动intent对应的Activity，返回默认消息 startActivityForResult(intent, Activity.DEFAULT_KEYS_DIALER); 最后，将图片显示在MainActivity内。这时，我们通过重载onActivityResult()方法来获取Camera返回的消息。 1234567@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data)&#123; if(requestCode == Activity.DEFAULT_KEYS_DIALER)&#123; // MainActivity接收Camera返回的消息，然后将已经写入的图片显示在ImageView内 imageView.setImageURI(Uri.fromFile(fileName)); &#125;&#125; 完整代码为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import android.app.Activity;import android.content.Intent;import android.net.Uri;import android.os.Bundle;import android.os.Environment;import android.provider.MediaStore;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.ImageView; import java.io.File; public class MainActivity extends Activity &#123; private File fileName = null; private Button button; private ImageView imageView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button)findViewById(R.id.button); imageView = (ImageView)findViewById(R.id.imageView); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; File filePath = new File(Environment.getExternalStorageDirectory(), \"myCamera\"); if(!filePath.exists())&#123; filePath.mkdirs(); &#125; fileName = new File(filePath, System.currentTimeMillis() + \".jpg\"); try&#123; if(!fileName.exists())&#123; fileName.createNewFile(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; // intent用来启动系统自带的Camera Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); // 将系统Camera的拍摄结果写入到文件 intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(fileName)); // 启动intent对应的Activity，返回默认消息 startActivityForResult(intent, Activity.DEFAULT_KEYS_DIALER); &#125; &#125;); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data)&#123; if(requestCode == Activity.DEFAULT_KEYS_DIALER)&#123; // MainActivity接收Camera返回的消息，然后将已经写入的图片显示在ImageView内 imageView.setImageURI(Uri.fromFile(fileName)); &#125; &#125; &#125; 2、自己写一个摄像界面 自己写摄像的界面，主要应用了SurfaceView来显示摄像机的画面。然后通过一个Button来保存当前的画面。 同样的，我们需要添加camera和SDCard权限： 12&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt;&lt;uses-permission android:name=\"android.permission.CAMERA\"/&gt; 首先，我们初始化这个SurfaceView，为这个SurfaceView添加一个对应的Callback即可： 1234567891011121314151617181920private SurfaceView surfaceView;private SurfaceHolder.Callback callback;surfaceView = (SurfaceView)findViewById(R.id.surfaceView);callback = new SurfaceHolder.Callback()&#123; @Override public void surfaceCreated(SurfaceHolder holder) &#123; startCamera(); // 用于启动摄像头 &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; stopCamera(); // 用于关闭摄像头 &#125;&#125;;surfaceView.getHolder().addCallback(callback); // 将Callback绑定到SurfaceView 在启动摄像头的时候，首先打开摄像头连接，然后将其图像输出到SurfaceView上，然后启动摄像头预览即可在SurfaceView上显示摄像头的画面，这里的画面和实际画面相差有90度，所以我们需要将图像旋转90度之后才可以和拍摄的物体方向一致。 在关闭摄像头时，只要停止预览，然后释放摄像头资源即可。 12345678910111213141516public void startCamera()&#123; camera = Camera.open(); try &#123; camera.setPreviewDisplay(surfaceView.getHolder()); camera.setDisplayOrientation(90); camera.startPreview(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; public void stopCamera()&#123; camera.stopPreview(); camera.release(); camera = null;&#125; 最后，是将拍摄到的图片保存到SDCard，我们单击Button来拍摄图片，调用Camera.takePicture()方法，其原型为： /** * Equivalent to takePicture(shutter, raw, null, jpeg). * * @see #takePicture(ShutterCallback, PictureCallback, PictureCallback, PictureCallback) */ public final void takePicture(ShutterCallback shutter, PictureCallback raw, PictureCallback jpeg) { takePicture(shutter, raw, null, jpeg); } 其中，shutter为按快门瞬间的回调，就是说按快门瞬间会调用ShutterCallback.onShutter()方法。raw是未压缩的图像的回调，即处理图像原始数据的时候会调用PictureCallback.onPictureTaken()方法。jpeg为处理JPEG图片时候的回调，即我们需要将图像数据按照jpg格式保存的时候会调用这个方法，PictureCallback.onPIctureTaken()。这里我们就调用了这个方法，从而将jpg图片存储到SDCard上。 12345678910111213141516171819202122232425button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; camera.takePicture(null, null, new Camera.PictureCallback() &#123; @Override public void onPictureTaken(byte[] data, Camera camera) &#123; try &#123; File filePath = new File(Environment.getExternalStorageDirectory(), \"myCamera\"); if(!filePath.exists()) &#123; filePath.mkdirs(); &#125; File fileName = new File(filePath, System.currentTimeMillis() + \".jpg\"); fileName.createNewFile(); FileOutputStream fos = new FileOutputStream(fileName); fos.write(data); fos.flush(); fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125;); 这样，我们便实现了用SurfaceView预览摄像头画面，点击Button将当前预览保存到SDCard中。 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import android.app.Activity;import android.hardware.Camera;import android.os.Bundle;import android.os.Environment;import android.view.SurfaceHolder;import android.view.SurfaceView;import android.view.View;import android.widget.Button; import java.io.File;import java.io.FileOutputStream;import java.io.IOException; public class MainActivity extends Activity &#123; private Camera camera; private Button button; private SurfaceView surfaceView; private SurfaceHolder.Callback callback; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button)findViewById(R.id.button); surfaceView = (SurfaceView)findViewById(R.id.surfaceView); callback = new SurfaceHolder.Callback()&#123; @Override public void surfaceCreated(SurfaceHolder holder) &#123; startCamera(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; stopCamera(); &#125; &#125;; surfaceView.getHolder().addCallback(callback); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; camera.takePicture(null, null, new Camera.PictureCallback() &#123; @Override public void onPictureTaken(byte[] data, Camera camera) &#123; try &#123; File filePath = new File(Environment.getExternalStorageDirectory(), \"myCamera\"); if(!filePath.exists()) &#123; filePath.mkdirs(); &#125; File fileName = new File(filePath, System.currentTimeMillis() + \".jpg\"); fileName.createNewFile(); FileOutputStream fos = new FileOutputStream(fileName); fos.write(data); fos.flush(); fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125;); &#125; public void startCamera()&#123; camera = Camera.open(); try &#123; camera.setPreviewDisplay(surfaceView.getHolder()); camera.setDisplayOrientation(90); camera.startPreview(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public void stopCamera()&#123; camera.stopPreview(); camera.release(); camera = null; &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"Camera","slug":"Camera","permalink":"http://blog.duanxu.tech/tags/Camera/"}]},{"title":"Android开发手记(31) 使用MediaRecorder录音","slug":"2015/2015-11-22-Android-Study-31-MediaRecorder","date":"2015-11-22T11:57:00.000Z","updated":"2018-12-07T12:47:10.146Z","comments":true,"path":"2015/11/22/2015/2015-11-22-Android-Study-31-MediaRecorder/","link":"","permalink":"http://blog.duanxu.tech/2015/11/22/2015/2015-11-22-Android-Study-31-MediaRecorder/","excerpt":"","text":"content{:toc} 使用Android手机的时候，有时我们会用到录音功能，本文简单的介绍了如何使用MediaRecorder通过手机自带麦克风进行录音。 首先，既然是录音，我们需要录音和写外存的权限： 12&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt;&lt;uses-permission android:name=\"android.permission.RECORD_AUDIO\"/&gt; 然后，我们创建一个录音的方法startRecord()，当我们单击录音按钮时调用这个方法来进行录音。录音的过程为： （1）确定录音的文件的存放位置 （2）实例化一个MediaRecorder对象，并设置其参数 （3）调用MediaRecorder.prepare()准备录音 （4）调用MediaRecorder.start()开始录音 123456789101112131415161718192021222324252627282930public void startRecord()&#123; if(mr == null)&#123; File filePath = new File(Environment.getExternalStorageDirectory(), \"myRecord\"); File fileName = new File(filePath, System.currentTimeMillis() + \".amr\"); try &#123; if (!filePath.exists()) &#123; filePath.mkdirs(); &#125; if (!fileName.exists()) &#123; fileName.createNewFile(); &#125; &#125; catch(IOException e)&#123; e.printStackTrace(); &#125; mr = new MediaRecorder(); mr.setAudioSource(MediaRecorder.AudioSource.MIC); // 设置录音的输入源 mr.setOutputFormat(MediaRecorder.OutputFormat.AMR_WB); // 设置输出格式 mr.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_WB); // 设置编码格式 mr.setOutputFile(fileName.getAbsolutePath()); // 设置输出文件名 try&#123; mr.prepare(); mr.start(); textView.setText(\"文件名：\"+fileName.getAbsolutePath()); &#125; catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 然后我们创建一个方法stopRecord()来停止录音，调用MediaRecorder.stop()可以停止录音，调用MediaRecorder.release()释放录音对象。然后将MediaRecorder指针置空以便下一次录音可以实例化新的MediaRecorder对象。 1234567public void stopRecord()&#123; if(mr != null)&#123; mr.stop(); mr.release(); mr = null; &#125;&#125; 最后，在MainActivity中为按钮添加单击事件，并调用上述方法即可实现录音。完整代码如下： activity_main.xml1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.doodle.myapplication\"&gt; &lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt; &lt;uses-permission android:name=\"android.permission.RECORD_AUDIO\"/&gt; &lt;/manifest&gt; MainActivity.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import android.app.Activity;import android.media.MediaRecorder;import android.os.Bundle;import android.os.Environment;import android.view.View;import android.widget.Button;import android.widget.TextView; import java.io.File;import java.io.IOException; public class MainActivity extends Activity &#123; private Button button; private TextView textView; private boolean isStart = false; private MediaRecorder mr = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button)findViewById(R.id.button); textView = (TextView)findViewById(R.id.textView); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if(isStart)&#123; startRecord(); button.setText(\"停止录音\"); isStart = false; &#125; else &#123; stopRecord(); button.setText(\"开始录音\"); isStart = true; &#125; &#125; &#125;); &#125; public void startRecord()&#123; if(mr == null)&#123; File filePath = new File(Environment.getExternalStorageDirectory(), \"myRecord\"); File fileName = new File(filePath, System.currentTimeMillis() + \".amr\"); try &#123; if (!filePath.exists()) &#123; filePath.mkdirs(); &#125; if (!fileName.exists()) &#123; fileName.createNewFile(); &#125; &#125; catch(IOException e)&#123; e.printStackTrace(); &#125; mr = new MediaRecorder(); mr.setAudioSource(MediaRecorder.AudioSource.MIC); // 设置录音的输入源 mr.setOutputFormat(MediaRecorder.OutputFormat.AMR_WB); // 设置输出格式 mr.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_WB); // 设置编码格式 mr.setOutputFile(fileName.getAbsolutePath()); // 设置输出文件名 try&#123; mr.prepare(); mr.start(); textView.setText(\"文件名：\"+fileName.getAbsolutePath()); &#125; catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; public void stopRecord()&#123; if(mr != null)&#123; mr.stop(); mr.release(); mr = null; &#125; &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"MediaRecorder","slug":"MediaRecorder","permalink":"http://blog.duanxu.tech/tags/MediaRecorder/"}]},{"title":"Android开发手记(30) 触摸及手势操作","slug":"2015/2015-11-20-Android-Study-30-Touch-and-Gesture","date":"2015-11-20T13:22:00.000Z","updated":"2018-12-07T12:46:46.655Z","comments":true,"path":"2015/11/20/2015/2015-11-20-Android-Study-30-Touch-and-Gesture/","link":"","permalink":"http://blog.duanxu.tech/2015/11/20/2015/2015-11-20-Android-Study-30-Touch-and-Gesture/","excerpt":"","text":"content{:toc} 触摸操作在现在智能手机系统中起到举足轻重的作用，本文将对安卓中的触摸以及一些简单手势的操作进行简单的介绍。 1、触摸 首先是关于触摸的判断，有两种方法可以判断的触摸操作。 （1.1）setOnTouchListener 对于View类，我们可以为View添加setOnTouchListener来获取触摸事件。我们以TextView为例，由于TextView继承自View，所以我们可以为其添加一个触摸监听。然后将触摸事件交给OnTouchListener处理。比如，我们在触摸TextView时改变这个TextView的文字。 1234567891011121314textView.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; int action = MotionEventCompat.getActionMasked(event); switch (action)&#123; case MotionEvent.ACTION_DOWN : textView.setText(\"TextAction: DOWN\"); return true; case MotionEvent.ACTION_UP : textView.setText(\"TextAction UP\"); return true; default: return false; &#125; &#125;&#125;); 其中，我们通过getActionMasked(MotionEvent event)取得触摸事件的类型ID，然后对其分别判断。当然，还有一些其他的事件： 1234567public static final int ACTION_DOWN = 0; //单点触摸动作public static final int ACTION_UP = 1; //单点触摸离开动作public static final int ACTION_MOVE = 2; //触摸点移动动作public static final int ACTION_CANCEL = 3; //触摸动作取消public static final int ACTION_OUTSIDE = 4; //触摸动作超出边界public static final int ACTION_POINTER_DOWN = 5; //多点触摸动作public static final int ACTION_POINTER_UP = 6; //多点离开动作 （1.2）onTouchEvent 对于Activity，我们可以通过重载onTouch方法来获取触摸事件。我们这里通过触摸MainActivity然后通过一个TextView来显示触摸的信息。 12345678910111213@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; int action = MotionEventCompat.getActionMasked(event); switch (action)&#123; case MotionEvent.ACTION_DOWN : textView.setText(\"MainAction: DOWN\"); return true; case MotionEvent.ACTION_UP : textView.setText(\"MainAction UP\"); return true; default: return super.onTouchEvent(event); &#125;&#125; 完整代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import android.app.Activity;import android.os.Bundle;import android.support.v4.view.MotionEventCompat;import android.view.MotionEvent;import android.view.View;import android.widget.TextView; public class MainActivity extends Activity &#123; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView)findViewById(R.id.textView); textView.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; int action = MotionEventCompat.getActionMasked(event); switch (action) &#123; case MotionEvent.ACTION_DOWN: textView.setText(\"TextAction: DOWN\"); return true; case MotionEvent.ACTION_UP: textView.setText(\"TextAction UP\"); return true; default: return false; &#125; &#125; &#125;); &#125; @Override public boolean onTouchEvent(MotionEvent event)&#123; int action = MotionEventCompat.getActionMasked(event); switch (action)&#123; case MotionEvent.ACTION_DOWN : textView.setText(\"MainAction: DOWN\"); return true; case MotionEvent.ACTION_UP : textView.setText(\"MainAction UP\"); return true; default: return super.onTouchEvent(event); &#125; &#125; &#125; 2、手势识别 Android提供的onTouch方法只能处理一些简单的触摸操作比如触摸、离开、移动之类的，但是当我们处理一些复杂的手势时，这样判断就会很复杂，比如长按操作。好在Android SDK提供了另外的一些方法来处理手势的操作：GestureDetector。GestureDetector类对外提供了两个接口：OnGestureListener，OnDoubleTapListener，还有一个内部类SimpleOnGestureListener；SimpleOnGestureListener类是GestureDetector提供给我们的一个更方便的响应不同手势的类，它实现了上述两个接口，该类是static class，也就是说它实际上是一个外部类，我们可以在外部继承这个类，重写里面的手势处理方法。 使用GestureDetector，具体过程为，首先实现GestureDetector接口，然后实例化一个这个类对象，最后对Activity添加onTouchEvent处理方法即可。 （2.1）OnGestureListener 首先我们需要新建一个MyGesture类来实现GestureDetector的接口，这里我们需要注意的是我们必须实现所有提供的接口： 按下（onDown）： 刚刚手指接触到触摸屏的那一刹那，就是触的那一下。 提拉（onFling）： 手指在触摸屏上迅速移动，并松开的动作。 长按（onLongPress）： 手指按在持续一段时间，并且没有松开。 滚动（onScroll）： 手指在触摸屏上滑动。 按住（onShowPress）： 手指按在触摸屏上，它的时间范围在按下起效，在长按之前。 抬起（onSingleTapUp）：手指离开触摸屏的那一刹那。 1234567891011121314151617181920212223242526272829303132333435363738class MyGesture implements GestureDetector.OnGestureListener&#123; @Override public boolean onDown(MotionEvent event) &#123; textView.setText(\"onDown: \" + event.toString()); return true; &#125; @Override public boolean onFling(MotionEvent event1, MotionEvent event2, float velocityX, float velocityY) &#123; textView.setText(\"onFling: \" + event1.toString() + event2.toString()); return true; &#125; @Override public void onLongPress(MotionEvent event) &#123; textView.setText(\"onLongPress: \" + event.toString()); &#125; @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; textView.setText(\"onScroll: \" + e1.toString() + e2.toString()); return true; &#125; @Override public void onShowPress(MotionEvent event) &#123; textView.setText(\"onShowPress: \" + event.toString()); &#125; @Override public boolean onSingleTapUp(MotionEvent event) &#123; textView.setText(\"onSingleTapUp: \" + event.toString()); return true; &#125; &#125; 然后在MainActivity的onCreate方法内实例化这个类； 1gestureDetector = new GestureDetector(MainActivity.this, new MyGesture()); 最后，根据我们实例化的对象为MainActivity添加时间处理方法： 1234567@Overridepublic boolean onTouchEvent(MotionEvent event)&#123; gestureDetector.onTouchEvent(event); return super.onTouchEvent(event);&#125; 完整的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import android.app.Activity;import android.os.Bundle;import android.view.GestureDetector;import android.view.MotionEvent;import android.widget.TextView; public class MainActivity extends Activity &#123; private TextView textView; private GestureDetector gestureDetector; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView)findViewById(R.id.textView); gestureDetector = new GestureDetector(MainActivity.this, new MyGesture()); &#125; @Override public boolean onTouchEvent(MotionEvent event)&#123; gestureDetector.onTouchEvent(event); return super.onTouchEvent(event); &#125; class MyGesture implements GestureDetector.OnGestureListener&#123; @Override public boolean onDown(MotionEvent event) &#123; textView.setText(\"onDown: \" + event.toString()); return true; &#125; @Override public boolean onFling(MotionEvent event1, MotionEvent event2, float velocityX, float velocityY) &#123; textView.setText(\"onFling: \" + event1.toString() + event2.toString()); return true; &#125; @Override public void onLongPress(MotionEvent event) &#123; textView.setText(\"onLongPress: \" + event.toString()); &#125; @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; textView.setText(\"onScroll: \" + e1.toString() + e2.toString()); return true; &#125; @Override public void onShowPress(MotionEvent event) &#123; textView.setText(\"onShowPress: \" + event.toString()); &#125; @Override public boolean onSingleTapUp(MotionEvent event) &#123; textView.setText(\"onSingleTapUp: \" + event.toString()); return true; &#125; &#125;&#125; （2.2）SimpleOnGestureListener 从上文可以看出，我们在使用OnGestureListener的时候，需要重载一些我们用不到的方法，好在Android也为我们考虑到了这种不便，所以为我们提供了一个SimpleOnGestureListener类来方便的实现我们需要的手势。 这里我们只需要继承一下SimpleOnGestureListener类即可： 123456789class MyGesture extends GestureDetector.SimpleOnGestureListener&#123; @Override public boolean onDown(MotionEvent event) &#123; textView.setText(\"onDown: \" + event.toString()); return true; &#125; //...其他实现方法&#125; 完整的代码入下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import android.app.Activity;import android.os.Bundle;import android.view.GestureDetector;import android.view.MotionEvent;import android.widget.TextView; public class MainActivity extends Activity &#123; private TextView textView; private GestureDetector gestureDetector; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView)findViewById(R.id.textView); gestureDetector = new GestureDetector(MainActivity.this, new MyGesture()); &#125; @Override public boolean onTouchEvent(MotionEvent event)&#123; gestureDetector.onTouchEvent(event); return super.onTouchEvent(event); &#125; class MyGesture extends GestureDetector.SimpleOnGestureListener&#123; @Override public boolean onDown(MotionEvent event) &#123; textView.setText(\"onDown: \" + event.toString()); return true; &#125; @Override public boolean onFling(MotionEvent event1, MotionEvent event2, float velocityX, float velocityY) &#123; textView.setText(\"onFling: \" + event1.toString() + event2.toString()); return true; &#125; @Override public void onLongPress(MotionEvent event) &#123; textView.setText(\"onLongPress: \" + event.toString()); &#125; @Override public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; textView.setText(\"onScroll: \" + e1.toString() + e2.toString()); return true; &#125; @Override public void onShowPress(MotionEvent event) &#123; textView.setText(\"onShowPress: \" + event.toString()); &#125; @Override public boolean onSingleTapUp(MotionEvent event) &#123; textView.setText(\"onSingleTapUp: \" + event.toString()); return true; &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"Touch","slug":"Touch","permalink":"http://blog.duanxu.tech/tags/Touch/"},{"name":"Gesture","slug":"Gesture","permalink":"http://blog.duanxu.tech/tags/Gesture/"}]},{"title":"Android开发手记(29) 基于Http的LaTeX数学公式转换器","slug":"2015/2015-11-17-Android-Study-29-Http-Latex","date":"2015-11-17T14:30:00.000Z","updated":"2018-12-07T12:46:34.053Z","comments":true,"path":"2015/11/17/2015/2015-11-17-Android-Study-29-Http-Latex/","link":"","permalink":"http://blog.duanxu.tech/2015/11/17/2015/2015-11-17-Android-Study-29-Http-Latex/","excerpt":"","text":"content{:toc} 本文将讲解如何通过codecogs.com和Google.com提供的API接口来将LaTeX数学函数表达式转化为图片形式。具体思路如下： （1）通过EditText获取用户输入的LaTeX数学表达式，然后对表达式格式化使之便于网络传输。 （2）将格式化之后的字符串，通过Http请求发送至codecogs.com或者Google.com。 （3）获取网站返回的数据流，将其转化为图片，并显示在ImageView上。 具体过程为： 1、获取并格式化LaTeX数学表达式 首先，我们在这个网站输入LaTeX数学公式然后返回图片时，即“http://latex.codecogs.com/gif.latex?“后面跟上我们输入的公式内容。比如”http://latex.codecogs.com/gif.latex?\\alpha”就显示一个希腊字母$$\\alpha$$。所以我们可以在其后加上我们希望转换的公式即可。但是需要注意的是，网络URL中的空格有时候会自动转化为加号”+“。所以，我们在传输的时候需要将空格去掉。或者将其转换为”%20“。Button单击时执行。 首先要添加网络访问权限：1&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; 123456String PicUrlCogs = \"http://latex.codecogs.com/gif.latex?\";Url = new URL(PicUrlCogs + editText.getText().toString().replace(\" \",\"\"));new MyDownloadTask().execute(); // 执行Http请求while(!finishFlag) &#123;&#125; // 等待数据接收完毕imageView.setImageBitmap(pngBM); // 显示图片finishFlag = false; // 标识回位 2、发送Http请求 这里，我们发送Http请求采取异步线程的方式。首先，获取上一步得到的URL地址，然后建立一个Http链接，然后将返回的数据输入到输入流中，最后将输入流进行解码为图片并显示在ImageView中。 123456789101112131415161718 protected Void doInBackground(Void... params) &#123; try &#123; URL picUrl = Url; // 获取URL地址 HttpURLConnection conn = (HttpURLConnection) picUrl.openConnection();// conn.setConnectTimeout(1000); // 建立连接// conn.setReadTimeout(1000); conn.connect(); // 打开连接 if (conn.getResponseCode() == 200) &#123; // 连接成功，返回数据 InputStream ins = conn.getInputStream(); // 将数据输入到数据流中 pngBM = BitmapFactory.decodeStream(picUrl.openStream()); // 解析数据流 finishFlag = true; // 数据传输完毕标识 ins.close(); // 关闭数据流 &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; 完整的MyDownloadTask类代码（在MainActivity内）： 123456789101112131415161718192021222324252627282930class MyDownloadTask extends AsyncTask&lt;Void, Void, Void&gt; &#123; protected void onPreExecute() &#123; //display progress dialog. &#125; protected Void doInBackground(Void... params) &#123; try &#123; URL picUrl = Url; // 获取URL地址 HttpURLConnection conn = (HttpURLConnection) picUrl.openConnection();// conn.setConnectTimeout(1000); // 建立连接// conn.setReadTimeout(1000); conn.connect(); // 打开连接 if (conn.getResponseCode() == 200) &#123; // 连接成功，返回数据 InputStream ins = conn.getInputStream(); // 将数据输入到数据流中 pngBM = BitmapFactory.decodeStream(picUrl.openStream()); // 解析数据流 finishFlag = true; // 数据传输完毕标识 ins.close(); // 关闭数据流 &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; protected void onPostExecute(Void result) &#123; // dismiss progress dialog and update ui &#125; &#125; 3、显示图片 在上一步建立的网络连接类，然后在Button单击事件内实例化一个此类来接收数据，然后将返回的数据显示在ImageView内。 12345678910111213141516 btnPreview.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; try &#123; Url = new URL(PicUrlCogs + editText.getText().toString().replace(\" \",\"\")); // 转换字符串 new MyDownloadTask().execute(); // 执行Http请求 while(!finishFlag) &#123;&#125; // 等待数据接收完毕 imageView.setImageBitmap(pngBM); // 显示图片 finishFlag = false; // 标识回位 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;); 这样，我们在输入LaTeX公式之后，单击PREVIEW按钮，就会在ImageView上显示对应的图片了。由于本文只讨论如何进行转化，并没有对图片进行任何优化处理，可能看起来比较小。另外，如果采取去空格转化URL的方法，尽量保证LaTeX表达式是严格合法的（比如所有单元都用{}括起来）。 完整代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import android.app.Activity;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.AsyncTask;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.ImageView; import java.io.InputStream;import java.net.HttpURLConnection;import java.net.URL; public class MainActivity extends Activity &#123; private String PicUrlGoogle = \"http://chart.apis.google.com/chart?cht=tx&amp;chl=\"; private String PicUrlCogs = \"http://latex.codecogs.com/gif.latex?\"; private Button btnPreview; private EditText editText; private ImageView imageView; private Bitmap pngBM; private URL Url; private boolean finishFlag = false; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btnPreview = (Button) findViewById(R.id.btnPreview); imageView = (ImageView) findViewById(R.id.imageView); editText = (EditText) findViewById(R.id.editText); btnPreview.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; try &#123; Url = new URL(PicUrlCogs + editText.getText().toString().replace(\" \",\"\")); // 转换字符串 new MyDownloadTask().execute(); // 执行Http请求 while(!finishFlag) &#123;&#125; // 等待数据接收完毕 imageView.setImageBitmap(pngBM); // 显示图片 finishFlag = false; // 标识回位 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125; class MyDownloadTask extends AsyncTask&lt;Void, Void, Void&gt; &#123; protected void onPreExecute() &#123; //display progress dialog. &#125; protected Void doInBackground(Void... params) &#123; try &#123; URL picUrl = Url; // 获取URL地址 HttpURLConnection conn = (HttpURLConnection) picUrl.openConnection();// conn.setConnectTimeout(1000); // 建立连接// conn.setReadTimeout(1000); conn.connect(); // 打开连接 if (conn.getResponseCode() == 200) &#123; // 连接成功，返回数据 InputStream ins = conn.getInputStream(); // 将数据输入到数据流中 pngBM = BitmapFactory.decodeStream(picUrl.openStream()); // 解析数据流 finishFlag = true; // 数据传输完毕标识 ins.close(); // 关闭数据流 &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; protected void onPostExecute(Void result) &#123; // dismiss progress dialog and update ui &#125; &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"Http","slug":"Http","permalink":"http://blog.duanxu.tech/tags/Http/"},{"name":"Latex","slug":"Latex","permalink":"http://blog.duanxu.tech/tags/Latex/"}]},{"title":"Android开发手记(28) Handler和Looper","slug":"2015/2015-11-17-Android-Study-28-Handler-and-Looper","date":"2015-11-17T02:11:00.000Z","updated":"2018-12-07T12:46:19.244Z","comments":true,"path":"2015/11/17/2015/2015-11-17-Android-Study-28-Handler-and-Looper/","link":"","permalink":"http://blog.duanxu.tech/2015/11/17/2015/2015-11-17-Android-Study-28-Handler-and-Looper/","excerpt":"","text":"content{:toc} Android的消息处理有三个核心类：Looper,Handler和Message。其实还有一个Message Queue（消息队列），但是MQ被封装到Looper里面了，我们不会直接与MQ打交道。平时我们最常使用的就是Message与Handler了，如果使用过HandlerThread或者自己实现类似HandlerThread的东西可能还会接触到Looper，而MessageQueue是Looper内部使用的，对于标准的SDK，我们是无法实例化并使用的（构造函数是包可见性）。 在Android中，消息处理的大体过程为： （1）首先，要有消息的内容，我们将其放到一个Bundle中来存储消息的内容。 （2）然后通过此Bundle来实例化一个Message，并将此Message作为消息发送的基本单位。 （3）之后可以将Message放到Looper中用以循环处理消息。 （4）由于Handler内部拥有Looper实例，所以可以直接通过Handler发送和处理上述的Message。 以上就是Android中消息发送和处理的基本过程。 以下1、2部分引自博客园 1、Looper Looper的字面意思是“循环者”，它被设计用来使一个普通线程变成Looper线程。所谓Looper线程就是循环工作的线程。在程序开发中（尤其是GUI开发中），我们经常会需要一个线程不断循环，一旦有新任务则执行，执行完继续等待下一个任务，这就是Looper线程。使用Looper类创建Looper线程很简单： 123456789101112public class LooperThread extends Thread &#123; @Override public void run() &#123; // 将当前线程初始化为Looper线程 Looper.prepare(); // ...其他处理，如实例化handler // 开始循环处理消息队列 Looper.loop(); &#125;&#125; 通过上面两行核心代码，你的线程就升级为Looper线程了！！！是不是很神奇？让我们放慢镜头，看看这两行代码各自做了什么。 1) Looper.prepare() 通过上图可以看到，现在你的线程中有一个Looper对象，它的内部维护了一个消息队列MQ。注意，一个Thread只能有一个Looper对象。 2）Looper.loop() 调用loop方法后，Looper线程就开始真正工作了，它不断从自己的MQ中取出队头的消息(也叫任务)执行。由上loop()方法可以简单得出结论，Looper用以处理MessageQueue中的取出的Message，由MessageQueue是Handler及Looper所共用的，取出的Message则交由Handler进行处理。而Handler也能够通过post或者send等方式将Message添加到MessageQueue中供Looper后续进行取出处理。sThreadLocal保证了Looper是线程私有的，所有信息发送与处理都是在本线程中。 prepare()用以在sThreadLocal中创建线程与该线程对应的Looper的键值对；new Handler或者getHandler创建的Handler都根据sThreadLocal.get()进行获取；创建的Handler与Looper共用MessageQueue;loop开始循环处理Messagequeue中的事件。其即为整个流程。 2、Handler handler扮演了往MQ上添加消息和处理消息的角色（只处理由自己发出的消息），即通知MQ它要执行一个任务(sendMessage)，并在loop到自己的时候执行该任务(handleMessage)，整个过程是异步的。handler创建时会关联一个looper，默认的构造方法将关联当前线程的looper，不过这也是可以set的。加入handler后的效果如下图： 可以看到，一个线程可以有多个Handler，但是只能有一个Looper！ 3、使用Handler发送和处理消息 根据本文开始提到的，我们来实现通过Handler发送消息，然后改变MainActivity内一个TextView的颜色和内容。规定 flag == false 时为红色，arg1 = 0；flag == true 时为蓝色，arg1 = 1。 我们需要明白，Handler是通过一个进程来发送消息的，所以我们需要将发送消息的过程写到Runnable.run()方法内。首先我们新建一个SendMessage implements Runnable 类，然后我们构造消息： 12345678910111213141516171819202122232425@Overridepublic void run()&#123; while(true) &#123; try &#123; Thread.sleep(1000); // 每个1秒启动一次消息发送 Bundle bundle = new Bundle(); // Bundle 用于存储消息内容 Message msg = Message.obtain(); // 实例化一个空消息 if (flag) &#123; // 如果flag为真，说明当前颜色为蓝色 msg.arg1 = 0; // 颜色应变为红色，记录信息用于发送 flag = false; // 假设当前已经变为红色 bundle.putString(\"text\", \"我的颜色是红色\"); &#125; else &#123; // 如果flag为假，说明当前颜色为红色 msg.arg1 = 1; // 颜色应变为蓝色，记录信息用于发送 flag = true; // 假设当前已经变为蓝色 bundle.putString(\"text\", \"我的颜色是蓝色\"); &#125; count++; // 记录颜色变化的次数 msg.arg2 = count; // 存储颜色变化的次数用以发送 msg.setData(bundle); // 将Bundle封装至待发送的消息 handler.sendMessage(msg); // 通过handler发送消息 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这里需要注意的是，我们在通过bundle发送消息的时候，发送到什么地方了呢？这里我们需要在MainActivity内实例化一个Handler来处理发送的消息，并同时用此Handler来构造SendMessage。 1234567891011121314151617181920212223class SendMessage implements Runnable&#123; private Handler handler; static boolean flag = false; static int count = 0; public SendMessage(Handler handler)&#123; this.handler = handler; &#125; @Override public void run()&#123; while(true) &#123; try &#123; Thread.sleep(1000); // 每个1秒启动一次消息发送 /* ----------------------------------------- */ handler.sendMessage(msg); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 下面就是在MainActivity内进行消息处理，我们继承Handler来新建一个自己的消息处理器。通过Message.getData().getString(String keyValue)来获取我们上一步中封装到Message内的Bundle信息。通过判断传入Message的arg1和arg2的简单int类型，来判断需要改变的颜色。（如果待发送的消息比较简单的话，可以直接封装到Message的arg1或者arg2内，就不必再使用Bundle来发送消息了）。 1234567891011class MyHandler extends Handler&#123; @Override public void handleMessage(Message msg)&#123; textView.setText(msg.getData().getString(\"text\") + msg.arg2); if(msg.arg1 == 1) textView.setTextColor(Color.BLUE); else textView.setTextColor(Color.RED); &#125; &#125; 最后，为Button添加单击事件，来启动SendMessage线程即可。 1234567891011121314151617181920212223242526272829303132333435public class MainActivity extends Activity &#123; private Button button; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button)findViewById(R.id.button); textView = (TextView)findViewById(R.id.textView); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Thread thread = new Thread(new SendMessage(new MyHandler())); thread.start(); &#125; &#125;); &#125; class MyHandler extends Handler&#123; @Override public void handleMessage(Message msg)&#123; textView.setText(msg.getData().getString(\"text\") + msg.arg2); if(msg.arg1 == 1) textView.setTextColor(Color.BLUE); else textView.setTextColor(Color.RED); &#125; &#125; &#125; 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import android.app.Activity;import android.graphics.Color;import android.os.Bundle;import android.os.Message;import android.os.Handler;import android.view.View;import android.widget.Button;import android.widget.TextView; public class MainActivity extends Activity &#123; private Button button; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button)findViewById(R.id.button); textView = (TextView)findViewById(R.id.textView); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Thread thread = new Thread(new SendMessage(new MyHandler())); thread.start(); &#125; &#125;); &#125; class MyHandler extends Handler&#123; @Override public void handleMessage(Message msg)&#123; textView.setText(msg.getData().getString(\"text\") + msg.arg2); if(msg.arg1 == 1) textView.setTextColor(Color.BLUE); else textView.setTextColor(Color.RED); &#125; &#125; &#125; class SendMessage implements Runnable&#123; private Handler handler; static boolean flag = false; static int count = 0; public SendMessage(Handler handler)&#123; this.handler = handler; &#125; @Override public void run()&#123; while(true) &#123; try &#123; Thread.sleep(1000); // 每个1秒启动一次消息发送 Bundle bundle = new Bundle(); // Bundle 用于存储消息内容 Message msg = Message.obtain(); // 实例化一个空消息 if (flag) &#123; // 如果flag为真，说明当前颜色为蓝色 msg.arg1 = 0; // 颜色应变为红色，记录信息用于发送 flag = false; // 假设当前已经变为红色 bundle.putString(\"text\", \"我的颜色是红色\"); &#125; else &#123; // 如果flag为假，说明当前颜色为红色 msg.arg1 = 1; // 颜色应变为蓝色，记录信息用于发送 flag = true; // 假设当前已经变为蓝色 bundle.putString(\"text\", \"我的颜色是蓝色\"); &#125; count++; // 记录颜色变化的次数 msg.arg2 = count; // 存储颜色变化的次数用以发送 msg.setData(bundle); // 将Bundle封装至待发送的消息 handler.sendMessage(msg); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"Handler","slug":"Handler","permalink":"http://blog.duanxu.tech/tags/Handler/"},{"name":"Looper","slug":"Looper","permalink":"http://blog.duanxu.tech/tags/Looper/"}]},{"title":"Android开发手记(27) Java多线程的操作","slug":"2015/2015-11-15-Android-Study-27-Thread","date":"2015-11-15T08:23:00.000Z","updated":"2018-12-07T12:46:15.650Z","comments":true,"path":"2015/11/15/2015/2015-11-15-Android-Study-27-Thread/","link":"","permalink":"http://blog.duanxu.tech/2015/11/15/2015/2015-11-15-Android-Study-27-Thread/","excerpt":"","text":"content{:toc} Java中常用的有关线程的操作有，判断线程是否启动、线程强制执行、线程休眠、线程中断、线程让步、线程同步等。下面就一一举例。 首先，我们新建一个MyThread类实现Runnable接口。基于此接口进行线程的相关操作。 1234567class MyThread implements Runnable &#123; public void run() &#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(Thread.currentThread().getName() + \" 运行 \" + i); &#125; &#125;&#125; 1、判断线程是否启动 判断线程是否启动很简单，通过Thread.isAlive()方法即可。 12345678910public class Test &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); Thread t = new Thread(mt); System.out.println(\"线程\" + (t.isAlive() ? \"已\" : \"未\") + \"启动\"); t.start(); System.out.println(\"线程\" + (t.isAlive() ? \"已\" : \"未\") + \"启动\"); &#125;&#125; 输出如下： 线程未启动线程已启动Thread-0 运行 0Thread-0 运行 1Thread-0 运行 2 2、线程强制执行 线程强制执行可以通过Thread.join()实现。我们首先来看一个没有强制执行的例子 1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; MyThread mt1 = new MyThread(); MyThread mt2 = new MyThread(); Thread t1 = new Thread(mt1); Thread t2 = new Thread(mt2); try &#123; t1.start(); // t1.join(); t2.start(); // t2.join(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序输入如下： Thread-0 运行 0Thread-1 运行 0Thread-0 运行 1Thread-1 运行 1Thread-0 运行 2Thread-1 运行 2 我们发现，两个线程是并行运行的，因此，执行的结果为两个线程分别执行取得的输出然后在按照时间插入到输出流中。我们将join注释掉之后，发现程序的执行结果变为： Thread-0 运行 0Thread-0 运行 1Thread-0 运行 2Thread-1 运行 0Thread-1 运行 1Thread-1 运行 2 可以看出，执行的结果是线程1开始执行，等线程1执行完毕之后线程2才开始执行。 3、线程休眠 线程休眠通过Thread.sleep()实现。这是一个静态方法，所以需要通过Thread类来调用，而不是通过实例化之后的变量调用。另外，调用sleep()可能抛出InterruptedException异常，我们我们需要将其放在try-catch块中来捕获此异常。 1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); Thread t = new Thread(mt); long stime = System.currentTimeMillis(); t.start(); System.out.println(System.currentTimeMillis() - stime); try &#123; Thread.sleep(1000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(System.currentTimeMillis() - stime); &#125;&#125; 程序执行结果为： Thread-0 运行 0Thread-0 运行 1Thread-0 运行 21000 使用System.currentTimeMiles()来获取程序运行的时间。我们发现：从开始执行到结束，花了1秒钟的时间，这个时间是main Thread休眠的时间。 4、线程中断 上一小节提到，线程在sleep过程中可以被打断并抛出InterruptedException异常，这个线程中断行为可以通过Thread.interrupt()实现。首先我们将时间统计移动到MyThread内部，然后在MyThread内每输出一次运行情况进行一次休眠操作。 1234567891011121314151617181920212223242526class MyThread implements Runnable &#123; public void run() &#123; long stime = System.currentTimeMillis(); System.out.println(System.currentTimeMillis() - stime); for (int i = 0; i &lt; 3; i++) &#123; System.out.println(Thread.currentThread().getName() + \" 运行 \" + i); try &#123; Thread.sleep(1000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(System.currentTimeMillis() - stime); &#125;&#125; public class Test &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); Thread t = new Thread(mt); t.start(); t.interrupt(); &#125;&#125; 程序输出为： Thread-0 运行 0java.lang.InterruptedException: sleep interruptedThread-0 运行 1 at java.lang.Thread.sleep(Native Method) at MyThread.run(Test.java:9) at java.lang.Thread.run(Thread.java:745) Thread-0 运行 22002 程序从开始运行到结束，花了2秒左右的时间，但是明明在MyThread内休眠了3次，每次一秒，应该运行3秒左右。这是因为在线程第一次休眠的时候，在main线程内通过Thread.interrupt对第一次休眠进行了打断，所以这次休眠时间几乎为0，剩余的两次休眠没有被打断，所以总共执行时间为2秒左右。 5、线程让步 有时候，线程在执行过程中，需要等待其余线程的执行结果，才能继续自身的运算，这时候就需要进行线程让步。线程的让步可以通过Thread.yield来实现。 12345678910111213141516171819202122class MyThread implements Runnable &#123; public void run() &#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(Thread.currentThread().getName() + \" 运行 \" + i); Thread.yield(); &#125; &#125;&#125; public class Test &#123; public static void main(String[] args) &#123; MyThread mt1 = new MyThread(); MyThread mt2 = new MyThread(); Thread t1 = new Thread(mt1); Thread t2 = new Thread(mt2); t1.start(); t2.start(); &#125;&#125; 输出结果为： Thread-0 运行 0Thread-1 运行 0Thread-0 运行 1Thread-1 运行 1Thread-0 运行 2Thread-1 运行 2 6、线程同步 Java中线程同步可以通过同步方法和同步代码块来完成： （6.1）同步方法 我们首先来观察一个程序的执行结果 12345678910111213141516171819class MyThread implements Runnable &#123; private int Tic = 5; @Override public void run() &#123; for (int i = 0; i &lt; 3; i++) if (Tic &gt; 0) System.out.println(Thread.currentThread().getName() + \" Ticket:\" + Tic--); &#125;&#125; public class Test &#123; public static void main(String[] args) &#123; MyThread mt = new MyThread(); for (int i = 0; i &lt; 3; i++) &#123; new Thread(mt).start(); &#125; &#125;&#125; 执行结果为： Thread-1 Ticket:5Thread-2 Ticket:3Thread-0 Ticket:4Thread-2 Ticket:1Thread-1 Ticket:2 我们发现，其结果是3个线程不分先后并行执行，当线程0运行的时候，线程2依然可以访问到方法体内部，反之依然。有时候（比如卖票系统）我们需要在一个线程运行的时候，另一个线程无法进入到正在运行的方法体内部，这时候我们就需要进行线程的同步与互斥操作。通过在方法前面加入synchronized可以指定一个方法为同步方法。 12345678910class MyThread implements Runnable &#123; private int Tic = 5; @Override public synchronized void run() &#123; for (int i = 0; i &lt; 3; i++) if (Tic &gt; 0) System.out.println(Thread.currentThread().getName() + \" Ticket:\" + Tic--); &#125;&#125; 此时程序的运行结果为： Thread-0 Ticket:5Thread-0 Ticket:4Thread-0 Ticket:3Thread-2 Ticket:2Thread-2 Ticket:1 可以看出，在增加了同步之后，票是一张一张被卖出去的，这样就可以有效的避免重票的情况。 （6.2）同步代码块 我们将上述代码改为如下。依然可以实现相同的功能 12345678910111213class MyThread implements Runnable &#123; private int Tic = 5; @Override public void run() &#123; synchronized (this) &#123; for (int i = 0; i &lt; 3; i++) if (Tic &gt; 0) System.out.println(Thread.currentThread().getName() + \" Ticket:\" + Tic--); &#125; &#125;&#125; （6.3）注意 1）当一个线程正在访问一个对象的synchronized方法，那么其他线程不能访问该对象的其他synchronized方法。这个原因很简单，因为一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized方法。 2）当一个线程正在访问一个对象的synchronized方法，那么其他线程能访问该对象的非synchronized方法。这个原因很简单，访问非synchronized方法不需要获得该对象的锁，假如一个方法没用synchronized关键字修饰，说明它不会使用到临界资源，那么其他线程是可以访问这个方法的， 3）如果一个线程A需要访问对象object1的synchronized方法fun1，另外一个线程B需要访问对象object2的synchronized方法fun1，即使object1和object2是同一类型），也不会产生线程安全问题，因为他们访问的是不同的对象，所以不存在互斥问题。 7、生产者消费者问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697class BreadContainer &#123; public static final int maxNum = 300; private int num; public BreadContainer() &#123; &#125; public BreadContainer(int num) &#123; this.num = num; &#125; public synchronized void produceBread(int pdcNum, String producer) &#123; while(num + pdcNum &gt; maxNum)&#123; System.out.println(producer + \" 要生产 \" + pdcNum +\" 个，资源充足无需生产，转入等待。\"); try&#123; this.wait(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; num += pdcNum; System.out.println(producer + \" 生产了 \" + pdcNum + \" 个，现有 \" + num + \" 个\"); this.notifyAll(); &#125; public synchronized void consumerBread(int csmNum, String consumer) &#123; while (csmNum &gt; num) &#123; System.out.println(consumer + \" 要消费 \" + csmNum + \" 个，资源不足无法消费，转入等待。\"); try &#123; this.wait(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; num -= csmNum; System.out.println(csmNum + \" 消费了 \" + csmNum + \" 个，现有 \" + num + \" 个\"); this.notifyAll(); &#125; &#125; class Producer extends Thread &#123; private int pdcNum; private BreadContainer bc; public Producer() &#123; &#125; public Producer(int pdcNum, BreadContainer bc, String producer) &#123; this.pdcNum = pdcNum; this.bc = bc; this.setName(producer); &#125; public void run() &#123; bc.produceBread(pdcNum, this.getName()); &#125;&#125; class Consumer extends Thread &#123; private int csmNum; private BreadContainer bc; public Consumer() &#123; &#125; public Consumer(int csmNum, BreadContainer bc, String consumer) &#123; this.csmNum = csmNum; this.bc = bc; this.setName(consumer); &#125; public void run() &#123; bc.consumerBread(csmNum, this.getName()); &#125;&#125; public class Test &#123; public static void main(String[] args) &#123; BreadContainer bc = new BreadContainer(50); Producer p1 = new Producer(50, bc, \"p1\"); Producer p2 = new Producer(200, bc, \"p2\"); Producer p3 = new Producer(290, bc, \"p3\"); Consumer c1 = new Consumer(70, bc, \"c1\"); Consumer c2 = new Consumer(80, bc, \"c2\"); c1.start(); c2.start(); p1.start(); p2.start(); p3.start(); &#125;&#125; 输出结果为： c1 要消费 70 个，资源不足无法消费，转入等待。p3 要生产 290 个，资源充足无需生产，转入等待。p2 生产了 200 个，现有 250 个p1 生产了 50 个，现有 300 个80 消费了 80 个，现有 220 个p3 要生产 290 个，资源充足无需生产，转入等待。70 消费了 70 个，现有 150 个p3 要生产 290 个，资源充足无需生产，转入等待。","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"Thread","slug":"Thread","permalink":"http://blog.duanxu.tech/tags/Thread/"},{"name":"Runnable","slug":"Runnable","permalink":"http://blog.duanxu.tech/tags/Runnable/"}]},{"title":"Android开发手记(26) Java多线程的实现","slug":"2015/2015-11-14-Android-Study-26-Thread","date":"2015-11-14T11:17:00.000Z","updated":"2018-12-07T12:45:53.202Z","comments":true,"path":"2015/11/14/2015/2015-11-14-Android-Study-26-Thread/","link":"","permalink":"http://blog.duanxu.tech/2015/11/14/2015/2015-11-14-Android-Study-26-Thread/","excerpt":"","text":"content{:toc} 随着多核CPU的发展，多线程编程显得越来越重要，本文将对Java中的多线程编程进行一些简单的探讨。 1、继承Thread类 Java中，线程运行的基本单位是Thread，所以，我们可以通过继承Thread类的方法来实现多线程编程。继承Thread类，必须重写run方法。 12345678910class MyThread extends Thread &#123; private int num = 5; public void run() &#123; for (int i = 0; i &lt; 5; i++) if (num &gt; 0) System.out.println(Thread.currentThread().getName() + \" Ticket:\" + num--); &#125;&#125; 这样，我们在main方法里就可以通过实例化两个MyThread类的方法来实现多线程编程。 123456789public class Test &#123; public static void main(String[] args) &#123; MyThread t1 = new MyThread(); MyThread t2 = new MyThread(); t1.start(); t2.start(); &#125;&#125; 最后运行的结果如下： Thread-1 Ticket:5Thread-0 Ticket:5Thread-1 Ticket:4Thread-0 Ticket:4Thread-1 Ticket:3Thread-0 Ticket:3Thread-1 Ticket:2Thread-0 Ticket:2Thread-0 Ticket:1Thread-1 Ticket:1 当然，由于线程运行不确定性，所以每次运行的结果可能不尽相同。 2、Runnable方法 Runnable实际上是一个接口，我们在多线程编程的时候需要实现这个接口定义的抽象方法。首先需要定义一个MyRunnable来实现Runnable的接口。这里我们只实现其中的构造方法和run方法。run()是MyRunnable运行的关键方法。 12345678910class MyThread implements Runnable &#123; private int num = 5; public void run() &#123; for (int i = 0; i &lt; 5; i++) if (num &gt; 0) System.out.println(Thread.currentThread().getName() + \" Ticket:\" + num--); &#125;&#125; 然后，仅仅实现了Runnable的接口是无法运行的。因为线程运行单位是Thread，所以我们需要用Runnable实例化一个Thread来运行。实际上Thread也是实现了Runnable的接口。 123456789101112public class Test &#123; public static void main(String[] args) &#123; MyThread t1 = new MyThread(); MyThread t2 = new MyThread(); Thread tt1 = new Thread(t1, \"NO.1\"); Thread tt2 = new Thread(t2, \"NO.2\"); tt1.start(); tt2.start(); &#125;&#125; 具体的执行结果如下： NO.1 Ticket:5NO.1 Ticket:4NO.2 Ticket:5NO.1 Ticket:3NO.2 Ticket:4NO.1 Ticket:2NO.1 Ticket:1NO.2 Ticket:3NO.2 Ticket:2NO.2 Ticket:1 3、Runnable和Thread的区别与联系 实现Runnable接口比继承Thread类所具有的优势： 1）：适合多个相同的程序代码的线程去处理同一个资源 2）：可以避免java中的单继承的限制 3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立。 另外，使用Runnable可以实现对线程资源的共享，我们将2中的main方法修改如下，通过使用同一个Runnable实例化多个线程，可以实现对此Runnable资源的共享。 1234567891011public class Test &#123; public static void main(String[] args) &#123; MyThread t = new MyThread(); Thread tt1 = new Thread(t, \"NO.1\"); Thread tt2 = new Thread(t, \"NO.2\"); tt1.start(); tt2.start(); &#125;&#125; 运行结果为： NO.1 Ticket:5NO.2 Ticket:4NO.1 Ticket:3NO.2 Ticket:2NO.1 Ticket:1 4、使用线程池实现多线程 本小节转载自：博客园 java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类，其构造方法为： 12public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue); corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中； maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程； keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0； unit：参数keepAliveTime的时间单位。 workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响。 具体实现为： 12345678910111213141516171819202122232425262728293031public class Test &#123; public static void main(String[] args) &#123; ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(5)); for(int i=0;i&lt;15;i++)&#123; MyTask myTask = new MyTask(i); executor.execute(myTask); System.out.println(\"线程池中线程数目：\"+executor.getPoolSize()+\"，队列中等待执行的任务数目：\"+ executor.getQueue().size()+\"，已执行玩别的任务数目：\" + executor.getCompletedTaskCount()); &#125; executor.shutdown(); &#125;&#125; class MyTask implements Runnable &#123; private int taskNum; public MyTask(int num) &#123; this.taskNum = num; &#125; @Override public void run() &#123; System.out.println(\"正在执行task \"+taskNum); try &#123; Thread.currentThread().sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"task \"+taskNum+\"执行完毕\"); &#125;&#125; 执行结果： 正在执行task 0线程池中线程数目：1，队列中等待执行的任务数目：0，已执行玩别的任务数目：0线程池中线程数目：2，队列中等待执行的任务数目：0，已执行玩别的任务数目：0线程池中线程数目：3，队列中等待执行的任务数目：0，已执行玩别的任务数目：0正在执行task 1正在执行task 2线程池中线程数目：4，队列中等待执行的任务数目：0，已执行玩别的任务数目：0正在执行task 3线程池中线程数目：5，队列中等待执行的任务数目：0，已执行玩别的任务数目：0正在执行task 4线程池中线程数目：5，队列中等待执行的任务数目：1，已执行玩别的任务数目：0线程池中线程数目：5，队列中等待执行的任务数目：2，已执行玩别的任务数目：0线程池中线程数目：5，队列中等待执行的任务数目：3，已执行玩别的任务数目：0线程池中线程数目：5，队列中等待执行的任务数目：4，已执行玩别的任务数目：0线程池中线程数目：5，队列中等待执行的任务数目：5，已执行玩别的任务数目：0线程池中线程数目：6，队列中等待执行的任务数目：5，已执行玩别的任务数目：0正在执行task 10线程池中线程数目：7，队列中等待执行的任务数目：5，已执行玩别的任务数目：0正在执行task 11线程池中线程数目：8，队列中等待执行的任务数目：5，已执行玩别的任务数目：0正在执行task 12线程池中线程数目：9，队列中等待执行的任务数目：5，已执行玩别的任务数目：0正在执行task 13线程池中线程数目：10，队列中等待执行的任务数目：5，已执行玩别的任务数目：0正在执行task 14task 0执行完毕正在执行task 5task 1执行完毕task 2执行完毕正在执行task 6正在执行task 7task 4执行完毕task 3执行完毕正在执行task 8正在执行task 9task 12执行完毕task 11执行完毕task 13执行完毕task 10执行完毕task 14执行完毕task 5执行完毕task 6执行完毕task 7执行完毕task 8执行完毕task 9执行完毕 不过在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池： 123Executors.newCachedThreadPool(); //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUEExecutors.newSingleThreadExecutor(); //创建容量为1的缓冲池Executors.newFixedThreadPool(int); //创建固定容量大小的缓冲池 下面是这三个静态方法的具体实现： 12345678910111213141516public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。 newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue； newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue； newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。 实际中，如果Executors提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置ThreadPoolExecutor的参数有点麻烦，要根据实际任务的类型和数量来进行配置。另外，如果ThreadPoolExecutor达不到要求，可以自己继承ThreadPoolExecutor类进行重写。","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"Thread","slug":"Thread","permalink":"http://blog.duanxu.tech/tags/Thread/"},{"name":"Runnable","slug":"Runnable","permalink":"http://blog.duanxu.tech/tags/Runnable/"}]},{"title":"Android开发手记(25) 简单Service的实现","slug":"2015/2015-11-12-Android-Study-25-Service","date":"2015-11-12T10:12:00.000Z","updated":"2018-12-07T12:45:37.832Z","comments":true,"path":"2015/11/12/2015/2015-11-12-Android-Study-25-Service/","link":"","permalink":"http://blog.duanxu.tech/2015/11/12/2015/2015-11-12-Android-Study-25-Service/","excerpt":"","text":"content{:toc} 本文将通过实现一个简单的Service发送简单消息，然后通过一个BroadcastReceiver接收Service发送的消息，从而改变一个TextView的文本颜色。 这里，我们需要三个java文件，一个实现MainActivity，一个实现Service，一个实现BroadcastReceiver。 首先是MyService.java，为了让BroadcastReceiver，接收到消息，我们需要调用sendBroadcast(Intent) 方法，这里的intent便是我们需要发送的消息内容。发送消息的时候改变TextView的颜色一次。 12intent = new Intent(\"Change_Color\");sendBroadcast(intent); 为了实现1s改变一次TextView的颜色，我们需要将Service运行在一个线程之中，这时我们来新建一个线程，并让此线程每隔1s休眠一次。需要注意的是，在最后一定不能忘记调用Thread.start()。 123456789101112131415new Thread()&#123; @Override public void run()&#123; while(true)&#123; intent = new Intent(\"Change_Color\"); // 待广播的intent sendBroadcast(intent); // 广播intent try&#123; Thread.sleep(1000); // 休眠1秒 &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); // 开启线程 另外，继承Service的话，需要重载onBind方法，IBinder是远程对象的基本接口，是为高性能而设计的轻量级远程调用机制的核心部分。但它不仅用于远程调用，也用于进程内调用。这个接口定义了与远程对象交互的协议。Android的远程调用（就是跨进程调用）就是通过IBinder实现的。 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041import android.app.Service;import android.content.Intent;import android.os.IBinder; public class MyService extends Service&#123; private Intent intent; @Override public IBinder onBind(Intent i)&#123; return null; &#125; @Override public void onCreate()&#123; super.onCreate(); new Thread()&#123; @Override public void run()&#123; while(true)&#123; intent = new Intent(\"Change_Color\"); sendBroadcast(intent); try&#123; Thread.sleep(1000); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;.start(); &#125; @Override public void onDestroy()&#123; super.onDestroy(); this.stopService(intent); &#125;&#125; 然后是MyBroadcastReceiver.java，继承BroadcastReceiver，然后重载onReceiver。在得到的intent判断intent.getAction()是否和发送的消息相同即可。 12345678if(intent.getAction().equals(\"Change_Color\"))&#123; // 接受的intent是上述发送的intent if(!colorIndex) &#123; MainActivity.textView.setTextColor(Color.BLUE); // 改变TextView的颜色 colorIndex = true; &#125; else &#123; MainActivity.textView.setTextColor(Color.RED); colorIndex = false; &#125; colorIndex需要定义为static，为了使下一次实例化MyBroadcastReceiver的时候可以记住当前的TextView颜色。完整代码如下： 123456789101112131415161718192021222324import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.graphics.Color; public class MyBroadcastReceiver extends BroadcastReceiver&#123; static boolean colorIndex = false; @Override public void onReceive(Context context, Intent intent)&#123; if(intent.getAction().equals(\"Change_Color\"))&#123; if(!colorIndex) &#123; MainActivity.textView.setTextColor(Color.BLUE); colorIndex = true; &#125; else &#123; MainActivity.textView.setTextColor(Color.RED); colorIndex = false; &#125; &#125; &#125;&#125; 最后是MainActivity.java，这个比较简单，在onCreate()内startService()，在onDestroy()内stopService()即可。注意一定要stopService()，否则这个Service将一直占用CPU时间。 12345678910111213141516171819202122232425262728293031323334353637import android.app.Activity;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView; public class MainActivity extends Activity &#123; private Button button; static TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView)findViewById(R.id.textView); button = (Button)findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startService(new Intent(MainActivity.this, MyService.class)); // 启动服务 textView.setText(\"这是一个可以变颜色的文字\"); &#125; &#125;); &#125; @Override public void onDestroy()&#123; super.onDestroy(); stopService(new Intent(MainActivity.this, MyService.class)); // 关闭服务 &#125;&#125; 仅仅这样做，我们发现仍然没法让程序按照我们希望的样子运行。这是因为我们没有在AndroidManifest.xml内注册我们定义的Service和BroadcastReceiver。 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.doodle.example\" &gt; &lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:theme=\"@style/AppTheme\" &gt; &lt;activity android:name=\".MainActivity\" android:label=\"@string/app_name\" &gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;service android:name=\".MyService\"/&gt; &lt;receiver android:name=\".MyBroadcastReceiver\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"Change_Color\"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;/application&gt; &lt;/manifest&gt;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"Service","slug":"Service","permalink":"http://blog.duanxu.tech/tags/Service/"}]},{"title":"Android开发手记(24) Log的使用及颜色的更改","slug":"2015/2015-11-08-Android-Study-24-Log","date":"2015-11-08T11:43:00.000Z","updated":"2018-12-07T12:45:23.341Z","comments":true,"path":"2015/11/08/2015/2015-11-08-Android-Study-24-Log/","link":"","permalink":"http://blog.duanxu.tech/2015/11/08/2015/2015-11-08-Android-Study-24-Log/","excerpt":"","text":"content{:toc} 在程序开发过程中，LOG是广泛使用的用来记录程序执行过程的机制，它既可以用于程序调试，也可以用于产品运营中的事件记录。在Android系统中，提供了简单、便利的LOG机制，开发人员可以方便地使用。本文简单介绍了Android中Log的使用以及在Android Studio中 Log 颜色的更改。 要使用 Log，我们需要首先 import android.util.Log，其中Log常用的方法有5个：Log.v() Log.d() Log.i() Log.w() 以及 Log.e() 。根据首字母对应VERBOSE，DEBUG，INFORMATION，WARNING，ERROR。其中： Log.v 的调试颜色为黑色的，任何消息都会输出。 Log.d的输出颜色是蓝色的，仅输出debug调试的意思，但他会输出上层的信息。 Log.i的输出为绿色，一般提示性的消息information，它不会输出Log.v和Log.d的信息，但会显示i、w和e的信息。 Log.w的意思为橙色，可以看作为warning警告，一般需要我们注意优化Android代码，同时选择它后还会输出Log.e的信息。 Log.e为红色，可以想到error错误，这里仅显示红色的错误信息，这些错误就需要我们认真的分析，查看栈的信息了。 我们新建一个Button，然后Click事件设置为： 12345Log.v(\"MainActivity\", \"This is Verbose.\");Log.d(\"MainActivity\", \"This is Debug.\");Log.i(\"MainActivity\", \"This is Information\");Log.w(\"MainActivity\", \"This is Warning.\");Log.e(\"MainActivity\", \"This is Error.\"); 此时，我们单击Button时，在Android/logcat中便会显示出Log信息： 但是，我们发现，Log信息在你的电脑上可能是白色和红色的。那么如何来修改Log信息的颜色呢？ File-&gt;Settings 或Ctrl + Alt +S 找到 Editor -&gt; Colors &amp;Fonts -&gt; Android Logcat 或在上面的搜索框中输入Logcat 点中Verbose , Info, Debug等选项，然后在后面将Use Inberited attributes 去掉勾选 再将 Foreground 前的复选框选上，就可以双击后面的框框去选择颜色了 Apply–&gt;OK 我们可以将Log颜色修改如下，便可得到上图所示的Log效果。 Log 色值 VERBOSE BBBBBB DEBUG 0070BB INFOMATION 48BB31 WARNING BBBB23 ERROR FF0006 ASSERT 8F0005 至此便可得到上述的效果了。 完整代码如下： 123456789101112131415161718192021222324252627282930import android.app.Activity;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button; public class MainActivity extends Activity &#123; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Log.v(\"MainActivity\", \"This is Verbose.\"); Log.d(\"MainActivity\", \"This is Debug.\"); Log.i(\"MainActivity\", \"This is Information\"); Log.w(\"MainActivity\", \"This is Warning.\"); Log.e(\"MainActivity\", \"This is Error.\"); &#125; &#125;); &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"Log","slug":"Log","permalink":"http://blog.duanxu.tech/tags/Log/"}]},{"title":"Android开发手记(23) Notification","slug":"2015/2015-11-06-Android-Study-23-Notification","date":"2015-11-06T08:37:00.000Z","updated":"2018-12-07T12:45:11.957Z","comments":true,"path":"2015/11/06/2015/2015-11-06-Android-Study-23-Notification/","link":"","permalink":"http://blog.duanxu.tech/2015/11/06/2015/2015-11-06-Android-Study-23-Notification/","excerpt":"","text":"content{:toc} 有时候，我们需要应用程序在状态内显示一些通知信息，这时我们就需要使用Notification来完成这一工作。也许我们会想到以前经常使用的Toast来通知用户。虽然Notification与Toast都可以起到通知、提醒的作用，其实这两者还是有很大不同的。在android中，Notification是通过NotificationManager进行统一管理的，而Toast使用Toast.makeToast即可显示。另外，Notification可以长久的显示在系统的状态栏内，但是Toast只能暂时显示一段时间。 现在我们开始讨论创建Notification的一般步骤。 首先，我们需要通过getSystemService方法获得一个NotificationManager对象。 1NotificationManager nfManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); 然后，要想显示一个Notification，我们还需一个PendingIntent，由于PendingIntent由android系统负责维护，可以防止在应用程序关闭的时候系统自动销毁Notification对象。 1PendingIntent intent = PendingIntent.getActivity(MainActivity.this, 0, getIntent(), 0); 然后，通过Notification.Builder创建一个Notification对象。 12345678910Notification notification = new Notification.Builder(MainActivity.this) .setSmallIcon(android.R.drawable.ic_dialog_email) // 设置Icon .setTicker(\"你有一封新邮件\") // 设置接收时滚动通知 .setContentTitle(\"邮件主题：这是第\" + notiID + \"封邮件\") // 设置Title .setContentText(\"邮件内容:\") // 设置Message .setContentIntent(intent) // 设置用于显示的Intent .setNumber(notiID) // 设置右下角Number .getNotification(); //API 11可以使用getNotificatin() // API 16及之后使用 build()notification.flags = Notification.FLAG_AUTO_CANCEL; // 点击自动消失 最后，通过NotificationManager来显示Notification即可。 1nfManager.notify(notiID++, notification); // notiID定义了通知的编号，notification为通知的内容 如果想销毁显示的Notification可以使用NotificationManager提供的方法。 12nfManager.cancel(notiID); // 销毁编号为notiID的通知nfManager.cancelAll(); // 销毁所有通知 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import android.app.Activity;import android.app.Notification;import android.app.NotificationManager;import android.app.PendingIntent;import android.os.Bundle;import android.view.View;import android.widget.Button; public class MainActivity extends Activity &#123; private NotificationManager nfManager; private Button btnNoti; private Button btnClear; private int notiID; @Override protected void onCreate (Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); notiID = 1; nfManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); btnNoti = (Button)findViewById(R.id.brnNoti); btnNoti.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; PendingIntent intent = PendingIntent.getActivity(MainActivity.this, 0, getIntent(), 0); Notification notification = new Notification.Builder(MainActivity.this) .setSmallIcon(android.R.drawable.ic_dialog_email) // 设置Icon .setTicker(\"你有一封新邮件\") // 设置接收时滚动通知 .setContentTitle(\"邮件主题：这是第\" + notiID + \"封邮件\") // 设置Title .setContentText(\"邮件内容:\") // 设置Message .setContentIntent(intent) // 设置用于显示的Intent .setNumber(notiID) // 设置右下角Number .getNotification(); //API 11可以使用getNotificatin() // API 16及之后使用 build() notification.flags = Notification.FLAG_AUTO_CANCEL; // 点击自动消失 nfManager.notify(notiID++, notification); &#125; &#125;); btnClear = (Button)findViewById(R.id.btnClear); btnClear.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; nfManager.cancel(notiID --);// nfManager.cancelAll(); &#125; &#125;); &#125;&#125; 然后，我们添加三个TextView和三个EditText和一个Button。如图所示：","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"Notification","slug":"Notification","permalink":"http://blog.duanxu.tech/tags/Notification/"}]},{"title":"Android开发手记(22) 传感器的使用","slug":"2015/2015-11-05-Android-Study-22-Sensors","date":"2015-11-05T13:54:00.000Z","updated":"2018-12-07T12:44:51.154Z","comments":true,"path":"2015/11/05/2015/2015-11-05-Android-Study-22-Sensors/","link":"","permalink":"http://blog.duanxu.tech/2015/11/05/2015/2015-11-05-Android-Study-22-Sensors/","excerpt":"","text":"content{:toc} Android的传感器主要包括八大传感器，他们分别是：加速度传感器（accelerometer）、陀螺仪（gyroscope）、方向传感器（orientation）、磁力传感器（magnetic field）、环境光照传感器（light）、温度传感器（temperature）、距离传感器（proximity）和压力传感器（pressure）。本文先对传感器的使用做一个总体的介绍，然后再详细介绍每一种传感器的具体参数获取。 〇、总体介绍 Android传感器的使用，先通过SensorManager获取系统提供的传感器服务。然后通过得到的Sensor服务，实例化一个需要使用到的传感器。之后实例化一个SensorEventListener，来监听传感器的变化信息。最后注册此SensorEventListener即可。 12345678910111213141516171819// 获取系统提供的传感器服务SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);// 实例化需要使用的传感器（以加速度传感器为例）Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);// 实例化传感器事件监听器SensorEventListener sel = SensorEventListener() &#123; @Override public void onSensorChanged(SensorEvent sensorEvent) &#123; // 获取传感器变化信息 // sensorEvent.values 存储了传感器的数值 &#125; @Override public void onAccuracyChanged(Sensor sensor, int i) &#123; // 获取传感器精度变化信息 &#125;&#125;;// 注册传感器事件监听器，第三个参数为采样时间sensorManager.registerListener(sel, sensor, SensorManager.SENSOR_DELAY_NORMAL); 传感器的名称和对应类型为： 名称 英文 类型 加速度传感器 accelerometer Sensor.TYPE_ACCELEROMETER 陀螺仪 gyroscope Sensor.TYPE_GYROSCOPE 方向传感器 orientation Sensor.TYPE_ORIENTATION 磁场传感器 magnetic field Sensor.TYPE_MAGNETIC_FIELD 环境光照传感器 light Sensor.TYPE_LIGHT 温度传感器 temperature Sensor.TYPE_AMBIENT_TEMPERATURE 距离传感器 proximity Sensor.TYPE_PROXIMITY 压力传感器 pressure ensor.TYPE_PRESSURE 一、加速度传感器（TYPE_ACCELEROMETER） 按照上文所述，我们添加一个Button来启动传感器，然后添加一个TextView来接收传感器的数据。sensorEvent.values存储的数据中，value[0]为X轴方向上的加速度，value[1]为Y轴方向上的加速度，value[2]为Z轴方向上的加速度。单位为m/s2。 1234567891011121314151617181920212223btnAcc = (Button) findViewById(R.id.btnAcc);btnAcc.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sensorManager.unregisterListener(sel); sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER); sel = new SensorEventListener() &#123; @Override public void onSensorChanged(SensorEvent sensorEvent) &#123; float[] value = sensorEvent.values; String str = \"加速度传感器加速度\" + \"\\nX轴：\" + value[0] + \"\\nY轴：\" + value[1] + \"\\nZ轴：\" + value[2]; textView.setText(str); &#125; @Override public void onAccuracyChanged(Sensor sensor, int i) &#123; &#125; &#125;; sensorManager.registerListener(sel, sensor, SensorManager.SENSOR_DELAY_NORMAL); &#125;&#125;); 二、陀螺仪（TYPE_GYROSCOPE） 按照上文所述，我们添加一个Button来启动传感器，然后添加一个TextView来接收传感器的数据。sensorEvent.values存储的数据中，value[0]为X轴方向上的角速度，value[1]为Y轴方向上的角速度，value[2]为Z轴方向上的角速度。单位为rad/s。 1234567891011121314151617181920212223btnGys = (Button)findViewById(R.id.btnGys);btnGys.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sensorManager.unregisterListener(sel); sensor = sensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE); sel = new SensorEventListener() &#123; @Override public void onSensorChanged(SensorEvent sensorEvent) &#123; float[] value = sensorEvent.values; String str = \"陀螺仪传感器角速度\" + \"\\nX轴：\" + value[0] + \"\\nY轴：\" + value[1] + \"\\nZ轴：\" + value[2]; textView.setText(str); &#125; @Override public void onAccuracyChanged(Sensor sensor, int i) &#123; &#125; &#125;; sensorManager.registerListener(sel, sensor, SensorManager.SENSOR_DELAY_NORMAL); &#125;&#125;); 三、方向传感器（TYPE_ORIENTATION） 按照上文所述，我们添加一个Button来启动传感器，然后添加一个TextView来接收传感器的数据。sensorEvent.values存储的数据中，value[0]为Yaw轴方向上的角度，value[1]为Pitch轴方向上的角度，value[2]为Roll轴方向上的角度。单位为degree。其中，在手机平面内顺时针旋转为Yaw增加方向，将手机屏幕向上从左往右看，手机逆时针旋转为Pitch增加方向。手机屏幕向上，从后往前看，手机逆时针旋转为Roll增加方向。 1234567891011121314151617181920212223btnOri = (Button)findViewById(R.id.btnOri);btnOri.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sensorManager.unregisterListener(sel); sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION); sel = new SensorEventListener() &#123; @Override public void onSensorChanged(SensorEvent sensorEvent) &#123; float[] value = sensorEvent.values; String str = \"姿态传感器角度\" + \"\\nYaw：\" + value[0] + \"\\nPitch：\" + value[1] + \"\\nRoll：\" + value[2]; textView.setText(str); &#125; @Override public void onAccuracyChanged(Sensor sensor, int i) &#123; &#125; &#125;; sensorManager.registerListener(sel, sensor, SensorManager.SENSOR_DELAY_NORMAL); &#125;&#125;); 四、磁场传感器（TYPE_MAGNETIC_FIELD） 按照上文所述，我们添加一个Button来启动传感器，然后添加一个TextView来接收传感器的数据。sensorEvent.values存储的数据中，value[0]为X轴方向上的磁场强度，value[1]为Y轴方向上的磁场强度，value[2]为Z轴方向上的磁场强度。单位为μT。 1234567891011121314151617181920212223btnMage = (Button)findViewById(R.id.btnMage);btnMage.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sensorManager.unregisterListener(sel); sensor = sensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD); sel = new SensorEventListener() &#123; @Override public void onSensorChanged(SensorEvent sensorEvent) &#123; float[] value = sensorEvent.values; String str = \"磁场传感器微特斯拉\" + \"\\nX轴：\" + value[0] + \"\\nY轴：\" + value[1] + \"\\nZ轴：\" + value[2]; textView.setText(str); &#125; @Override public void onAccuracyChanged(Sensor sensor, int i) &#123; &#125; &#125;; sensorManager.registerListener(sel, sensor, SensorManager.SENSOR_DELAY_NORMAL); &#125;&#125;); 五、环境光照传感器（TYPE_LIGHT） 按照上文所述，我们添加一个Button来启动传感器，然后添加一个TextView来接收传感器的数据。sensorEvent.values存储的数据中，value[0]为当前环境光照强度，单位为lux。 12345678910111213141516171819202122btnLight = (Button)findViewById(R.id.btnLight);btnLight.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sensorManager.unregisterListener(sel); sensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT); sel = new SensorEventListener() &#123; @Override public void onSensorChanged(SensorEvent sensorEvent) &#123; float[] value = sensorEvent.values; String str = \"光照传感器\" + \"\\n光强(lux)：\" + value[0]; textView.setText(str); &#125; @Override public void onAccuracyChanged(Sensor sensor, int i) &#123; &#125; &#125;; sensorManager.registerListener(sel, sensor, SensorManager.SENSOR_DELAY_NORMAL); &#125;&#125;); 六、温度传感器（TYPE_AMBIENT_TEMPERATURE） 按照上文所述，我们添加一个Button来启动传感器，然后添加一个TextView来接收传感器的数据。sensorEvent.values存储的数据中，value[0]为当前环境温度，单位为摄氏度。 12345678910111213141516171819202122btnTemp = (Button)findViewById(R.id.btnTemp);btnTemp.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sensorManager.unregisterListener(sel); sensor = sensorManager.getDefaultSensor(Sensor.TYPE_AMBIENT_TEMPERATURE); sel = new SensorEventListener() &#123; @Override public void onSensorChanged(SensorEvent sensorEvent) &#123; float[] value = sensorEvent.values; String str = \"温度传感器\" + \"\\n温度(℃)：\" + value[0]; textView.setText(str); &#125; @Override public void onAccuracyChanged(Sensor sensor, int i) &#123; &#125; &#125;; sensorManager.registerListener(sel, sensor, SensorManager.SENSOR_DELAY_NORMAL); &#125;&#125;); 七、距离传感器（TYPE_PROXIMITY） 按照上文所述，我们添加一个Button来启动传感器，然后添加一个TextView来接收传感器的数据。sensorEvent.values存储的数据中，value[0]为当前距离，单位为厘米。距离传感器可以空来探测用户是否在打电话的时候将手机贴到了耳边，从而熄灭屏幕避免误触。 12345678910111213141516171819202122btnPxm = (Button)findViewById(R.id.btnPxm);btnPxm.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sensorManager.unregisterListener(sel); sensor = sensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY); sel = new SensorEventListener() &#123; @Override public void onSensorChanged(SensorEvent sensorEvent) &#123; float[] value = sensorEvent.values; String str = \"距离传感器\" + \"\\n距离(厘米)：\" + value[0]; textView.setText(str); &#125; @Override public void onAccuracyChanged(Sensor sensor, int i) &#123; &#125; &#125;; sensorManager.registerListener(sel, sensor, SensorManager.SENSOR_DELAY_NORMAL); &#125;&#125;); 八、压力传感器（TYPE_PRESSURE） 按照上文所述，我们添加一个Button来启动传感器，然后添加一个TextView来接收传感器的数据。sensorEvent.values存储的数据中，value[0]为当前压力，压力的返回数值为0~1中间的值，没有具体单位。 12345678910111213141516171819202122btnPre = (Button)findViewById(R.id.btnPre);btnPre.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sensorManager.unregisterListener(sel); sensor = sensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY); sel = new SensorEventListener() &#123; @Override public void onSensorChanged(SensorEvent sensorEvent) &#123; float[] value = sensorEvent.values; String str = \"压力传感器\" + \"\\n压力：\" + value[0]; textView.setText(str); &#125; @Override public void onAccuracyChanged(Sensor sensor, int i) &#123; &#125; &#125;; sensorManager.registerListener(sel, sensor, SensorManager.SENSOR_DELAY_NORMAL); &#125;&#125;); 九、完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201import android.app.Activity;import android.hardware.Sensor;import android.hardware.SensorEvent;import android.hardware.SensorEventListener;import android.hardware.SensorManager;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView; public class MainActivity extends Activity &#123; private Button btnAcc; private Button btnGys; private Button btnOri; private Button btnMage; private Button btnLight; private Button btnTemp; private Button btnPxm; private Button btnPrs; private TextView textView; private SensorManager sensorManager; private SensorEventListener sel; private Sensor sensor; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView) findViewById(R.id.textView); sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE); btnAcc = (Button) findViewById(R.id.btnAcc); btnAcc.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sensorManager.unregisterListener(sel); sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER); sel = new SensorEventListener() &#123; @Override public void onSensorChanged(SensorEvent sensorEvent) &#123; float[] value = sensorEvent.values; String str = \"加速度传感器加速度\" + \"\\nX轴：\" + value[0] + \"\\nY轴：\" + value[1] + \"\\nZ轴：\" + value[2]; textView.setText(str); &#125; @Override public void onAccuracyChanged(Sensor sensor, int i) &#123; &#125; &#125;; sensorManager.registerListener(sel, sensor, SensorManager.SENSOR_DELAY_NORMAL); &#125; &#125;); btnGys = (Button)findViewById(R.id.btnGys); btnGys.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sensorManager.unregisterListener(sel); sensor = sensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE); sel = new SensorEventListener() &#123; @Override public void onSensorChanged(SensorEvent sensorEvent) &#123; float[] value = sensorEvent.values; String str = \"陀螺仪传感器角速度\" + \"\\nX轴：\" + value[0] + \"\\nY轴：\" + value[1] + \"\\nZ轴：\" + value[2]; textView.setText(str); &#125; @Override public void onAccuracyChanged(Sensor sensor, int i) &#123; &#125; &#125;; sensorManager.registerListener(sel, sensor, SensorManager.SENSOR_DELAY_NORMAL); &#125; &#125;); btnOri = (Button)findViewById(R.id.btnOri); btnOri.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sensorManager.unregisterListener(sel); sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION); sel = new SensorEventListener() &#123; @Override public void onSensorChanged(SensorEvent sensorEvent) &#123; float[] value = sensorEvent.values; String str = \"姿态传感器角度\" + \"\\nYaw：\" + value[0] + \"\\nPitch：\" + value[1] + \"\\nRoll：\" + value[2]; textView.setText(str); &#125; @Override public void onAccuracyChanged(Sensor sensor, int i) &#123; &#125; &#125;; sensorManager.registerListener(sel, sensor, SensorManager.SENSOR_DELAY_NORMAL); &#125; &#125;); btnMage = (Button)findViewById(R.id.btnMage); btnMage.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sensorManager.unregisterListener(sel); sensor = sensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD); sel = new SensorEventListener() &#123; @Override public void onSensorChanged(SensorEvent sensorEvent) &#123; float[] value = sensorEvent.values; String str = \"磁场传感器微特斯拉\" + \"\\nX轴：\" + value[0] + \"\\nY轴：\" + value[1] + \"\\nZ轴：\" + value[2]; textView.setText(str); &#125; @Override public void onAccuracyChanged(Sensor sensor, int i) &#123; &#125; &#125;; sensorManager.registerListener(sel, sensor, SensorManager.SENSOR_DELAY_NORMAL); &#125; &#125;); btnLight = (Button)findViewById(R.id.btnLight); btnLight.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sensorManager.unregisterListener(sel); sensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT); sel = new SensorEventListener() &#123; @Override public void onSensorChanged(SensorEvent sensorEvent) &#123; float[] value = sensorEvent.values; String str = \"光照传感器\" + \"\\n光强(lux)：\" + value[0]; textView.setText(str); &#125; @Override public void onAccuracyChanged(Sensor sensor, int i) &#123; &#125; &#125;; sensorManager.registerListener(sel, sensor, SensorManager.SENSOR_DELAY_NORMAL); &#125; &#125;); btnTemp = (Button)findViewById(R.id.btnTemp); btnTemp.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sensorManager.unregisterListener(sel); sensor = sensorManager.getDefaultSensor(Sensor.TYPE_AMBIENT_TEMPERATURE); sel = new SensorEventListener() &#123; @Override public void onSensorChanged(SensorEvent sensorEvent) &#123; float[] value = sensorEvent.values; String str = \"温度传感器\" + \"\\n温度(℃)：\" + value[0]; textView.setText(str); &#125; @Override public void onAccuracyChanged(Sensor sensor, int i) &#123; &#125; &#125;; sensorManager.registerListener(sel, sensor, SensorManager.SENSOR_DELAY_NORMAL); &#125; &#125;); btnPxm = (Button)findViewById(R.id.btnPxm); btnPxm.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; sensorManager.unregisterListener(sel); sensor = sensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY); sel = new SensorEventListener() &#123; @Override public void onSensorChanged(SensorEvent sensorEvent) &#123; float[] value = sensorEvent.values; String str = \"距离传感器\" + \"\\n距离(厘米)：\" + value[0]; textView.setText(str); &#125; @Override public void onAccuracyChanged(Sensor sensor, int i) &#123; &#125; &#125;; sensorManager.registerListener(sel, sensor, SensorManager.SENSOR_DELAY_NORMAL); &#125; &#125;); &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"Sensor","slug":"Sensor","permalink":"http://blog.duanxu.tech/tags/Sensor/"}]},{"title":"Android开发手记(21) 遍历文件夹","slug":"2015/2015-11-04-Android-Study-21-Travel-Folder","date":"2015-11-04T14:08:00.000Z","updated":"2018-12-07T12:44:42.280Z","comments":true,"path":"2015/11/04/2015/2015-11-04-Android-Study-21-Travel-Folder/","link":"","permalink":"http://blog.duanxu.tech/2015/11/04/2015/2015-11-04-Android-Study-21-Travel-Folder/","excerpt":"","text":"content{:toc} 我们在遍历文件夹的时候由于涉及到SD卡相关操作，所以我们需要添加如下权限： 12&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt;&lt;uses-permission android:name=\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\"/&gt; 首先，需要检查SD卡挂载状态： 12345boolean sdCard = Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED); if (!sdCard) &#123; Toast.makeText(MainActivity.this, \"SD卡未挂载\", Toast.LENGTH_SHORT).show(); MainActivity.this.finish(); &#125; 当getExternalStorageState()挂载状态返回为未挂载时，程序提示错误，并结束执行。 然后，通过Intent获取Activity当前的消息，如果第一次执行，那么Intent所get到的信息为空。此时就读取SD卡根目录文件列表。如果不是第一次执行，那么就获取上次传入的文件路径信息，然后再读取此文件路径下的文件列表。 1234567891011Intent intent = getIntent();CharSequence cs = intent.getCharSequenceExtra(\"filePath\"); //filePath 为传入的文件路径信息if (cs != null) &#123; File file = new File(cs.toString()); tvPath.setText(file.getPath()); files = file.listFiles();&#125; else &#123; File sdFile = Environment.getExternalStorageDirectory(); tvPath.setText(sdFile.getPath()); files = sdFile.listFiles();&#125;ra(\"filePath\"); 然后，在获取到了所有的文件列表信息之后，我们需要将其输入到ListView中，而ListView数据是和Adapter绑定的。Adapter的初始化原型为： SimpleAdapter(Context context, List&lt;? extends Map&lt;String, ?&gt;&gt; data, int resource, String[] from, int[] to)// context 是上下文，这里我们取MainActivity.this// data 是数据来源，是一个Map结构，最终显示Map中的Value// resource 是资源文件，根据此xml文件将ListView中内容排版// from 是数据来源的名称，为Map中的Key值// to 是将数据和resource中进行绑定id的值 根据此，我们实例化一个Map来存储最终需要显示的数据，同时新建一个资源文件/res/layout/list_layout.xml来对ListView内容进行排版： 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"horizontal\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:weightSum=\"1\"&gt; &lt;ImageView android:layout_width=\"46dp\" android:layout_height=\"45dp\" android:id=\"@+id/image\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"38dp\" android:textAppearance=\"?android:attr/textAppearanceLarge\" android:text=\"Large Text\" android:id=\"@+id/fileName\" android:layout_weight=\"0.14\" /&gt;&lt;/LinearLayout&gt; 1234567891011List&lt;HashMap&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; files.length; i++) &#123; HashMap&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;(); if (files[i].isDirectory()) &#123; hashMap.put(\"image\", android.R.drawable.ic_dialog_email); &#125; else &#123; hashMap.put(\"image\", android.R.drawable.ic_dialog_map); &#125; hashMap.put(\"fileName\", files[i].getName()); list.add(hashMap); &#125; 最后，实例化此Adapter并将ListView与其绑定，同时为ListView添加Item单击事件。如果Item是目录的话，就将目录的路径通过intent传递给Activity，然后启动此Activity。回到起始定义Intent的地方，此Intent会得到由Activity传递过来的目录信息，然后根据此目录信息可以进一步访问文件目录。 1234567891011121314151617SimpleAdapter adapter = new SimpleAdapter(MainActivity.this, list, R.layout.list_layout, new String[]&#123;\"image\", \"fileName\"&#125;, new int[]&#123;R.id.image, R.id.fileName&#125;);listView.setAdapter(adapter);listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; if (files[i].isDirectory()) &#123; File[] childFile = files[i].listFiles(); if (childFile != null &amp;&amp; childFile.length &gt;= 0) &#123; Intent intent = new Intent(MainActivity.this, MainActivity.class); intent.putExtra(\"filePath\", files[i].getPath()); Toast.makeText(MainActivity.this, files[i].getPath(), Toast.LENGTH_SHORT).show(); startActivity(intent); &#125; &#125; &#125;&#125;); 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import android.content.Intent;import android.os.Environment;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.AdapterView;import android.widget.ListView;import android.widget.SimpleAdapter;import android.widget.TextView;import android.widget.Toast; import java.io.File;import java.util.ArrayList;import java.util.HashMap;import java.util.List; public class MainActivity extends AppCompatActivity &#123; private TextView tvPath; private ListView listView; private File[] files; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tvPath = (TextView) findViewById(R.id.textView); listView = (ListView) findViewById(R.id.listView); boolean sdCard = Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED); if (!sdCard) &#123; Toast.makeText(MainActivity.this, \"SD卡未挂载\", Toast.LENGTH_SHORT).show(); MainActivity.this.finish(); &#125; Intent intent = getIntent(); CharSequence cs = intent.getCharSequenceExtra(\"filePath\"); if (cs != null) &#123; File file = new File(cs.toString()); tvPath.setText(file.getPath()); files = file.listFiles(); &#125; else &#123; File sdFile = Environment.getExternalStorageDirectory(); tvPath.setText(sdFile.getPath()); files = sdFile.listFiles(); &#125; List&lt;HashMap&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; files.length; i++) &#123; HashMap&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;(); if (files[i].isDirectory()) &#123; hashMap.put(\"image\", android.R.drawable.ic_dialog_email); &#125; else &#123; hashMap.put(\"image\", android.R.drawable.ic_dialog_map); &#125; hashMap.put(\"fileName\", files[i].getName()); list.add(hashMap); &#125; SimpleAdapter adapter = new SimpleAdapter(MainActivity.this, list, R.layout.list_layout, new String[]&#123;\"image\", \"fileName\"&#125;, new int[]&#123;R.id.image, R.id.fileName&#125;); listView.setAdapter(adapter); listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; if (files[i].isDirectory()) &#123; File[] childFile = files[i].listFiles(); if (childFile != null &amp;&amp; childFile.length &gt;= 0) &#123; Intent intent = new Intent(MainActivity.this, MainActivity.class); intent.putExtra(\"filePath\", files[i].getPath()); Toast.makeText(MainActivity.this, files[i].getPath(), Toast.LENGTH_SHORT).show(); startActivity(intent); &#125; &#125; &#125; &#125;); &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"Folder","slug":"Folder","permalink":"http://blog.duanxu.tech/tags/Folder/"}]},{"title":"Android开发手记(20) 数据存储五 网络存储","slug":"2015/2015-11-04-Android-Study-20-Data-Store-5-Network","date":"2015-11-04T14:07:00.000Z","updated":"2018-12-07T12:44:26.494Z","comments":true,"path":"2015/11/04/2015/2015-11-04-Android-Study-20-Data-Store-5-Network/","link":"","permalink":"http://blog.duanxu.tech/2015/11/04/2015/2015-11-04-Android-Study-20-Data-Store-5-Network/","excerpt":"","text":"content{:toc} Android为数据存储提供了五种方式： 1、SharedPreferences 2、文件存储 3、SQLite数据库 4、ContentProvider 5、网络存储 安卓的网络存储比较简单，因为Android提供的 Uri 和 Intent 可以帮助我们完成大多数任务。 一、发送邮件 首先，我们来看一下如何写一个发邮件的程序。前提是需要在系统邮件程序中配置好邮件发送的账户。由于发送邮件需要访问网络，所以我们需要添加如下权限： 1&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; 然后，我们添加三个TextView和三个EditText和一个Button。如图所示： 对发送按钮添加相应的点击事件即可。 1234567891011btnSend.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Uri uri = Uri.parse(\"mailto:\" + etReceiver.getText()); // 发送邮件地址 Intent intent = new Intent(Intent.ACTION_SENDTO, uri); // 创建发送邮件Intent intent.putExtra(Intent.EXTRA_SUBJECT, etSubject.getText()); // 设置邮件主题 intent.putExtra(Intent.EXTRA_TEXT, etContent.getText()); // 设置邮件内容 startActivity(intent); &#125;&#125;); 之后，单击发送按钮，就会调用系统自带的邮件程序来进行邮件的发送。 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940import android.content.Intent;import android.net.Uri;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText; public class MainActivity extends AppCompatActivity &#123; private EditText etReceiver; private EditText etSubject; private EditText etContent; private Button btnSend; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); etReceiver = (EditText) findViewById(R.id.etReceiver); etSubject = (EditText) findViewById(R.id.etSubject); etContent = (EditText) findViewById(R.id.etContent); btnSend = (Button) findViewById(R.id.btnSend); btnSend.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Uri uri = Uri.parse(\"mailto:\" + etReceiver.getText()); // 发送邮件地址 Intent intent = new Intent(Intent.ACTION_SENDTO, uri); // 创建发送邮件Intent intent.putExtra(Intent.EXTRA_SUBJECT, etSubject.getText()); // 设置邮件主题 intent.putExtra(Intent.EXTRA_TEXT, etContent.getText()); // 设置邮件内容 startActivity(intent); &#125; &#125;); &#125; &#125; 二、浏览网页 Android浏览网页可以使用WebView组件。只需要提供Url地址即可。首先建立如图所示的Activity，然后对Button添加单击事件，使其将EditText内用户输入的地址传送到WebView内即可。由于浏览网页需要访问网络，所以我们需要添加如下权限： 1&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; 需要指出的是，WebView所接受的URL必须带有类似“http://”的前缀才能正常解析，可以在编程时人工加上去。另外，我们需要覆盖WebView默认使用第三方或系统默认浏览器打开网页的行为，使网页用WebView打开。只需重载shouldOverrideUrlLoading()方法即可。此方法返回值是true的时候控制去WebView打开，为false调用系统浏览器或第三方浏览器。 12345678910111213141516171819202122232425262728293031323334353637383940import android.app.Activity;import android.os.Bundle;import android.view.View;import android.webkit.WebView;import android.webkit.WebViewClient;import android.widget.Button;import android.widget.EditText; public class MainActivity extends Activity &#123; private WebView webView; private EditText etUrl; private Button button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); webView = (WebView) findViewById(R.id.webView); etUrl = (EditText) findViewById(R.id.editText); button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; webView.loadUrl(\"http://\" + etUrl.getText().toString());//WebView加载web资源 //覆盖WebView默认使用第三方或系统默认浏览器打开网页的行为，使网页用WebView打开 webView.setWebViewClient(new WebViewClient() &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; //返回值是true的时候控制去WebView打开，为false调用系统浏览器或第三方浏览器 view.loadUrl(url); return true; &#125; &#125;); &#125; &#125;); &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"DataStore","slug":"DataStore","permalink":"http://blog.duanxu.tech/tags/DataStore/"},{"name":"Network","slug":"Network","permalink":"http://blog.duanxu.tech/tags/Network/"}]},{"title":"Android开发手记(19) 数据存储四 ContentProvider","slug":"2015/2015-11-04-Android-Study-19-Data-Store-4-ContentProvider","date":"2015-11-04T12:59:00.000Z","updated":"2018-12-07T12:44:09.127Z","comments":true,"path":"2015/11/04/2015/2015-11-04-Android-Study-19-Data-Store-4-ContentProvider/","link":"","permalink":"http://blog.duanxu.tech/2015/11/04/2015/2015-11-04-Android-Study-19-Data-Store-4-ContentProvider/","excerpt":"","text":"content{:toc} 转载自：博客园 Android为数据存储提供了五种方式： 1、SharedPreferences 2、文件存储 3、SQLite数据库 4、ContentProvider 5、网络存储 1.适用场景1.1) ContentProvider为存储和读取数据提供了统一的接口 1.2) 使用ContentProvider，应用程序可以实现数据共享 1.3) android内置的许多数据都是使用ContentProvider形式，供开发者调用的(如视频，音频，图片，通讯录等) 2.相关概念介绍2.1）ContentProvider简介 当应用继承ContentProvider类，并重写该类用于提供数据和存储数据的方法，就可以向其他应用共享其数据。虽然使用其他方法也可以对外共享数据，但数据访问方式会因数据存储的方式而不同，如：采用文件方式对外共享数据，需要进行文件操作读写数据；采用sharedpreferences共享数据，需要使用sharedpreferences API读写数据。而使用ContentProvider共享数据的好处是统一了数据访问方式。 2.2）Uri类简介1Uri uri = Uri.parse(\"content://com.changcheng.provider.contactprovider/contact\") 在Content Provider中使用的查询字符串有别于标准的SQL查询。很多诸如select, add, delete, modify等操作我们都使用一种特殊的URI来进行，这种URI由3个部分组成， “content://”, 代表数据的路径，和一个可选的标识数据的ID。以下是一些示例URI: content://media/internal/images 这个URI将返回设备上存储的所有图片content://contacts/people/ 这个URI将返回设备上的所有联系人信息content://contacts/people/45 这个URI返回单个结果（联系人信息中ID为45的联系人记录） 尽管这种查询字符串格式很常见，但是它看起来还是有点令人迷惑。为此，Android提供一系列的帮助类（在android.provider包下），里面包含了很多以类变量形式给出的查询字符串，这种方式更容易让我们理解一点，因此，如上面content://contacts/people/45这个URI就可以写成如下形式： 1Uri person = ContentUris.withAppendedId(People.CONTENT_URI, 45); 然后执行数据查询: 1Cursor cur = managedQuery(person, null, null, null); 这个查询返回一个包含所有数据字段的游标，我们可以通过迭代这个游标来获取所有的数据： 1234567891011121314151617181920212223242526272829303132package com.wissen.testApp;public class ContentProviderDemo extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); displayRecords(); &#125; private void displayRecords() &#123; //该数组中包含了所有要返回的字段 String columns[] = new String[] &#123; People.NAME, People.NUMBER &#125;; Uri mContacts = People.CONTENT_URI; Cursor cur = managedQuery( mContacts, columns, // 要返回的数据字段 null, // WHERE子句 null, // WHERE 子句的参数 null // Order-by子句 ); if (cur.moveToFirst()) &#123; String name = null; String phoneNo = null; do &#123; // 获取字段的值 name = cur.getString(cur.getColumnIndex(People.NAME)); phoneNo = cur.getString(cur.getColumnIndex(People.NUMBER)); Toast.makeText(this, name + ” ” + phoneNo, Toast.LENGTH_LONG).show(); &#125; while (cur.moveToNext()); &#125; &#125;&#125; 上例示范了一个如何依次读取联系人信息表中的指定数据列name和number。 修改记录: 我们可以使用ContentResolver.update()方法来修改数据，我们来写一个修改数据的方法: 123456private void updateRecord(int recNo, String name) &#123; Uri uri = ContentUris.withAppendedId(People.CONTENT_URI, recNo); ContentValues values = new ContentValues(); values.put(People.NAME, name); getContentResolver().update(uri, values, null, null);&#125; 现在你可以调用上面的方法来更新指定记录： 1updateRecord(10, ”XYZ”); //更改第10条记录的name字段值为“XYZ” 添加记录: 要增加记录，我们可以调用ContentResolver.insert()方法，该方法接受一个要增加的记录的目标URI，以及一个包含了新记录值的Map对象，调用后的返回值是新记录的URI，包含记录号。 上面的例子中我们都是基于联系人信息簿这个标准的Content Provider，现在我们继续来创建一个insertRecord() 方法以对联系人信息簿中进行数据的添加： 1234567891011private void insertRecords(String name, String phoneNo) &#123; ContentValues values = new ContentValues(); values.put(People.NAME, name); Uri uri = getContentResolver().insert(People.CONTENT_URI, values); Log.d(”ANDROID”, uri.toString()); Uri numberUri = Uri.withAppendedPath(uri, People.Phones.CONTENT_DIRECTORY); values.clear(); values.put(Contacts.Phones.TYPE, People.Phones.TYPE_MOBILE); values.put(People.NUMBER, phoneNo); getContentResolver().insert(numberUri, values);&#125; 这样我们就可以调用insertRecords(name, phoneNo)的方式来向联系人信息簿中添加联系人姓名和电话号码。 删除记录: Content Provider中的getContextResolver.delete()方法可以用来删除记录，下面的记录用来删除设备上所有的联系人信息： 1234private void deleteRecords() &#123; Uri uri = People.CONTENT_URI; getContentResolver().delete(uri, null, null);&#125; 你也可以指定WHERE条件语句来删除特定的记录： 1getContentResolver().delete(uri, “NAME=” + “‘XYZ XYZ’”, null); 这将会删除name为‘XYZ XYZ’的记录。 3.创建ContentProvider 要创建我们自己的Content Provider的话，我们需要遵循以下几步： a. 创建一个继承了ContentProvider父类的类 b. 定义一个名为CONTENT_URI，并且是public static final的Uri类型的类变量，你必须为其指定一个唯一的字符串值，最好的方案是以类的全名称， 如: 1public static final Uri CONTENT_URI = Uri.parse( “content://com.google.android.MyContentProvider”); c. 定义你要返回给客户端的数据列名。如果你正在使用Android数据库，必须为其定义一个叫_id的列，它用来表示每条记录的唯一性。 d. 创建你的数据存储系统。大多数Content Provider使用Android文件系统或SQLite数据库来保持数据，但是你也可以以任何你想要的方式来存储。 e. 如果你要存储字节型数据，比如位图文件等，数据列其实是一个表示实际保存文件的URI字符串，通过它来读取对应的文件数据。处理这种数据类型的Content Provider需要实现一个名为_data的字段，_data字段列出了该文件在Android文件系统上的精确路径。这个字段不仅是供客户端使用，而且也可以供ContentResolver使用。客户端可以调用ContentResolver.openOutputStream()方法来处理该URI指向的文件资源；如果是ContentResolver本身的话，由于其持有的权限比客户端要高，所以它能直接访问该数据文件。 f. 声明public static String型的变量，用于指定要从游标处返回的数据列。 g. 查询返回一个Cursor类型的对象。所有执行写操作的方法如insert(), update() 以及delete()都将被监听。我们可以通过使用ContentResover().notifyChange()方法来通知监听器关于数据更新的信息。 h. 在AndroidMenifest.xml中使用标签来设置Content Provider。 i. 如果你要处理的数据类型是一种比较新的类型，你就必须先定义一个新的MIME类型，以供ContentProvider.geType(url)来返回。MIME类型有两种形式:一种是为指定的单个记录的，还有一种是为多条记录的。这里给出一种常用的格式： vnd.android.cursor.item/vnd.yourcompanyname.contenttype （单个记录的MIME类型） 比如, 一个请求列车信息的URI如content://com.example.transportationprovider/trains/122 可能就会返回typevnd.android.cursor.item/vnd.example.rail这样一个MIME类型。 vnd.android.cursor.dir/vnd.yourcompanyname.contenttype （多个记录的MIME类型） 比如, 一个请求所有列车信息的URI如content://com.example.transportationprovider/trains 可能就会返回vnd.android.cursor.dir/vnd.example.rail这样一个MIME 类型。 下列代码将创建一个Content Provider，它仅仅是存储用户名称并显示所有的用户名称（使用 SQLLite数据库存储这些数据）： 12345678910public class MyUsers &#123; public static final String AUTHORITY = “com.wissen.MyContentProvider”; // BaseColumn类中已经包含了 _id字段 public static final class User implements BaseColumns &#123; public static final Uri CONTENT_URI = Uri.parse(”content://com.wissen.MyContentProvider”); // 表数据列 public static final String USER_NAME = “USER_NAME”; &#125;&#125; 上面的类中定义了Content Provider的CONTENT_URI，以及数据列。下面我们将定义基于上面的类来定义实际的Content Provider类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class MyContentProvider extends ContentProvider &#123; private SQLiteDatabase sqlDB; private DatabaseHelper dbHelper; private static final String DATABASE_NAME = “Users.db”; private static final int DATABASE_VERSION= 1; private static final String TABLE_NAME= “User”; private static final String TAG = “MyContentProvider”; private static class DatabaseHelper extends SQLiteOpenHelper &#123; DatabaseHelper(Context context) &#123; super(context, DATABASE_NAME, null, DATABASE_VERSION); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; //创建用于存储数据的表 db.execSQL(”Create table ” + TABLE_NAME + “( _id INTEGER PRIMARY KEY AUTOINCREMENT, USER_NAME TEXT);”); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; db.execSQL(”DROP TABLE IF EXISTS ” + TABLE_NAME); onCreate(db); &#125; &#125; @Override public int delete(Uri uri, String s, String[] as) &#123; return 0; &#125; @Override public String getType(Uri uri) &#123; return null; &#125; @Override public Uri insert(Uri uri, ContentValues contentvalues) &#123; sqlDB = dbHelper.getWritableDatabase(); long rowId = sqlDB.insert(TABLE_NAME, “”, contentvalues); if (rowId &gt; 0) &#123; Uri rowUri = ContentUris.appendId(MyUsers.User.CONTENT_URI.buildUpon(), rowId).build(); getContext().getContentResolver().notifyChange(rowUri, null); return rowUri; &#125; throw new SQLException(”Failed to insert row into ” + uri); &#125; @Override public boolean onCreate() &#123; dbHelper = new DatabaseHelper(getContext()); return (dbHelper == null) ? false : true; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; SQLiteQueryBuilder qb = new SQLiteQueryBuilder(); SQLiteDatabase db = dbHelper.getReadableDatabase(); qb.setTables(TABLE_NAME); Cursor c = qb.query(db, projection, selection, null, null, null, sortOrder); c.setNotificationUri(getContext().getContentResolver(), uri); return c; &#125; @Override public int update(Uri uri, ContentValues contentvalues, String s, String[] as) &#123; return 0; &#125;&#125; 一个名为MyContentProvider的Content Provider创建完成了，它用于从Sqlite数据库中添加和读取记录。 Content Provider的入口需要在AndroidManifest.xml中配置: 1&lt;provider android:name=”MyContentProvider” android:authorities=”com.wissen.MyContentProvider” /&gt; 之后，让我们来使用这个定义好的Content Provider: 1）为应用程序添加ContentProvider的访问权限。 2）通过getContentResolver()方法得到ContentResolver对象。 3）调用ContentResolver类的query()方法查询数据，该方法会返回一个Cursor对象。 4）对得到的Cursor对象进行分析，得到需要的数据。 5）调用Cursor类的close()方法将Cursor对象关闭。 1234567891011121314151617181920212223242526272829public class MyContentDemo extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); insertRecord(”MyUser”); displayRecords(); &#125; private void insertRecord(String userName) &#123; ContentValues values = new ContentValues(); values.put(MyUsers.User.USER_NAME, userName); getContentResolver().insert(MyUsers.User.CONTENT_URI, values); &#125; private void displayRecords() &#123; String columns[] = new String[] &#123; MyUsers.User._ID, MyUsers.User.USER_NAME &#125;; Uri myUri = MyUsers.User.CONTENT_URI; Cursor cur = managedQuery(myUri, columns,null, null, null ); if (cur.moveToFirst()) &#123; String id = null; String userName = null; do &#123; id = cur.getString(cur.getColumnIndex(MyUsers.User._ID)); userName = cur.getString(cur.getColumnIndex(MyUsers.User.USER_NAME)); Toast.makeText(this, id + ” ” + userName, Toast.LENGTH_LONG).show(); &#125; while (cur.moveToNext()); &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"DataStore","slug":"DataStore","permalink":"http://blog.duanxu.tech/tags/DataStore/"},{"name":"ContentProvider","slug":"ContentProvider","permalink":"http://blog.duanxu.tech/tags/ContentProvider/"}]},{"title":"Android开发手记(18) 数据存储三 SQLite存储数据","slug":"2015/2015-10-29-Android-Study-18-Data-Store-3-SQLite","date":"2015-10-29T13:29:00.000Z","updated":"2018-12-07T12:43:32.857Z","comments":true,"path":"2015/10/29/2015/2015-10-29-Android-Study-18-Data-Store-3-SQLite/","link":"","permalink":"http://blog.duanxu.tech/2015/10/29/2015/2015-10-29-Android-Study-18-Data-Store-3-SQLite/","excerpt":"","text":"content{:toc} Android为数据存储提供了五种方式： 1、SharedPreferences 2、文件存储 3、SQLite数据库 4、ContentProvider 5、网络存储 SQLite 是以嵌入式为目的而设计的轻型数据库，运行起来占用的资源非常低，通常只需要几百K的内存就足够了。同时也具有非常好的兼容性，支持标准SQL语言。Android提供了对SQLite的支持，我们可以通过其来管理一些应用数据。 一、创建SQLite数据库和表 我们可以通过SQLiteDatabase.openOrCreateDatabase()来创建一个数据库实例。 SQLiteDatabase db = openOrCreateDatabase(dbName, MODE_PRIVATE, null);// openOrCreateDatabase(String name, int mode, CursorFactory factory)// 第一个参数为创建数据库的名称// 第二个参数为创建数据库的权限，其权限同内部文件存储数据权限相同。默认为MODE_PRIVATE。// 第三个参数为CursorFactory对象，用于查询时返回Cursor的子类对象；或者传入null使用默认的factory构造。 在创建表的时候，我们可以使用一条SQL语句来完成。 12cmd = \"CREATE TABLE IF NOT EXISTS \" + tableName + \" (name VARCHAR, passwd VARCHAR)\";db.execSQL(cmd); 这样，我们可以发现在“/data/data/[PACKAGE_NAME]/databases”目录下生成了一个“myDB.db”数据库文件。 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839import android.database.sqlite.SQLiteDatabase;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button; public class MainActivity extends AppCompatActivity &#123; private Button btnDB; private Button btnTable; private String dbName = \"myDB\"; private String cmd = \"\"; private SQLiteDatabase db; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btnDB = (Button)findViewById(R.id.btnDB); btnTable = (Button)findViewById(R.id.btnTable); btnDB.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; db = openOrCreateDatabase(dbName,MODE_PRIVATE,null); &#125; &#125;); btnTable.setOnClickListener(new View.OnClickListener() &#123; String tableName = \"User\"; @Override public void onClick(View view) &#123; cmd = \"CREATE TABLE IF NOT EXISTS \" + tableName + \" (name VARCHAR, passwd VARCHAR)\"; db.execSQL(cmd); &#125; &#125;); &#125;&#125; 二、添加、删除、修改（2.1）SQL语句方法123456cmd = \"INSERT INTO \" + tableName + \" values ('Amy','123456')\";db.execSQL(cmd);cmd = \"UPDATE \" + tableName + \" SET passwd='654321' WHERE name='AMY')\";db.execSQL(cmd);cmd = \"DELETE FROM \" + tableName + \" WHERE name='Amy'\";db.execSQL(cmd); （2.2）另一种方法123db.insert(String table, String nullColumnHack, ContentValues values);db.update(String table, Contentvalues values, String whereClause, String whereArgs);db.delete(String table, String whereClause, String whereArgs); 以上三个方法的第一个参数都是表示要操作的表名；insert中的第二个参数表示如果插入的数据每一列都为空的话，需要指定此行中某一列的名称，系统将此列设置为NULL，不至于出现错误；insert中的第三个参数是ContentValues类型的变量，是键值对组成的Map，key代表列名，value代表该列要插入的值；update的第二个参数也很类似，只不过它是更新该字段key为最新的value值，第三个参数whereClause表示WHERE表达式，比如“age &gt; ? and age &lt; ?”等，最后的whereArgs参数是占位符的实际参数值；delete方法的参数也是一样。 实例： 1234567891011121314151617181920212223242526 btnTable.setOnClickListener(new View.OnClickListener() &#123; String tableName = \"User\"; @Override public void onClick(View view) &#123; cmd = \"CREATE TABLE IF NOT EXISTS \" + tableName + \" (name VARCHAR, passwd VARCHAR)\"; db.execSQL(cmd); ContentValues cv = new ContentValues(); cv.put(\"name\", \"Amy\"); cv.put(\"passwd\", \"123456\"); db.insert(dbName, null, cv);// cmd = \"INSERT INTO \" + tableName + \" values ('Amy','123456')\";// db.execSQL(cmd); cv = new ContentValues(); cv.put(\"passwd\", \"654321\"); db.update(dbName, cv, \"name=?\", new String[]&#123;\"Amy\"&#125;);// cmd = \"UPDATE \" + tableName + \" SET passwd='654321' WHERE name='AMY')\";// db.execSQL(cmd); db.delete(dbName, \"name=?\", new String[]&#123;\"Amy\"&#125;);// cmd = \"DELETE FROM \" + tableName + \" WHERE name='Amy'\";// db.execSQL(cmd); &#125; &#125;); 三、数据库查询 对数据库的查询可以通过db.query()来实现，query方法一般包含8个参数： db.query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit);// table为查询表的名称// columns为查询的字段名// selection为查询的条件// selectionArgs为查询条件的值// groupBy为分组字段值// having为分组后筛选条件// orderBy为排序字段名// limit为查询结果返回记录条数 查询的的结果通过Cursor返回。代表数据集的游标。 1234567891011Cursor cursor = db.query(tableName, null, null, null, null, null, null);String str = \"\";if(cursor.getCount()!=0)&#123; // 查询符合条件的记录个数 cursor.moveToFirst(); // 移动到第一个记录 for(int i=0; i&lt;cursor.getCount();i++)&#123; str += cursor.getString(0)+\" \"+cursor.getString(1)+\"\\n\"; cursor.moveToNext(); // 移动到下一个记录 &#125;&#125;new AlertDialog.Builder(MainActivity.this).setTitle(\"Query\") .setMessage(str).setNegativeButton(\"OK\",null).show(); 四、SQLiteOpenHelper 除了常规的管理方法之外，Android SDK还提供了另外一种管理数据库的方法，SQLiteOpenHelper。它提供了一套自动执行的机制来创建、更新、打开数据库。 首先，我们继承SQLiteOpenHelper类，创建MyDBHelper类。 1234567891011121314151617181920212223242526272829303132public class MyDBHelper extends SQLiteOpenHelper &#123; private String tableName = \"User\"; public MyDBHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); &#125; public void onCreate(SQLiteDatabase db) &#123; String cmd = \"CREATE TABLE IF NOT EXISTS \" + tableName + \" (name VARCHAR, passwd VARCHAR)\"; db.execSQL(cmd); &#125; public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; String cmd = \"UPDATE \" + tableName + \" SET passwd='654321' WHERE name='AMY')\"; db.execSQL(cmd); &#125; public String showTable()&#123; SQLiteDatabase db = this.getReadableDatabase(); Cursor cursor = db.query(tableName, null, null, null, null, null, null); String str = \"\"; if(cursor.getCount()!=0)&#123; // 查询符合条件的记录个数 cursor.moveToFirst(); // 移动到第一个记录 for(int i=0; i&lt;cursor.getCount();i++)&#123; str += cursor.getString(0)+\" \"+cursor.getString(1)+\"\\n\"; cursor.moveToNext(); // 移动到下一个记录 &#125; &#125; return str; &#125; &#125; 然后，我们便可以在MainActivity内使用我们定义的SQLiteOpenHelper类的方法。 123456789btnShow = (Button) findViewById(R.id.btnShow);btnShow.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; dbHelper = new MyDBHelper(MainActivity.this, dbName, null, 1); new AlertDialog.Builder(MainActivity.this).setTitle(\"MyDBHelper\") .setMessage(dbHelper.showTable()).setNegativeButton(\"OK\", null).show(); &#125;&#125;); 完整代码如下： MainActivity.java1234567891011121314151617181920212223242526272829import android.app.AlertDialog;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button; public class MainActivity extends AppCompatActivity &#123; private Button btnShow; private String dbName = \"myDB\"; private MyDBHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btnShow = (Button) findViewById(R.id.btnShow); btnShow.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; dbHelper = new MyDBHelper(MainActivity.this, dbName, null, 1); new AlertDialog.Builder(MainActivity.this).setTitle(\"MyDBHelper\") .setMessage(dbHelper.showTable()).setNegativeButton(\"OK\", null).show(); &#125; &#125;); &#125; &#125; MyDBHelper.java12345678910111213141516171819202122232425262728293031323334353637import android.content.Context;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper; public class MyDBHelper extends SQLiteOpenHelper &#123; private String tableName = \"User\"; public MyDBHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); &#125; public void onCreate(SQLiteDatabase db) &#123; String cmd = \"CREATE TABLE IF NOT EXISTS \" + tableName + \" (name VARCHAR, passwd VARCHAR)\"; db.execSQL(cmd); &#125; public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; String cmd = \"UPDATE \" + tableName + \" SET passwd='654321' WHERE name='AMY')\"; db.execSQL(cmd); &#125; public String showTable()&#123; SQLiteDatabase db = this.getReadableDatabase(); Cursor cursor = db.query(tableName, null, null, null, null, null, null); String str = \"\"; if(cursor.getCount()!=0)&#123; // 查询符合条件的记录个数 cursor.moveToFirst(); // 移动到第一个记录 for(int i=0; i&lt;cursor.getCount();i++)&#123; str += cursor.getString(0)+\" \"+cursor.getString(1)+\"\\n\"; cursor.moveToNext(); // 移动到下一个记录 &#125; &#125; return str; &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"DataStore","slug":"DataStore","permalink":"http://blog.duanxu.tech/tags/DataStore/"},{"name":"SQLite","slug":"SQLite","permalink":"http://blog.duanxu.tech/tags/SQLite/"}]},{"title":"Android开发手记(17) 数据存储二 文件存储数据","slug":"2015/2015-10-29-Android-Study-17-Data-Store-2-File","date":"2015-10-29T09:10:00.000Z","updated":"2018-12-07T12:43:26.825Z","comments":true,"path":"2015/10/29/2015/2015-10-29-Android-Study-17-Data-Store-2-File/","link":"","permalink":"http://blog.duanxu.tech/2015/10/29/2015/2015-10-29-Android-Study-17-Data-Store-2-File/","excerpt":"","text":"content{:toc} Android为数据存储提供了五种方式： 1、SharedPreferences 2、文件存储 3、SQLite数据库 4、ContentProvider 5、网络存储 本文主要介绍如何使用文件来存储数据。Android文件操作用到的是Java.IO中的FileOutputStream和FileInputStream类。 一、存储文件 首先实例化一个FileOutputStream。 FileOutputStream foStream = openFileOutput(fileName, MODE_PRIVATE);// fileName: 要写入文件的名称// MODE_PRIVATE: 为默认操作模式,代表该文件是私有数据,只能被应用本身访问,在该模式下,写入的内容会覆盖原文件的内容// MODE_APPEND: 模式会检查文件是否存在,存在就往文件追加内容,否则就创建新文件.// MODE_WORLD_READABLE: 表示当前文件可以被其他应用读取，不推荐使用// MODE_WORLD_WRITEABLE: 表示当前文件可以被其他应用写入，不推荐使用 然后调用foStream.write()即可完成写入。 123byte[] buffer = fileContent.getBytes();foStream.write(buffer);Toast.makeText(MainActivity.this, \"写入成功\",Toast.LENGTH_SHORT).show(); 最后进行一些清理工作，刷新写出流和关闭流。 12foStream.flush();foStream.close(); 二、读取文件 同样的，首先实例化一个FileInputStream。 1FileInputStream fiStream = openFileInput(fileName); 然后调用fiStream.read()即可 123int len = fiStream.available();byte[] buffer = new byte[len];fiStream.read(buffer); 最后，将文本显示并关闭读文件流 123etContent.setText(new String(buffer));Toast.makeText(MainActivity.this, \"读取成功\",Toast.LENGTH_SHORT).show();fiStream.close(); 三、完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import java.io.FileInputStream;import java.io.FileOutputStream;public class MainActivity extends AppCompatActivity &#123; private EditText etName; private EditText etContent; private Button btnWrite; private Button btnRead; private String fileName = \"\"; private String fileContent = \"\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); etName = (EditText)findViewById(R.id.etName); etContent = (EditText)findViewById(R.id.etContent); btnWrite = (Button)findViewById(R.id.btnWrite); btnRead = (Button)findViewById(R.id.btnRead); btnWrite.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; fileName = etName.getText().toString(); fileContent = etContent.getText().toString(); try &#123; FileOutputStream foStream = openFileOutput(fileName, MODE_PRIVATE); byte[] buffer = fileContent.getBytes(); foStream.write(buffer); Toast.makeText(MainActivity.this, \"写入成功\",Toast.LENGTH_SHORT).show(); foStream.flush(); foStream.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;); btnRead.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; fileName = etName.getText().toString(); try&#123; FileInputStream fiStream = openFileInput(fileName); int len = fiStream.available(); byte[] buffer = new byte[len]; fiStream.read(buffer); etContent.setText(new String(buffer)); Toast.makeText(MainActivity.this, \"读取成功\",Toast.LENGTH_SHORT).show(); fiStream.close(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; activity_main.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" android:paddingBottom=\"@dimen/activity_vertical_margin\" tools:context=\".MainActivity\"&gt; &lt;EditText android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:id=\"@+id/etName\" android:layout_alignParentTop=\"true\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:layout_alignParentRight=\"true\" android:layout_alignParentEnd=\"true\" android:text=\"文件名\" /&gt; &lt;EditText android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:id=\"@+id/etContent\" android:layout_below=\"@+id/etName\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:layout_alignParentRight=\"true\" android:layout_alignParentEnd=\"true\" android:text=\"文件内容\" /&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"保存\" android:id=\"@+id/btnWrite\" android:layout_alignTop=\"@+id/btnRead\" android:layout_toLeftOf=\"@+id/btnRead\" android:layout_toStartOf=\"@+id/btnRead\" /&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"读取\" android:id=\"@+id/btnRead\" android:layout_below=\"@+id/etContent\" android:layout_alignParentRight=\"true\" android:layout_alignParentEnd=\"true\" /&gt;&lt;/RelativeLayout&gt;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"DataStore","slug":"DataStore","permalink":"http://blog.duanxu.tech/tags/DataStore/"},{"name":"File","slug":"File","permalink":"http://blog.duanxu.tech/tags/File/"}]},{"title":"Android开发手记(16) 数据存储一 SharedPreferences","slug":"2015/2015-10-28-Android-Study-16-Data-Store-1-SharedPreferences","date":"2015-10-28T13:27:00.000Z","updated":"2018-12-07T12:43:11.550Z","comments":true,"path":"2015/10/28/2015/2015-10-28-Android-Study-16-Data-Store-1-SharedPreferences/","link":"","permalink":"http://blog.duanxu.tech/2015/10/28/2015/2015-10-28-Android-Study-16-Data-Store-1-SharedPreferences/","excerpt":"","text":"content{:toc} Android为数据存储提供了五种方式： 1、SharedPreferences 2、文件存储 3、SQLite数据库 4、ContentProvider 5、网络存储 SharedPreferences是Android中最容易理解的数据存储技术，实际上SharedPreferences处理的就是一个key-value（键值对）SharedPreferences常用来存储一些轻量级的数据。这类似于C++中Map的数据存储方式（实际上在最后生成的.xml文件内，就是以Map格式存储的）。 获取SharedPreferences的两种方式: 1、调用Context对象的getSharedPreferences()方法 2、调用Activity对象的getPreferences()方法 两种方式的区别： 调用Context对象的getSharedPreferences()方法获得的SharedPreferences对象可以被同一应用程序下的其他组件共享。 调用Activity对象的getPreferences()方法获得的SharedPreferences对象只能在该Activity中使用。 其中，getSharedPreferences()的方法原型为： getSharedPreferences(String name, int mode);// name: 生成xml文件的名称// MODE_PRIVATE: 为默认操作模式,代表该文件是私有数据,只能被应用本身访问,在该模式下,写入的内容会覆盖原文件的内容// MODE_APPEND: 模式会检查文件是否存在,存在就往文件追加内容,否则就创建新文件.// MODE_WORLD_READABLE: 表示当前文件可以被其他应用读取，不推荐使用// MODE_WORLD_WRITEABLE: 表示当前文件可以被其他应用写入，不推荐使用 使用SharedPreferences存储数据的方法如下： 123456789101112//实例化SharedPreferences对象（第一步） SharedPreferences sp = getSharedPreferences(\"test\", MODE_PRIVATE); //实例化SharedPreferences.Editor对象（第二步） SharedPreferences.Editor editor = mySharedPreferences.edit(); //用putString的方法保存数据 editor.putString(\"UserName\", etName.getText().toString());editor.putString(\"Password\", etPassword.getText().toString());//提交当前数据 //editor.apply();editor.commit(); //使用toast信息提示框提示成功写入数据 Toast.makeText(MainActivity.this, \"注册成功\", Toast.LENGTH_LONG).show(); 使用SharedPreferences读取数据的方法如下： 12345678SharedPreferences sp = getSharedPreferences(strLogInfo, MODE_APPEND);String name = sp.getString(\"UserName\", \"\");String passwd = sp.getString(\"Password\",\"\");if(etName.getText().toString().equals(name) &amp;&amp; etPassword.getText().toString().equals(passwd))&#123; Toast.makeText(MainActivity.this, \"登陆成功\", Toast.LENGTH_LONG).show();&#125; else&#123; Toast.makeText(MainActivity.this, \"登录失败\", Toast.LENGTH_LONG).show();&#125; 在使用SharedPreferences之后，程序会在“/data/data/包名/shared_prefs/xxx.xml”生成的一个XML文件。文件名取决于getSharedPreferences的第一个参数名。 12345&lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?&gt;&lt;map&gt; &lt;string name=\"UserName\"&gt;Name&lt;/string&gt; &lt;string name=\"Password\"&gt;Password&lt;/string&gt;&lt;/map&gt; 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import android.content.SharedPreferences;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; private EditText etName; private EditText etPassword; private Button btnLogin; private Button btnLogup; private String strLogInfo = \"test\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); etName = (EditText)findViewById(R.id.etName); etPassword = (EditText)findViewById(R.id.etPassword); btnLogin = (Button)findViewById(R.id.btnLogin); btnLogup = (Button)findViewById(R.id.btnLogup); btnLogup.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; SharedPreferences sp = getSharedPreferences(strLogInfo, MODE_APPEND); SharedPreferences.Editor editor = sp.edit(); editor.putString(\"UserName\", etName.getText().toString()); editor.putString(\"Password\", etPassword.getText().toString()); editor.commit(); Toast.makeText(MainActivity.this, \"注册成功\", Toast.LENGTH_LONG).show(); &#125; &#125;); btnLogin.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; SharedPreferences sp = getSharedPreferences(strLogInfo, MODE_APPEND); String name = sp.getString(\"UserName\", \"\"); String passwd = sp.getString(\"Password\",\"\"); if(etName.getText().toString().equals(name) &amp;&amp; etPassword.getText().toString().equals(passwd))&#123; Toast.makeText(MainActivity.this, \"登陆成功\", Toast.LENGTH_LONG).show(); &#125; else&#123; Toast.makeText(MainActivity.this, \"登录失败\", Toast.LENGTH_LONG).show(); &#125; &#125; &#125;); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"DataStore","slug":"DataStore","permalink":"http://blog.duanxu.tech/tags/DataStore/"},{"name":"SharedPreferences","slug":"SharedPreferences","permalink":"http://blog.duanxu.tech/tags/SharedPreferences/"}]},{"title":"Android开发手记(15) 拨打电话和收发短信","slug":"2015/2015-10-26-Android-Study-15-Phone-and-Message","date":"2015-10-26T11:35:00.000Z","updated":"2018-12-07T12:42:45.948Z","comments":true,"path":"2015/10/26/2015/2015-10-26-Android-Study-15-Phone-and-Message/","link":"","permalink":"http://blog.duanxu.tech/2015/10/26/2015/2015-10-26-Android-Study-15-Phone-and-Message/","excerpt":"","text":"content{:toc} 1、Intent简介 Android组价之间的通信，由Intent来协助完成。Intent负责对应用中一次操作的动作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将 Intent传递给调用的组件，并完成组件的调用。 Intent可以启动一个Activity，也可以启动一个Service，还可以发起一个广播Broadcasts。分别通过startActivity();startService();startBroadcasts();来执行操作。 在使用Android的电话功能的时候，我们需要调用Intent的相关功能来实现拨打电话和收发短信。 2、URI URI是统一资源标识符（Uniform Resource Identifier）的缩写。是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对任何（包括本地和互联网）的资源通过特定的协议进行交互操作。URI由包括确定语法和相关协议的方案所定义。在Android中URI的意义非常重大，他是所有资源的标示符（ID），通过URI可找到一个对应的具体实体，如文件(file)，数据库的表项(content)等，可以说贯穿整个Framework。 URI一般的格式为：[scheme:]schemeSpecificPart[#fragment] ([…]表示可选) 3、拨打电话 直接拨打电话需要添加android.permission.CALL_PHONE权限，在AndroidManifest.xml中添加如下代码： 1&lt;uses-permission android:name=\"android.permission.CALL_PHONE\"/&gt; 完整代码为： 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.doodle.button\" &gt; &lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:theme=\"@style/AppTheme\" &gt; &lt;activity android:name=\".MainActivity\" android:label=\"@string/app_name\" &gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;uses-permission android:name=\"android.permission.CALL_PHONE\"/&gt;&lt;/manifest&gt; 然后，我们实例化一个Uri，其内容为要拨打电话的命令。电话号码通过TextView获得。然后我们实例化一个Intent，设置Intent的行为为“直接拨打电话”，Intent的数据为“拨打XXX电话命令”。 1234Uri uri = Uri.parse(\"tel:\" + tvPhone.getText());Intent intent = new Intent();intent.setAction(Intent.ACTION_CALL);intent.setData(uri); 然后为拨打电话按钮添加此单击事件即可 12345678910btnDriect.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Uri uri = Uri.parse(\"tel:\" + tvPhone.getText()); Intent intent = new Intent(); intent.setAction(Intent.ACTION_CALL); intent.setData(uri); startActivity(intent); &#125;&#125;); 同理，我们可以通过Intent来启动系统自带的拨号器。启动系统自带的拨号器是不需要android.permission.CALL_PHONE权限的。 12345678btnSystem.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Uri uri = Uri.parse(\"tel:\" + tvPhone.getText()); Intent intent = new Intent(Intent.ACTION_DIAL, uri); startActivity(intent); &#125;&#125;); 4、发送短信 同拨打电话一样，发送短信同样需要相应的权限。 1&lt;uses-permission android:name=\"android.permission.SEND_SMS\"/&gt; 不同的是，我们在发送短信的时候是通过SmsManager来完成发送的。首先我们要实例化一个SmsManager。通过SmsManager.sendTextMessage()方法可以进行短信发送。其原型为： sendTextMessage(String destAddr, String scAddr, String text, PendingIntent sentIntent, PendingIntent deliveryIntent);// destAddress 发送短信的地址（也就是号码）// scAddress 短信服务中心，如果为null，就是用当前默认的短信服务中心// text 短信内容// sentIntent 如果不为null，当短信发送成功或者失败时，这个PendingIntent会被广播出去成功的结果代码是Activity.RESULT_OK// deliveryIntent 如果不为null，当这个短信发送到接收者那里，这个PendtingIntent会被广播，状态报告生成的pdu（指对等层次之间传递的数据单位）会拓展到数据（”pdu”） 这里我们需要实例化一个PendingIntent来协助SMSManger的工作。 SmsManager smsManager = SmsManager.getDefault();PendingIntent pendingIntent = PendingIntent.getBroadcast(MainActivity.this, 0, new Intent(), 0);smsManager.sendTextMessage(strAddr, null, strCont, pendingIntent, null); 12345678910111213141516171819btnSend.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; String strAddr = etPhone.getText().toString(); String strCont = etContent.getText().toString(); if (strAddr.equals(\"\")) &#123; Toast.makeText(MainActivity.this, \"收件人不能为空\", Toast.LENGTH_SHORT).show(); &#125; if (strCont.equals(\"\")) &#123; Toast.makeText(MainActivity.this, \"短信内容不能为空\", Toast.LENGTH_SHORT).show(); &#125; SmsManager smsManager = SmsManager.getDefault(); PendingIntent pendingIntent = PendingIntent.getBroadcast(MainActivity.this, 0, new Intent(), 0); smsManager.sendTextMessage(strAddr, null, strCont, pendingIntent, null); Toast.makeText(MainActivity.this, \"短信发送成功\",Toast.LENGTH_LONG).show(); &#125;&#125;); 完整代码为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import android.app.PendingIntent;import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.telephony.SmsManager;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; private EditText etPhone; private EditText etContent; private Button btnSend; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); etPhone = (EditText) findViewById(R.id.etPhone); etContent = (EditText) findViewById(R.id.etContent); btnSend = (Button) findViewById(R.id.btnSend); btnSend.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; String strAddr = etPhone.getText().toString(); String strCont = etContent.getText().toString(); if (strAddr.equals(\"\")) &#123; Toast.makeText(MainActivity.this, \"收件人不能为空\", Toast.LENGTH_SHORT).show(); &#125; if (strCont.equals(\"\")) &#123; Toast.makeText(MainActivity.this, \"短信内容不能为空\", Toast.LENGTH_SHORT).show(); &#125; SmsManager smsManager = SmsManager.getDefault(); PendingIntent pendingIntent = PendingIntent.getBroadcast(MainActivity.this, 0, new Intent(), 0); smsManager.sendTextMessage(strAddr, null, strCont, pendingIntent, null); Toast.makeText(MainActivity.this, \"短信发送成功\",Toast.LENGTH_LONG).show(); &#125; &#125;); &#125;&#125; 5、接收短信 同拨打电话一样，发送短信同样需要相应的权限。接收短信需要 1&lt;uses-permission android:name=\"android.permission.RECEIVE_SMS\"/&gt; 接收短信的原理是，首先新建一个BroadcastReceiver来监听短信信息，然后根据监听到的广播信息中的短信进行捕捉，然后呈现出来。 首先，新建一个Receiver类，然后重载其onReceive方法。 12345678910public class Receiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (intent.getAction().equals(\"android.provider.Telephony.SMS_RECEIVED\")) &#123; &#125; &#125;&#125; 然后，我们新建一个Budle来接收信息，我们知道，短信信息的关键字为”pdus”，所以通过一个Object[]来接收此信息，然后再将其转化为SmsMessage即可。 由于接收到的短信由于长度原因，可能被分割成若干条信息，所以，我们通过一个for循环来处理此短信。 123456789101112131415161718if (intent.getAction().equals(\"android.provider.Telephony.SMS_RECEIVED\")) &#123; StringBuilder str = new StringBuilder(); Bundle bundle = intent.getExtras(); if (bundle != null) &#123; Object[] pdus = (Object[]) bundle.get(\"pdus\"); SmsMessage[] msg = new SmsMessage[pdus.length]; for (int i = 0; i &lt; pdus.length; i++) &#123; msg[i] = SmsMessage.createFromPdu((byte[]) pdus[i]); &#125; for (SmsMessage m : msg) &#123; str.append(\"发件人：\"); str.append(m.getDisplayOriginatingAddress()); str.append(\"\\n内容:\"); str.append(m.getDisplayMessageBody()); &#125; Toast.makeText(context, \"收到消息：\\n\" + str, Toast.LENGTH_LONG); &#125;&#125; 最后在AndroidManifest.xml中处理一下新建的Receiver类即可。 完整代码： AndroidMainfest.xml123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.doodle.button\" &gt; &lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:theme=\"@style/AppTheme\" &gt; &lt;activity android:name=\".MainActivity\" android:label=\"@string/app_name\" &gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;receiver android:name=\".Receiver\" android:enabled=\"true\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.provider.Telephony.SMS_RECEIVED\"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;/application&gt; &lt;uses-permission android:name=\"android.permission.SEND_SMS\"/&gt; &lt;uses-permission android:name=\"android.permission.RECEIVE_SMS\"/&gt;&lt;/manifest&gt; MainActivity.java123456789101112import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; Receiver.java12345678910111213141516171819202122232425262728293031import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.telephony.SmsMessage;import android.widget.Toast;public class Receiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (intent.getAction().equals(\"android.provider.Telephony.SMS_RECEIVED\")) &#123; StringBuilder str = new StringBuilder(); Bundle bundle = intent.getExtras(); if (bundle != null) &#123; Object[] pdus = (Object[]) bundle.get(\"pdus\"); SmsMessage[] msg = new SmsMessage[pdus.length]; for (int i = 0; i &lt; pdus.length; i++) &#123; msg[i] = SmsMessage.createFromPdu((byte[]) pdus[i]); &#125; for (SmsMessage m : msg) &#123; str.append(\"发件人：\"); str.append(m.getDisplayOriginatingAddress()); str.append(\"\\n内容:\"); str.append(m.getDisplayMessageBody()); &#125; Toast.makeText(context, \"收到消息：\\n\" + str, Toast.LENGTH_LONG); &#125; &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"Phone","slug":"Phone","permalink":"http://blog.duanxu.tech/tags/Phone/"},{"name":"Message","slug":"Message","permalink":"http://blog.duanxu.tech/tags/Message/"}]},{"title":"Android开发手记(14) 使用MediaPlayer播放mp3","slug":"2015/2015-10-22-Android-Study-14-MediaPlayer","date":"2015-10-22T02:28:00.000Z","updated":"2018-12-07T12:42:20.603Z","comments":true,"path":"2015/10/22/2015/2015-10-22-Android-Study-14-MediaPlayer/","link":"","permalink":"http://blog.duanxu.tech/2015/10/22/2015/2015-10-22-Android-Study-14-MediaPlayer/","excerpt":"","text":"content{:toc} 1、获取MediaPlayer实例（1.1）可以直接通过new或者create方式： 调用setDataSource和create的区别是，create时已经执行了MediaPlayer.prepare()，而setDataSource需要手动执行。 123MediaPlayer mPlayer = new MediaPlayer();mPlayer.setDataSource();MediaPlayer mPlayer = MediaPlayer.create(); （1.2）获取用户事先导入到/res的资源文件12private MediaPlayer mPlayer;mPlayer = MediaPlayer.create(this, R.raw.leessang); （1.3）获取存储在SD卡或者其他路径下的文件12MediaPlayer mPlayer = new MediaPlayer();mPlayer.setDataSource(\"/sdcard/leesang.mp3\"); （1.4）获取网络媒体文件12MediaPlayer mPlayer = new MediaPlayer();mPlayer.setDataSource(\"http://www.xxxx.com/yyyy.mp3\"); 2、播放、暂停 对于通过create调用的媒体，无需在播放时调用prepare方法，而对于通过new创建的媒体，则需要调用一次prepare方法才可完成start的启动。 12345678910111213141516171819 btnStart.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; try &#123; if (mPlayer != null) &#123; if (mPlayer.isPlaying()) &#123; mPlayer.pause(); btnStart.setText(\"播放\"); &#125; else &#123;// mPlayer.prepare(); mPlayer.start(); btnStart.setText(\"暂停\"); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); 3、停止播放 当Mediaplayer对象在播放时，可以进行暂停和停止操作，pause方法暂停播放，stop方法停止播放。处于暂停暂停时可通过start方法恢复播放，但是处于停止状态时则必须先调用prepare方法使其处于准备状态，再调用start方法。 123456789101112131415btnStop.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; try &#123; if (mPlayer != null) &#123; mPlayer.stop(); seekBar.setProgress(mPlayer.getCurrentPosition()); btnStart.setText(\"播放\"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;); 4、通过SeekBar控制播放进度 通过MediaPlayer.getDuration()可以得到媒体文件的长度（单位毫秒），可以将此作为SeekBar的最大值。 通过MediaPlayer.seekTo(int i)可以定位媒体文件的任意位置（单位毫秒），mPlayer.seekTo(seekBar.getProgress()); 1234567891011121314151617seekBar.setMax(mPlayer.getDuration());seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; @Override public void onProgressChanged(SeekBar seekBar, int i, boolean b) &#123; &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; mPlayer.seekTo(seekBar.getProgress()); &#125;&#125;); 5、将播放时间反馈给SeekBar 由于Android没有提供播放时间反馈方法，所以只能使用定时器或者线程来进行播放反馈。即每隔一定时间来检查播放进度，按照此进度来调节SeekBar。 12345678mTimer = new Timer();mTimerTask = new TimerTask() &#123; @Override public void run() &#123; seekBar.setProgress(mPlayer.getCurrentPosition()); &#125;&#125;;mTimer.schedule(mTimerTask, 0, 10); 6、小结 此处转载自博客园 android Mediaplayer各种属性和方法简单介绍（1） 当一个MediaPlayer对象被创建或者调用 reset() 方法之后，它处于空闲状态，调用 release() 方法后处于结束状态 1、一个MediaPlayer对象调用了 reset() 方法后，再调用其它方法可能会触发 OnErrorListener.onError() 事件，未调用 reset() 方法则不会触发 2、当Mediaplayer对象不再被使用时，最好调用 release() 方法对其进行释放，使其处于结束状态，此时它不能被使用 3、Mediaplayer对象被创建时（调用构造方法）处于空闲状态，若使用 create() 方法创建后则处于准备状态。（2） 一般情况下，一些常用的播放控制操作可能因为音频、视频的格式不被支持或者质量较差以及流超时，也有可能由于开发者的疏忽使得Mediaplayer对象处于无效状态等而导致错误。此时可通过注册setOnErrorListener方法实现监控。如果发生了错误，Mediaplayer对象将处于多雾状态，可以使用 reset() 方法来恢复错误。（3） 任何Mediaplayer对象都必须先处于准备状态，然后才开始播放（4） 要开始播放Mediaplayer对象都必须成功调用 start() 方法，可通过 isPlaying() 方法来检测是否正在播放（5） 当Mediaplayer对象在播放时，可以进行暂停和停止操作， pause() 方法暂停播放， stop() 方法停止播放。处于暂停暂停时可通过 start() 方法恢复播放，但是处于停止状态时则必须先调用 prepare() 方法使其处于准备状态，再调用 start() 方法。 7、完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import android.media.MediaPlayer;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.SeekBar;import android.widget.TextView;import java.util.Timer;import java.util.TimerTask;public class MainActivity extends AppCompatActivity &#123; private Button btnStart; private Button btnStop; private TextView textView; private MediaPlayer mPlayer; private SeekBar seekBar; private Timer mTimer; private TimerTask mTimerTask; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mPlayer = MediaPlayer.create(this, R.raw.leessang); textView = (TextView) findViewById(R.id.textView); textView.setText(\"MP3播放器\"); btnStart = (Button) findViewById(R.id.btnStart); btnStop = (Button) findViewById(R.id.btnStop); seekBar = (SeekBar) findViewById(R.id.seekBar); mPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() &#123; @Override public void onCompletion(MediaPlayer mediaPlayer) &#123; btnStart.setText(\"播放\"); mPlayer.seekTo(0); seekBar.setProgress(0); &#125; &#125;); mTimer = new Timer(); mTimerTask = new TimerTask() &#123; @Override public void run() &#123; seekBar.setProgress(mPlayer.getCurrentPosition()); &#125; &#125;; mTimer.schedule(mTimerTask, 0, 10); seekBar.setMax(mPlayer.getDuration()); seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; @Override public void onProgressChanged(SeekBar seekBar, int i, boolean b) &#123; &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; mPlayer.seekTo(seekBar.getProgress()); &#125; &#125;); btnStart.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; try &#123; if (mPlayer != null) &#123; if (mPlayer.isPlaying()) &#123; mPlayer.pause(); btnStart.setText(\"播放\"); &#125; else &#123;// mPlayer.prepare(); mPlayer.start(); btnStart.setText(\"暂停\"); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); btnStop.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; try &#123; if (mPlayer != null) &#123; mPlayer.stop(); seekBar.setProgress(mPlayer.getCurrentPosition()); btnStart.setText(\"播放\"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"MediaPlayer","slug":"MediaPlayer","permalink":"http://blog.duanxu.tech/tags/MediaPlayer/"}]},{"title":"Android开发手记(13) 几种Alertdialog的使用","slug":"2015/2015-10-20-Android-Study-13-AlertDialog","date":"2015-10-20T13:27:00.000Z","updated":"2018-12-07T12:41:56.005Z","comments":true,"path":"2015/10/20/2015/2015-10-20-Android-Study-13-AlertDialog/","link":"","permalink":"http://blog.duanxu.tech/2015/10/20/2015/2015-10-20-Android-Study-13-AlertDialog/","excerpt":"","text":"content{:toc} 本文主要讨论七种形式的AlertDialog，及其编写方法。 1、退出 在用户退出的时候提示用户是否退出，含有“确定”和“退出”两个按键。 12345678910111213141516btnExit.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; final AlertDialog.Builder alertDlg = new AlertDialog.Builder(MainActivity.this); alertDlg.setMessage(\"确定退出吗？\"); alertDlg.setTitle(\"退出\"); alertDlg.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; MainActivity.this.finish(); &#125; &#125;); alertDlg.setNegativeButton(\"取消\", null); alertDlg.show(); &#125;&#125;); 2、调查图表 弹出对话框，让用户选择相应的按钮来获得用户选项。含有相应的提示问题。 12345678910111213141516171819202122232425262728btnChart.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; AlertDialog.Builder alertDlg = new AlertDialog.Builder(MainActivity.this); alertDlg.setIcon(android.R.drawable.btn_star); alertDlg.setTitle(\"调查\"); alertDlg.setMessage(\"你喜欢的颜色是？\"); alertDlg.setPositiveButton(\"红色\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(MainActivity.this, \"你喜欢红色\", Toast.LENGTH_SHORT); &#125; &#125;); alertDlg.setNegativeButton(\"蓝色\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(MainActivity.this, \"你喜欢蓝色\", Toast.LENGTH_SHORT); &#125; &#125;); alertDlg.setNeutralButton(\"黄色\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(MainActivity.this, \"你喜欢黄色\", Toast.LENGTH_SHORT); &#125; &#125;); alertDlg.show(); &#125;&#125;); 3、输入内容 弹出对话框，提示用户输入用户名或者密码，可以作登陆使用。 1234567891011btnContent.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; AlertDialog.Builder alertDlg = new AlertDialog.Builder(MainActivity.this); alertDlg.setTitle(\"请输入\"); alertDlg.setIcon(android.R.drawable.ic_dialog_info); alertDlg.setView(new EditText(MainActivity.this)).setPositiveButton(\"确定\", null); alertDlg.setNegativeButton(\"取消\", null); alertDlg.show(); &#125;&#125;); 4、单选按钮 对话框内含有一系列单选按钮让用户选择。 12345678910btnRadio.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; new AlertDialog.Builder(MainActivity.this).setTitle(\"单选框\") .setIcon(android.R.drawable.ic_dialog_info) .setSingleChoiceItems(new String[]&#123;\"红色\", \"蓝色\", \"黄色\"&#125;, 0, null) .setPositiveButton(\"确定\", null) .setNegativeButton(\"取消\", null).show(); &#125;&#125;); 5、多选按钮 对话框内含有一系列多选按钮让用户选择。 12345678910btnCheckBox.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; new AlertDialog.Builder(MainActivity.this).setTitle(\"复选框\") .setIcon(android.R.drawable.ic_dialog_info) .setMultiChoiceItems(new String[]&#123;\"红色\", \"蓝色\", \"黄色\"&#125;, null, null) .setPositiveButton(\"确定\", null) .setNegativeButton(\"取消\", null).show(); &#125;&#125;); 6、简单列表 含有一系列简单的列表，供用户点击，可以做菜单使用。 12345678910btnList.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; new AlertDialog.Builder(MainActivity.this).setTitle(\"列表框\") .setIcon(android.R.drawable.ic_dialog_info) .setItems(new String[]&#123;\"红色\", \"蓝色\", \"黄色\"&#125;, null) .setPositiveButton(\"确定\", null) .setNegativeButton(\"取消\", null).show(); &#125;&#125;); 7、自定义布局 可以自定义对话框显示内容，通过资源文件导入布局。 12345678910111213btnCostume.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; LayoutInflater inflater = getLayoutInflater(); View layout = inflater.inflate(R.layout.activity_main, (ViewGroup)findViewById(R.id.mainMenu)); new AlertDialog.Builder(MainActivity.this).setTitle(\"自定义布局\") .setView(layout) .setPositiveButton(\"确定\", null) .setNegativeButton(\"取消\", null).show(); &#125;&#125;); 8、完整代码： 可以自定义对话框显示内容，通过资源文件导入布局。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144import android.app.AlertDialog;import android.app.Dialog;import android.content.DialogInterface;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; private Button btnExit; private Button btnChart; private Button btnContent; private Button btnRadio; private Button btnCheckBox; private Button btnList; private Button btnCostume; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btnExit = (Button)findViewById(R.id.btnExit); btnChart = (Button)findViewById(R.id.btnChart); btnContent = (Button)findViewById(R.id.btnContent); btnRadio = (Button)findViewById(R.id.btnRadio); btnCheckBox = (Button)findViewById(R.id.btnCheckBox); btnList = (Button)findViewById(R.id.btnList); btnCostume = (Button)findViewById(R.id.btnCostume); btnExit.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; final AlertDialog.Builder alertDlg = new AlertDialog.Builder(MainActivity.this); alertDlg.setMessage(\"确定退出吗？\"); alertDlg.setTitle(\"退出\"); alertDlg.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; MainActivity.this.finish(); &#125; &#125;); alertDlg.setNegativeButton(\"取消\", null); alertDlg.show(); &#125; &#125;); btnChart.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; AlertDialog.Builder alertDlg = new AlertDialog.Builder(MainActivity.this); alertDlg.setIcon(android.R.drawable.btn_star); alertDlg.setTitle(\"调查\"); alertDlg.setMessage(\"你喜欢的颜色是？\"); alertDlg.setPositiveButton(\"红色\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(MainActivity.this, \"你喜欢红色\", Toast.LENGTH_SHORT); &#125; &#125;); alertDlg.setNegativeButton(\"蓝色\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(MainActivity.this, \"你喜欢蓝色\", Toast.LENGTH_SHORT); &#125; &#125;); alertDlg.setNeutralButton(\"黄色\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; Toast.makeText(MainActivity.this, \"你喜欢黄色\", Toast.LENGTH_SHORT); &#125; &#125;); alertDlg.show(); &#125; &#125;); btnContent.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; AlertDialog.Builder alertDlg = new AlertDialog.Builder(MainActivity.this); alertDlg.setTitle(\"请输入\"); alertDlg.setIcon(android.R.drawable.ic_dialog_info); alertDlg.setView(new EditText(MainActivity.this)).setPositiveButton(\"确定\", null); alertDlg.setNegativeButton(\"取消\", null); alertDlg.show(); &#125; &#125;); btnRadio.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; new AlertDialog.Builder(MainActivity.this).setTitle(\"单选框\") .setIcon(android.R.drawable.ic_dialog_info) .setSingleChoiceItems(new String[]&#123;\"红色\", \"蓝色\", \"黄色\"&#125;, 0, null) .setPositiveButton(\"确定\", null) .setNegativeButton(\"取消\", null).show(); &#125; &#125;); btnCheckBox.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; new AlertDialog.Builder(MainActivity.this).setTitle(\"复选框\") .setIcon(android.R.drawable.ic_dialog_info) .setMultiChoiceItems(new String[]&#123;\"红色\", \"蓝色\", \"黄色\"&#125;, null, null) .setPositiveButton(\"确定\", null) .setNegativeButton(\"取消\", null).show(); &#125; &#125;); btnList.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; new AlertDialog.Builder(MainActivity.this).setTitle(\"列表框\") .setIcon(android.R.drawable.ic_dialog_info) .setItems(new String[]&#123;\"红色\", \"蓝色\", \"黄色\"&#125;, null) .setPositiveButton(\"确定\", null) .setNegativeButton(\"取消\", null).show(); &#125; &#125;); btnCostume.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; LayoutInflater inflater = getLayoutInflater(); View layout = inflater.inflate(R.layout.activity_main, (ViewGroup)findViewById(R.id.mainMenu)); new AlertDialog.Builder(MainActivity.this).setTitle(\"自定义布局\") .setView(layout) .setPositiveButton(\"确定\", null) .setNegativeButton(\"取消\", null).show(); &#125; &#125;); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"Alertdialog","slug":"Alertdialog","permalink":"http://blog.duanxu.tech/tags/Alertdialog/"}]},{"title":"Android开发手记(12) Menu的使用","slug":"2015/2015-10-20-Android-Study-12-Menu","date":"2015-10-20T11:25:00.000Z","updated":"2018-12-07T12:41:39.435Z","comments":true,"path":"2015/10/20/2015/2015-10-20-Android-Study-12-Menu/","link":"","permalink":"http://blog.duanxu.tech/2015/10/20/2015/2015-10-20-Android-Study-12-Menu/","excerpt":"","text":"content{:toc} Android中的Menu分为三种，分别为：OptionsMenu（选项菜单）、ContextMenu（上下文菜单）、SubMenu（子菜单）。 1、OptionsMenu 按Menu键就会显示，用于当前的Activity。 在Activity里面，一般通过以下函数来使用options menu： Activity::onCreateOptionsMenu (Menu menu) 创建options menu，这个函数只会在menu第一次显示时调用。 Activity::onPrepareOptionsMenu (Menu menu) 更新改变options menu的内容，这个函数会在menu每次显示时调用。 Activity::onOptionsItemSelected (MenuItem item) 处理选中的菜单项。 12345678910111213//menu.add(groupId, itemId, order, title); 通过add()增加menuItem，每个menuItem有groupId，itemId，Order。这三个属性是相互独立，没有关联。 MenuItem redMenu = menu.add(MENU_GROUP_1, 0, 0, \"Red\"); MenuItem OrangedMenu = menu.add(MENU_GROUP_1, 1, 1, \"Orange\"); MenuItem YellowMenu = menu.add(MENU_GROUP_2, 2, 2, \"Yellow\"); MenuItem GreenMenu = menu.add(MENU_GROUP_2, 3, 3, \"Green\"); MenuItem BlueMenu = menu.add(MENU_GROUP_2, 4, 4, \"Blue\"); MenuItem CyangonMenu = menu.add(MENU_GROUP_3, 5, 5, \"Cyangon\"); MenuItem PurpleMenu = menu.add(MENU_GROUP_3, 6, 6, \"Purple\"); menu.setGroupCheckable(MENU_GROUP_2, true /*isCheckable*/, false);//第三个参数true为单选，false为多选 menu.setGroupEnabled(MENU_GROUP_2, true/*isEnabled*/); menu.setGroupVisible(MENU_GROUP_2, true/*isVisible*/); menu.setGroupCheckable(MENU_GROUP_3, true, true); 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; private static int MENU_GROUP_1 = 1; private static int MENU_GROUP_2 = 2; private static int MENU_GROUP_3 = 3; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; MenuItem redMenu = menu.add(MENU_GROUP_1, 0, 0, \"Red\"); MenuItem OrangedMenu = menu.add(MENU_GROUP_1, 1, 1, \"Orange\"); MenuItem YellowMenu = menu.add(MENU_GROUP_2, 2, 2, \"Yellow\"); MenuItem GreenMenu = menu.add(MENU_GROUP_2, 3, 3, \"Green\"); MenuItem BlueMenu = menu.add(MENU_GROUP_2, 4, 4, \"Blue\"); MenuItem CyangonMenu = menu.add(MENU_GROUP_3, 5, 5, \"Cyangon\"); MenuItem PurpleMenu = menu.add(MENU_GROUP_3, 6, 6, \"Purple\"); menu.setGroupCheckable(MENU_GROUP_2, true /*isCheckable*/, false);//第三个参数true为单选，false为多选 menu.setGroupEnabled(MENU_GROUP_2, true/*isEnabled*/); menu.setGroupVisible(MENU_GROUP_2, true/*isVisible*/); menu.setGroupCheckable(MENU_GROUP_3, true, true); return super.onCreateOptionsMenu(menu); &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; super.onOptionsItemSelected(item); switch (item.getItemId()) &#123; case 0: Toast.makeText(this, \"Red\", Toast.LENGTH_SHORT).show(); break; case 1: Toast.makeText(this, \"Orange\", Toast.LENGTH_SHORT).show(); break; case 2: if(item.isCheckable())&#123; item.setChecked(!item.isChecked()); &#125; break; case 3: if(item.isCheckable())&#123; item.setChecked(!item.isChecked()); &#125; break; case 4: if(item.isCheckable())&#123; item.setChecked(!item.isChecked()); &#125; break; case 5: if(item.isCheckable())&#123; item.setChecked(true); &#125; break; case 6: if(item.isCheckable())&#123; item.setChecked(true); &#125; break; &#125; return true; &#125;&#125; 2、ContextMenu 要在相应的view上按几秒后才显示的，用于view，跟某个具体的view绑定在一起。这类型的菜单不支持icon和快捷键！ 在Activity里面，一般通过以下函数来使用context menu： Activity::registerForContextMenu(View view) 为某个view注册context menu，一般在Activity::onCreate里面调用。 Activity::onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) 创建context menu，和options menu不同，context meun每次显示时都会调用这个函数。 Activity::onContextItemSelected(MenuItem item) 处理选中的菜单项。 1234menu.setHeaderTitle(\"ContextMenu\");menu.add(GROUP_COLOR, 0, 0, \"Red\");menu.add(GROUP_COLOR, 1, 1, \"Green\");menu.add(GROUP_COLOR, 2, 2, \"Blue\"); 菜单响应事件处理和OptionMenu类似。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MainActivity extends AppCompatActivity &#123; private TextView colorText; private static int GROUP_COLOR = 1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); colorText = (TextView) findViewById(R.id.textView); registerForContextMenu(colorText); &#125; @Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) &#123; super.onCreateContextMenu(menu, v, menuInfo); menu.setHeaderTitle(\"ContextMenu\"); menu.add(GROUP_COLOR, 0, 0, \"Red\"); menu.add(GROUP_COLOR, 1, 1, \"Green\"); menu.add(GROUP_COLOR, 2, 2, \"Blue\"); &#125; @Override public boolean onContextItemSelected(MenuItem item) &#123; super.onContextItemSelected(item); switch (item.getItemId()) &#123; case 0: colorText.setTextColor(Color.RED); break; case 1: colorText.setTextColor(Color.GREEN); break; case 2: colorText.setTextColor( Color.BLUE); break; &#125; return true; &#125;&#125; 3、SubMenu SubMenu可以和OptionMenu、ContextMenu配合使用，但子菜单不能嵌套子菜单，这意味着在Android系统，菜单只有两层。同时子菜单不支持icon。 可以在onCreateOptionMenu或者onCreateContextMenu内定义SubMenu： 12345678910111213@Overridepublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) &#123; super.onCreateContextMenu(menu, v, menuInfo); menu.setHeaderTitle(\"ContextMenu\"); menu.add(GROUP_COLOR, 0, 0, \"Red\"); menu.add(GROUP_COLOR, 1, 1, \"Green\"); menu.add(GROUP_COLOR, 2, 2, \"Blue\"); SubMenu subMenu = menu.addSubMenu(Menu.NONE, 10, 10, \"Text Size\"); subMenu.add(Menu.NONE, 11, 11, \"Large\"); subMenu.add(Menu.NONE, 12, 12, \"Small\");&#125; 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import android.graphics.Color;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.ContextMenu;import android.view.Menu;import android.view.MenuItem;import android.view.SubMenu;import android.view.View;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; private TextView colorText; private static int GROUP_COLOR = 1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); colorText = (TextView) findViewById(R.id.textView); registerForContextMenu(colorText); &#125; @Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) &#123; super.onCreateContextMenu(menu, v, menuInfo); menu.setHeaderTitle(\"ContextMenu\"); menu.add(GROUP_COLOR, 0, 0, \"Red\"); menu.add(GROUP_COLOR, 1, 1, \"Green\"); menu.add(GROUP_COLOR, 2, 2, \"Blue\"); SubMenu subMenu = menu.addSubMenu(Menu.NONE, 10, 10, \"Text Size\"); subMenu.add(Menu.NONE, 11, 11, \"Large\"); subMenu.add(Menu.NONE, 12, 12, \"Small\"); &#125; @Override public boolean onContextItemSelected(MenuItem item) &#123; super.onContextItemSelected(item); switch (item.getItemId()) &#123; case 0: colorText.setTextColor(Color.RED); break; case 1: colorText.setTextColor(Color.GREEN); break; case 2: colorText.setTextColor( Color.BLUE); break; case 11: colorText.setTextSize(30); break; case 12: colorText.setTextSize(20); break; &#125; return true; &#125;&#125; 4、XML定义菜单 首先在/res/menu新建一个menu_main.xml，在其中定义相关Menu 12345678910111213141516171819202122232425262728293031&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" tools:context=\".MainActivity\"&gt; &lt;item android:id=\"@+id/subMenu\" android:title=\"SubMenu\" &gt; &lt;menu&gt; &lt;!--定义子菜单--&gt; &lt;item android:id=\"@+id/subLarge\" android:title=\"Large\"/&gt; &lt;item android:id=\"@+id/subSmall\" android:title=\"Small\"/&gt; &lt;/menu&gt; &lt;/item&gt; &lt;!--定义菜单组1--&gt; &lt;group android:id=\"@+id/group1\" android:checkableBehavior=\"single\" android:enabled=\"true\"&gt; &lt;item android:id=\"@+id/redMenu\" android:title=\"Red\"/&gt; &lt;item android:id=\"@+id/blueMenu\" android:title=\"Blue\"/&gt; &lt;/group&gt; &lt;!--定义菜单组2--&gt; &lt;group android:id=\"@+id/group2\" android:checkableBehavior=\"all\" android:enabled=\"true\"&gt; &lt;item android:id=\"@+id/greenMenu\" android:title=\"Green\"/&gt; &lt;item android:id=\"@+id/purpleMenu\" android:title=\"Purple\"/&gt; &lt;/group&gt;&lt;/menu&gt; （4.1）XML定义OptionsMenu 重载onCreateOptionsMenu即可： 123456@Overridepublic boolean onCreateOptionsMenu(Menu menu)&#123; MenuInflater menuInflater = new MenuInflater(getApplication()); menuInflater.inflate(R.menu.menu_main, menu); return super.onCreateOptionsMenu(menu);&#125; 完整代码为： 123456789101112131415161718192021222324import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.Menu;import android.view.MenuInflater;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; private TextView colorText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; @Override public boolean onCreateOptionsMenu(Menu menu)&#123; MenuInflater menuInflater = new MenuInflater(getApplication()); menuInflater.inflate(R.menu.menu_main, menu); return super.onCreateOptionsMenu(menu); &#125; &#125; （4.2）XML定义ContextMenu 首先为ContextMenu注册菜单项 12colorText = (TextView)findViewById(R.id.textView);registerForContextMenu(colorText); 然后重载onCreateContextMenu即可： 123456@Overridepublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) &#123; super.onCreateContextMenu(menu, v, menuInfo); getMenuInflater().inflate(R.menu.menu_main, menu);&#125; 完整代码为： 123456789101112131415161718192021222324252627import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.ContextMenu;import android.view.View;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; private TextView colorText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); colorText = (TextView)findViewById(R.id.textView); registerForContextMenu(colorText); &#125; @Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) &#123; super.onCreateContextMenu(menu, v, menuInfo); getMenuInflater().inflate(R.menu.menu_main, menu); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"Menu","slug":"Menu","permalink":"http://blog.duanxu.tech/tags/Menu/"}]},{"title":"Android开发手记(11) 滑动条SeekBar","slug":"2015/2015-10-18-Android-Study-11-SeekBar","date":"2015-10-18T12:02:00.000Z","updated":"2018-12-07T12:53:55.155Z","comments":true,"path":"2015/10/18/2015/2015-10-18-Android-Study-11-SeekBar/","link":"","permalink":"http://blog.duanxu.tech/2015/10/18/2015/2015-10-18-Android-Study-11-SeekBar/","excerpt":"","text":"content{:toc} 安卓滑动条的操作特别简单，通过getProgress()可以获得SeekBar的位置，通过setProgress(int progress)可以设置SeekBar的位置。要想动态获取用户对SeekBar的操作的话，只需要设置setOnSeekBarChangeListener即可。 setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() 示例代码如下： 123456789101112131415161718192021222324252627282930313233343536import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.SeekBar;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; private SeekBar seekBar; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); seekBar = (SeekBar) findViewById(R.id.seekBar); textView = (TextView) findViewById(R.id.textView); seekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; @Override public void onProgressChanged(SeekBar seekBar, int i, boolean b) &#123; textView.setText(i + \" progress\"); &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; &#125; &#125;); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"SeekBar","slug":"SeekBar","permalink":"http://blog.duanxu.tech/tags/SeekBar/"}]},{"title":"Android开发手记(10) 下拉菜单Spinner","slug":"2015/2015-10-18-Android-Study-10-Spinner","date":"2015-10-18T09:18:00.000Z","updated":"2018-12-07T12:41:06.400Z","comments":true,"path":"2015/10/18/2015/2015-10-18-Android-Study-10-Spinner/","link":"","permalink":"http://blog.duanxu.tech/2015/10/18/2015/2015-10-18-Android-Study-10-Spinner/","excerpt":"","text":"content{:toc} 1、自定义Spinner 首先，定义Spinner要显示的项目列表/res/values/arrays.xml 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;string-array name=\"citys\"&gt; &lt;item&gt;南京&lt;/item&gt; &lt;item&gt;徐州&lt;/item&gt; &lt;item&gt;常州&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; 然后，定义一个ArrayAdapter并绑定到上面定义的项目列表。 123ArrayAdapter&lt;String&gt; adapter = ArrayAdapter.createFromResource( this, R.array.citys, android.R.layout.simple_spinner_item);adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); 其中，createFromResource()的函数原型为： createFromResource(Context context, int textArrayResId, int textViewResId); 然后，将adapter绑定到spinner： 1spinner.setAdapter(adapter); 最后，为spinner添加一个setOnItemSelectedListener即可： 123456789101112spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() &#123; @Override public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; Toast.makeText(MainActivity.this, \"position\" + i + spinner.getSelectedItem().toString(), Toast.LENGTH_SHORT).show(); &#125; @Override public void onNothingSelected(AdapterView&lt;?&gt; adapterView) &#123; Toast.makeText(MainActivity.this, \"unselected\", Toast.LENGTH_SHORT); &#125;&#125;); 完整代码为： 1234567891011121314151617181920212223242526272829303132public class MainActivity extends AppCompatActivity &#123; private Spinner spinner; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); spinner = (Spinner) findViewById(R.id.spinner); ArrayAdapter&lt;CharSequence&gt; adapter = ArrayAdapter.createFromResource( this, R.array.citys, android.R.layout.simple_spinner_item); adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item); spinner.setAdapter(adapter); spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() &#123; @Override public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; Toast.makeText(MainActivity.this, \"position\" + i + spinner.getSelectedItem().toString(), Toast.LENGTH_SHORT).show(); &#125; @Override public void onNothingSelected(AdapterView&lt;?&gt; adapterView) &#123; Toast.makeText(MainActivity.this, \"unselected\", Toast.LENGTH_SHORT); &#125; &#125;); &#125;&#125; 2、动态改变Spinner 想动态改变Spinner的内容，需要将Spinner的内容绑定到一个Adapter上。通过增加ArrayAdapter的内容来动态改变Spinner的内容。 12345ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_spinner_dropdown_item);adapter.add(\"南京\");adapter.add(\"徐州\");adapter.add(\"常州\");spinner.setAdapter(adapter); （2.1）增加一个项 通过在EditText输入需要增加的内容，之后单击一个Button来增加Spinner。为Button添加以下事件即可。 123456789101112131415161718btnAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; String city = editText.getText().toString(); for (int i = 0; i &lt; adapter.getCount(); i++) &#123; if (city.equals(adapter.getItem(i))) &#123; Toast.makeText(MainActivity.this, \"此城市已存在\", Toast.LENGTH_SHORT).show(); return; &#125; &#125; if (!city.trim().equals(\"\")) &#123; adapter.add(city); int pos = adapter.getPosition(city); spinner.setSelection(pos); editText.setText(\"\"); &#125; &#125;&#125;); （2.2）删除一个项 通过在Spinner选中需要删除的内容，之后单击一个Button来删除Spinner。为Button添加以下事件即可。 123456789101112btnDel.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (spinner.getSelectedItem() != null) &#123; adapter.remove(spinner.getSelectedItem().toString()); editText.setText(\"\"); if (adapter.getCount() == 0) &#123; Toast.makeText(MainActivity.this, \"列表为空\", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;&#125;); 3、完整代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.Button;import android.widget.EditText;import android.widget.Spinner;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; private Spinner spinner; private EditText editText; private Button btnAdd; private Button btnDel; private ArrayAdapter&lt;String&gt; adapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btnAdd = (Button) findViewById(R.id.btnAdd); btnDel = (Button) findViewById(R.id.btnDel); editText = (EditText) findViewById(R.id.editText); spinner = (Spinner) findViewById(R.id.spinner); adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_spinner_dropdown_item); adapter.add(\"南京\"); adapter.add(\"徐州\"); adapter.add(\"常州\"); spinner.setAdapter(adapter); btnAdd.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; String city = editText.getText().toString(); for (int i = 0; i &lt; adapter.getCount(); i++) &#123; if (city.equals(adapter.getItem(i))) &#123; Toast.makeText(MainActivity.this, \"此城市已存在\", Toast.LENGTH_SHORT).show(); return; &#125; &#125; if (!city.trim().equals(\"\")) &#123; adapter.add(city); int pos = adapter.getPosition(city); spinner.setSelection(pos); editText.setText(\"\"); &#125; &#125; &#125;); btnDel.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (spinner.getSelectedItem() != null) &#123; adapter.remove(spinner.getSelectedItem().toString()); editText.setText(\"\"); if (adapter.getCount() == 0) &#123; Toast.makeText(MainActivity.this, \"列表为空\", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; &#125;); spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() &#123; @Override public void onItemSelected(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; editText.setText(adapter.getItem(i)); &#125; @Override public void onNothingSelected(AdapterView&lt;?&gt; adapterView) &#123; &#125; &#125;); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"Spinner","slug":"Spinner","permalink":"http://blog.duanxu.tech/tags/Spinner/"}]},{"title":"Android学习手记(09) DatePickerDialog 和 TimePickerDialog","slug":"2015/2015-10-15-Android-Study-09-DatePickerDialog-and-TimePickerDialog","date":"2015-10-15T12:28:00.000Z","updated":"2018-12-07T12:40:53.733Z","comments":true,"path":"2015/10/15/2015/2015-10-15-Android-Study-09-DatePickerDialog-and-TimePickerDialog/","link":"","permalink":"http://blog.duanxu.tech/2015/10/15/2015/2015-10-15-Android-Study-09-DatePickerDialog-and-TimePickerDialog/","excerpt":"","text":"content{:toc} 1、DatePickerDialog 用于获取用户输入的日期信息。其原型为： public DatePickerDialog(Contex contex, DatePickerDialog.OnDateSetListener callback, int year, int month, int day); 其中，year,month,day是传递给DatePickerDialog的初始值信息，然后通过OnDateSetListener来设置用户选择的日期。 123456789DatePickerDialog dpDlg = new DatePickerDialog(MainActivity.this, new DatePickerDialog.OnDateSetListener() &#123; @Override public void onDateSet(DatePicker datePicker, int i, int i1, int i2) &#123; year = i; month = i1; day = i2; tvDate.setText(year + \"-\" + month + \"-\" + day); &#125; &#125;,year,month,day); 完整代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import android.app.DatePickerDialog;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.DatePicker;import android.widget.TextView;import java.util.Calendar;import java.util.Date;import java.util.Locale;public class MainActivity extends AppCompatActivity &#123; private TextView tvDate; private Button btnDateDlg; private int year; private int month; private int day; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tvDate = (TextView) findViewById(R.id.textView); btnDateDlg = (Button) findViewById(R.id.button); Calendar myCalendar = Calendar.getInstance(Locale.CHINA); Date date = new Date(); myCalendar.setTime(date); year = myCalendar.get(Calendar.YEAR); month = myCalendar.get(Calendar.MONTH); day = myCalendar.get(Calendar.DAY_OF_MONTH); tvDate.setText(year + \"-\" + month + \"-\" + day); btnDateDlg.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; DatePickerDialog dpDlg = new DatePickerDialog(MainActivity.this, new DatePickerDialog.OnDateSetListener() &#123; @Override public void onDateSet(DatePicker datePicker, int i, int i1, int i2) &#123; year = i; month = i1; day = i2; tvDate.setText(year + \"-\" + month + \"-\" + day); &#125; &#125;,year,month,day); dpDlg.show(); &#125; &#125;); &#125;&#125; 2、TimePickerDialog 用于获取用户输入的日期信息。其原型为： public TimePickerDialog(Contex contex, TimePickerDialog.OnTimeSetListener callback, int hour, int minute, boolean is24Hours); 其中，hour,minute是传递给TimePickerDialog的初始值信息，is24Hours表示是否为24小时制，然后通过OnTimeSetListener来设置用户选择的日期。 123456789TimePickerDialog tpDlg = new TimePickerDialog(MainActivity.this, new TimePickerDialog.OnTimeSetListener() &#123; @Override public void onTimeSet(TimePicker timePicker, int i, int i1) &#123; hour = i; minute = i1; tvTime.setText(year + \"-\" + month + \"-\" + day + \" \" + hour + \":\" + minute); &#125; &#125;,hour, minute,true); tpDlg.show(); 完整代码为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import android.app.TimePickerDialog;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;import android.widget.TimePicker;import java.util.Calendar;import java.util.Date;import java.util.Locale;public class MainActivity extends AppCompatActivity &#123; private TextView tvTime; private Button btnTimeDlg; private int year; private int month; private int day; private int hour; private int minute; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tvTime = (TextView) findViewById(R.id.textView); btnTimeDlg = (Button) findViewById(R.id.button); Calendar myCalendar = Calendar.getInstance(Locale.CHINA); Date date = new Date(); myCalendar.setTime(date); year = myCalendar.get(Calendar.YEAR); month = myCalendar.get(Calendar.MONTH); day = myCalendar.get(Calendar.DAY_OF_MONTH); hour = myCalendar.get(Calendar.HOUR); minute = myCalendar.get(Calendar.MINUTE); tvTime.setText(year + \"-\" + month + \"-\" + day + \" \" + hour + \":\" + minute); btnTimeDlg.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; TimePickerDialog tpDlg = new TimePickerDialog(MainActivity.this, new TimePickerDialog.OnTimeSetListener() &#123; @Override public void onTimeSet(TimePicker timePicker, int i, int i1) &#123; hour = i; minute = i1; tvTime.setText(year + \"-\" + month + \"-\" + day + \" \" + hour + \":\" + minute); &#125; &#125;,hour, minute,true); tpDlg.show(); &#125; &#125;); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"DatePickerDialog","slug":"DatePickerDialog","permalink":"http://blog.duanxu.tech/tags/DatePickerDialog/"},{"name":"TimePickerDialog","slug":"TimePickerDialog","permalink":"http://blog.duanxu.tech/tags/TimePickerDialog/"}]},{"title":"Android学习手记(08) ProgressDialog的使用","slug":"2015/2015-10-15-Android-Study-08-ProgressDialog","date":"2015-10-15T11:15:00.000Z","updated":"2018-12-07T12:40:38.387Z","comments":true,"path":"2015/10/15/2015/2015-10-15-Android-Study-08-ProgressDialog/","link":"","permalink":"http://blog.duanxu.tech/2015/10/15/2015/2015-10-15-Android-Study-08-ProgressDialog/","excerpt":"","text":"content{:toc} ProgressDialog，进度对话框。一般有两种，一种是圆形的进度条(ProgressDialog.STYLE_SPINNER)，另一种是长条形的进度条(ProgressDialog.STYLE_HORIZONTAL)。 ProgressDialog常用的方法有以下几种： 1234567891011121314151617progressDialog = new ProgressDialog(MainActivity.this); // 新建一个ProgressDialogprogressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); // 设置ProgressDialog的样式progressDialog.setTitle(\"Note:\"); // 设置标题progressDialog.setMessage(\"这是一个水平进度条\"); // 设置显示内容progressDialog.setIndeterminate(false); // 是否是不确定状态progressDialog.setCancelable(true); // 是否可以取消progressDialog.setProgress(0); // 设置初始进度progressDialog.setMax(200); // 设置最大进度progressDialog.setSecondaryProgress(100); // 设置第二进度（可用于缓冲显示）progressDialog.setButton(DialogInterface.BUTTON_POSITIVE, \"OK\", new DialogInterface.OnClickListener() &#123; @Override // 设置按钮 public void onClick(DialogInterface dialogInterface, int i) &#123; // DialogInterface表示按钮位置 progressDialog.cancel(); // BUTTON_POSITIVE 为最右边 &#125; // BUTTON_NEUTRAL 为在中间&#125;); // BUTTON_NEGATIVE 为最左边progressDialog.show(); // 显示ProgressDialog 1、圆形进度条1234567891011121314151617181920212223242526btnCricleDlg = (Button)findViewById(R.id.btnCircleDlg);btnCricleDlg.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; progressDialog = new ProgressDialog(MainActivity.this); progressDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER); progressDialog.setTitle(\"Note:\"); progressDialog.setMessage(\"这是一个圆形进度条\"); progressDialog.setIndeterminate(false); progressDialog.setCancelable(true); progressDialog.setButton(DialogInterface.BUTTON_POSITIVE, \"OK\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int witch) &#123; progressDialog.cancel(); &#125; &#125;); progressDialog.setButton(DialogInterface.BUTTON_NEGATIVE,\"CANCEL\",new DialogInterface.OnClickListener()&#123; @Override public void onClick(DialogInterface dialog, int witch)&#123; progressDialog.cancel(); &#125; &#125;); progressDialog.show(); &#125;&#125;); 2、长形进度条1234567891011121314151617181920212223242526272829303132333435363738btnLongDlg = (Button) findViewById(R.id.btnLongDlg);btnLongDlg.setOnClickListener(new View.OnClickListener() &#123; int count = 0; @Override public void onClick(View view) &#123; progressDialog = new ProgressDialog(MainActivity.this); // 新建一个ProgressDialog progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); // 设置ProgressDialog的样式 progressDialog.setTitle(\"Note:\"); // 设置标题 progressDialog.setMessage(\"这是一个水平进度条\"); // 设置显示内容 progressDialog.setIndeterminate(false); // 是否是不确定状态 progressDialog.setCancelable(true); // 是否可以取消 progressDialog.setProgress(0); // 设置初始进度 progressDialog.setMax(200); // 设置最大进度 progressDialog.setSecondaryProgress(100); // 设置第二进度（可用于缓冲显示） progressDialog.setButton(DialogInterface.BUTTON_POSITIVE, \"OK\", new DialogInterface.OnClickListener() &#123; @Override // 设置按钮 public void onClick(DialogInterface dialogInterface, int i) &#123; // DialogInterface表示按钮位置 progressDialog.cancel(); // BUTTON_POSITIVE 为最右边 &#125; // BUTTON_NEUTRAL 为在中间 &#125;); // BUTTON_NEGATIVE 为最左边 progressDialog.show(); // 显示ProgressDialog new Thread()&#123; public void run()&#123; while(count&lt;=200)&#123; try&#123; Thread.sleep(100); progressDialog.incrementProgressBy(1); &#125;catch(Exception e)&#123; &#125; &#125; &#125; &#125;.start(); &#125;&#125;); 3、完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import android.app.ProgressDialog;import android.content.DialogInterface;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;public class MainActivity extends AppCompatActivity &#123; private Button btnCricleDlg; private Button btnLongDlg; private ProgressDialog progressDialog; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btnCricleDlg = (Button)findViewById(R.id.btnCircleDlg); btnLongDlg = (Button) findViewById(R.id.btnLongDlg); btnCricleDlg.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; progressDialog = new ProgressDialog(MainActivity.this); progressDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER); progressDialog.setTitle(\"Note:\"); progressDialog.setMessage(\"这是一个圆形进度条\"); progressDialog.setIndeterminate(false); progressDialog.setCancelable(true); progressDialog.setButton(DialogInterface.BUTTON_POSITIVE, \"OK\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int witch) &#123; progressDialog.cancel(); &#125; &#125;); progressDialog.setButton(DialogInterface.BUTTON_NEGATIVE,\"CANCEL\",new DialogInterface.OnClickListener()&#123; @Override public void onClick(DialogInterface dialog, int witch)&#123; progressDialog.cancel(); &#125; &#125;); progressDialog.show(); &#125; &#125;); btnLongDlg.setOnClickListener(new View.OnClickListener() &#123; int count = 0; @Override public void onClick(View view) &#123; progressDialog = new ProgressDialog(MainActivity.this); // 新建一个ProgressDialog progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); // 设置ProgressDialog的样式 progressDialog.setTitle(\"Note:\"); // 设置标题 progressDialog.setMessage(\"这是一个水平进度条\"); // 设置显示内容 progressDialog.setIndeterminate(false); // 是否是不确定状态 progressDialog.setCancelable(true); // 是否可以取消 progressDialog.setProgress(0); // 设置初始进度 progressDialog.setMax(200); // 设置最大进度 progressDialog.setSecondaryProgress(100); // 设置第二进度（可用于缓冲显示） progressDialog.setButton(DialogInterface.BUTTON_POSITIVE, \"OK\", new DialogInterface.OnClickListener() &#123; @Override // 设置按钮 public void onClick(DialogInterface dialogInterface, int i) &#123; // DialogInterface表示按钮位置 progressDialog.cancel(); // BUTTON_POSITIVE 为最右边 &#125; // BUTTON_NEUTRAL 为在中间 &#125;); // BUTTON_NEGATIVE 为最左边 progressDialog.show(); // 显示ProgressDialog new Thread()&#123; public void run()&#123; while(count&lt;=200)&#123; try&#123; Thread.sleep(100); progressDialog.incrementProgressBy(1); &#125;catch(Exception e)&#123; &#125; &#125; &#125; &#125;.start(); &#125; &#125;); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"ProgressDialog","slug":"ProgressDialog","permalink":"http://blog.duanxu.tech/tags/ProgressDialog/"}]},{"title":"Android学习手记(07) 按钮类控件的使用","slug":"2015/2015-10-14-Android-Study-07-Button","date":"2015-10-14T11:48:00.000Z","updated":"2018-12-07T12:40:35.107Z","comments":true,"path":"2015/10/14/2015/2015-10-14-Android-Study-07-Button/","link":"","permalink":"http://blog.duanxu.tech/2015/10/14/2015/2015-10-14-Android-Study-07-Button/","excerpt":"","text":"content{:toc} 1、点击Button改变页面背景色 通过Button改变页面背景色，首先新建相应的对象，让后绑定到Layout上的元素。 final RelativeLayout layout = (RelativeLayout)this.findViewById(R.id.layout); final Button btnRed = (Button)this.findViewById(R.id.btnRed); 然后向新建的按钮增加单机事件。 1234567btnRed.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; layout.setBackgroundColor(Color.RED); ((Button)view).setText(\"Is Red\"); &#125;&#125;); 完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); this.setTitle(\"Button\"); setContentView(R.layout.activity_main); final RelativeLayout layout = (RelativeLayout)this.findViewById(R.id.layout); final Button btnRed = (Button)this.findViewById(R.id.btnRed); final Button btnGreen = (Button)this.findViewById(R.id.btnGreen); final Button btnBlue = (Button)this.findViewById(R.id.btnBlue); btnRed.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; btnGreen.setText(\"Green\"); btnBlue.setText(\"Blue\"); layout.setBackgroundColor(Color.RED); ((Button)view).setText(\"Is Red\"); &#125; &#125;); btnGreen.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; btnRed.setText(\"Red\"); btnBlue.setText(\"Blue\"); layout.setBackgroundColor(Color.GREEN); ((Button)view).setText(\"Is Green\"); &#125; &#125;); btnBlue.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; btnRed.setText(\"Red\"); btnGreen.setText(\"Green\"); layout.setBackgroundColor(Color.BLUE); ((Button)view).setText(\"Is Blue\"); &#125; &#125;); &#125;&#125; 2、CheckBox状态获取 要获取CheckBox状态，只需要设置OnCheckedChangeListener()即可。 123456789CheckBox chkBox = (CheckBox) findViewById(R.id.chkFootball);chkFootball.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton compoundButton, boolean b) &#123; if (b) strFootball = \"Football\"; else strFootball = \"\"; tvResult.setText(strFootball + \" \" + strBasketball); &#125;&#125;); 完整代码为： 12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends AppCompatActivity &#123; private String strFootball = \"\"; private String strBasketball = \"\"; private TextView tvResult ; private CheckBox chkFootball; private CheckBox chkBasketball; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState);// this.setTitle(\"Button\"); setContentView(R.layout.activity_main); tvResult = (TextView) findViewById(R.id.tvResult); chkFootball = (CheckBox) findViewById(R.id.chkFootball); chkBasketball = (CheckBox) findViewById((R.id.chkBasketball)); chkFootball.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton compoundButton, boolean b) &#123; if (b) strFootball = \"Football\"; else strFootball = \"\"; tvResult.setText(strFootball + \" \" + strBasketball); &#125; &#125;); chkBasketball.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton compoundButton, boolean b) &#123; if (b) strBasketball = \"Basketball\"; else strBasketball = \"\"; tvResult.setText(strFootball + \" \" + strBasketball); &#125; &#125;); &#125;&#125; 3、RadioButton与RadioGroup 要获取RadioGroup内RadioButton的选择状态，为RadioGroup添加选择事件即可。 123456rGroup.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(RadioGroup radioGroup, int i) &#123; // TODO &#125;&#125;); 首先在RadioGroup内创建两个RadioButton: 1234567891011121314151617181920212223&lt;RadioGroup android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_below=\"@+id/textView\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:id=\"@+id/rGroup\"&gt; &lt;RadioButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"男\" android:id=\"@+id/rbMale\" android:checked=\"false\" /&gt; &lt;RadioButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"女\" android:id=\"@+id/rbFemale\" android:checked=\"false\" /&gt; &lt;/RadioGroup&gt; 然后，为RadioGroup设置OnCheckedChangeListener() 1234567891011rGroup.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(RadioGroup radioGroup, int i) &#123; if(i==rbMale.getId()) &#123; result.setText(\"你的性别是：男\"); &#125; else if(i==rbFemale.getId())&#123; result.setText(\"你的性别是：女\"); &#125; &#125;&#125;); 完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.widget.CheckBox;import android.widget.CompoundButton;import android.widget.RadioButton;import android.widget.RadioGroup;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; private TextView result; private RadioButton rbMale; private RadioButton rbFemale; private RadioGroup rGroup; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState);// this.setTitle(\"Button\"); setContentView(R.layout.activity_main); result = (TextView)findViewById(R.id.textView); rbMale = (RadioButton)findViewById(R.id.rbMale); rbFemale = (RadioButton)findViewById(R.id.rbFemale); rGroup = (RadioGroup)findViewById(R.id.rGroup); rGroup.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(RadioGroup radioGroup, int i) &#123; if(i==rbMale.getId()) &#123; result.setText(\"你的性别是：男\"); &#125; else if(i==rbFemale.getId())&#123; result.setText(\"你的性别是：女\"); &#125; &#125; &#125;); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"Button","slug":"Button","permalink":"http://blog.duanxu.tech/tags/Button/"}]},{"title":"Android学习手记(06) TabActivity和TabHost","slug":"2015/2015-10-11-Android-Study-06-TabActivity-and-TabHost","date":"2015-10-12T14:04:00.000Z","updated":"2018-12-07T12:40:18.161Z","comments":true,"path":"2015/10/12/2015/2015-10-11-Android-Study-06-TabActivity-and-TabHost/","link":"","permalink":"http://blog.duanxu.tech/2015/10/12/2015/2015-10-11-Android-Study-06-TabActivity-and-TabHost/","excerpt":"","text":"content{:toc} 使用TabHost可以实现标签式效果，将两个Activity放在两个Tab内。 首先，需要基于MainActivity创建一个TabHost对象。 TabHost tabHost = this.getTabHost(); 通过 TabHost.addTab() 可以创建一个新Tab。 TabHost.addTab(tabHost.newTabSpec(“tab1”).setIndicator(“Sign In”).setContent(new Intent(this, SignIn.class))); 其中，newTabSpec() 设置新建Tab名称。setIndicator(“”) 设置新建标签的内容。setContent()设置Tab的内容。 首先，新建两个Activity，分别命名为“SignIn“和”SignUp“。 然后在MainActivity中加入如下代码，即可实现下图所示功能。 MainActivity.java 123456789101112public class MainActivity extends TabActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); this.setTitle(\"TabActivity\"); TabHost tabHost = this.getTabHost(); tabHost.addTab(tabHost.newTabSpec(\"tab1\").setIndicator(\"Sign In\").setContent(new Intent(this, SignIn.class))); tabHost.addTab(tabHost.newTabSpec(\"tab2\").setIndicator(\"Sign Up\").setContent(new Intent(this, SignUp.class))); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"TabActivity","slug":"TabActivity","permalink":"http://blog.duanxu.tech/tags/TabActivity/"},{"name":"TabHost","slug":"TabHost","permalink":"http://blog.duanxu.tech/tags/TabHost/"}]},{"title":"Android 学习笔记(05) 基本UI布局","slug":"2015/2015-10-11-Android-Study-05-Basic-UI-Layout","date":"2015-10-11T12:50:00.000Z","updated":"2018-12-07T12:39:58.527Z","comments":true,"path":"2015/10/11/2015/2015-10-11-Android-Study-05-Basic-UI-Layout/","link":"","permalink":"http://blog.duanxu.tech/2015/10/11/2015/2015-10-11-Android-Study-05-Basic-UI-Layout/","excerpt":"","text":"content{:toc} 1、View和ViewGroupActivity是Android应用程序的基本管理单元，Android的每一个窗口都是通过一个Activity来定义的，但是Activity并不能直接用来显示窗口。我们需要调用setContentView(View view)来显示这个窗口。也就是说，真正用来显示窗口的是View类及其子类。 View主要负责绘制元素和事件处理，提供了许多用于绘制界面的子类。比如Button类，TextView类，EditText类等等。我们可以通过这些子类控件来进行一些简单的界面绘制。 ViewGroup是View的子类，主要作用是容纳其他元素。ViewGroup是一个抽象类，所以容纳其他元素充当一个容器的任务实际上是通过其子类完成的。比如FrameLayout类、LinearLayout类、AbsoluteLayout类、RelativeLayout类、TableLayout类、GridLayout类等等。 // Android APIsViewGroupextends Viewimplements ViewParent ViewManager java.lang.Object ↳ android.view.View ↳ android.view.ViewGroup Known Direct Subclasses：AbsoluteLayout, AdapterView, CoordinatorLayout, DrawerLayout, FragmentBreadCrumbs, FrameLayout, GridLayout, LinearLayout, LinearLayoutCompat, PagerTitleStrip, RecyclerView, RelativeLayout, ShadowOverlayContainer, SlidingDrawer, SlidingPaneLayout, SwipeRefreshLayout, Toolbar, TvView, ViewPager Known Indirect Subclasses:AbsListView, AbsSpinner, ActionMenuView, AdapterViewAnimator, AdapterViewFlipper, AppBarLayout, AppCompatSpinner, AppWidgetHostView, BaseCardView, BrowseFrameLayout, and 43 others. 2、普通布局A. FrameLayoutFrameLayout，框架布局。是一种最简单的布局类型，将所有的组件固定在界面的左上角，叠加显示，后一个组件在前一个组件之上显示。也就是说，后一个组件可能会覆盖前一个组件。 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" android:paddingBottom=\"@dimen/activity_vertical_margin\" tools:context=\".MainActivity\"&gt; &lt;TextView android:text=\"Hello World!\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;TextView android:text=\"Hello Android!\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt;&lt;/FrameLayout&gt; B. LinearLayoutLinearLayout，线性布局。所有的组件按照一个方向放置，其方向通过android:orientation=”horizontal”来控制，这个是水平放置组件，我们可以把horizonal改写为vertical，从而实现组件的竖直放置。 1234&lt;LinearLayout android:orientation=\"horizontal\"&gt; &lt;!-- 组件 --&gt;&lt;/LinearLayout&gt; 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" android:paddingBottom=\"@dimen/activity_vertical_margin\" tools:context=\".MainActivity\" android:orientation=\"horizontal\"&gt; &lt;TextView android:text=\"Hello World!\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;TextView android:text=\"Hello Android!\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt;&lt;/LinearLayout&gt; C. AbsoluteLayoutAbsoluteLayout，绝对布局。这是一种不推荐的方式，因为其组件位置由左上角为坐标原点定义，当屏幕尺寸变化时，不能良好适应屏幕的显示需求，可能因为坐标问题在屏幕外面显示，从而用户无法对其操作。 123456&lt;AbsoluteLayout&gt; &lt;Button android:text=\"Hello Android!\" &lt;!-- 其他代码 --&gt; android:layout_x=\"100px\" android:layout_y=\"100px\"/&gt;&lt;/AbsoluteLayout&gt; 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;AbsoluteLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" android:paddingBottom=\"@dimen/activity_vertical_margin\" tools:context=\".MainActivity\"&gt; &lt;TextView android:text=\"Hello World!\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_x=\"600px\" android:layout_y=\"50px\"/&gt; &lt;TextView android:text=\"Hello Android!\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_x=\"100px\" android:layout_y=\"100px\"/&gt;&lt;/AbsoluteLayout&gt; D. RelativeLayoutRelativeLayout，相对布局。放置在相对布局上的组件可以设置其相对于子元素或者父元素的位置。通过指定相对父元素的位置来实现定位。 123456789101112131415&lt;RelativeLayout android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" android:paddingBottom=\"@dimen/activity_vertical_margin\"&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"OK\" android:id=\"@+id/button\" android:layout_below=\"@+id/radioFalse\" &lt;!-- 指定在父元素下方 --&gt; android:layout_alignParentRight=\"true\" &lt;!-- 右端与父窗体右端对齐 --&gt; android:layout_alignParentEnd=\"true\" /&gt; &lt;!-- 下端与父窗体末尾对齐 --&gt;&lt;/RelativeLayout&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" android:paddingBottom=\"@dimen/activity_vertical_margin\" tools:context=\".MainActivity\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Is that right?\" android:id=\"@+id/textView\" android:textSize=\"50px\" android:layout_alignParentTop=\"true\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" /&gt; &lt;RadioButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"True\" android:id=\"@+id/radioTrue\" android:layout_below=\"@+id/textView\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:checked=\"true\" /&gt; &lt;RadioButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"False\" android:id=\"@+id/radioFalse\" android:layout_below=\"@+id/radioTrue\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:checked=\"false\" /&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"OK\" android:id=\"@+id/button\" android:layout_below=\"@+id/radioFalse\" android:layout_alignParentRight=\"true\" android:layout_alignParentEnd=\"true\" /&gt;&lt;/RelativeLayout&gt; E. GridLayoutGridLayout，网格布局。这种布局把子视图存放在一个矩形网格中。网格是由被无数虚细线分割成多个单元格的可视区域组成。贯穿整个API的网格线通过网格索引数来指定。 1234567891011&lt;GridLayout &lt;!-- 其他代码省略 --&gt; android:orientation=\"horizontal\" android:columnCount=\"4\" &lt;!-- Grid列数 --&gt; android:rowCount=\"5\"&gt; &lt;!-- Grid行数 --&gt; &lt;Button android:layout_columnSpan=\"2\" &lt;!-- 指定占用列数 --&gt; android:layout_rowSpan=\"2\" &lt;!-- 指定占用行数 --&gt; android:layout_gravity=\"fill\"/&gt; &lt;!-- 相对父View的位置 --&gt; /GridLayout&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;GridLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:columnCount=\"4\" android:orientation=\"horizontal\" android:paddingEnd=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" android:rowCount=\"5\"&gt; &lt;Button android:id=\"@+id/one\" android:text=\"1\" /&gt; &lt;Button android:id=\"@+id/two\" android:text=\"2\" /&gt; &lt;Button android:id=\"@+id/three\" android:text=\"3\" /&gt; &lt;Button android:id=\"@+id/devide\" android:text=\"/\" /&gt; &lt;Button android:id=\"@+id/four\" android:text=\"4\" /&gt; &lt;Button android:id=\"@+id/five\" android:text=\"5\" /&gt; &lt;Button android:id=\"@+id/six\" android:text=\"6\" /&gt; &lt;Button android:id=\"@+id/multiply\" android:text=\"×\" /&gt; &lt;Button android:id=\"@+id/seven\" android:text=\"7\" /&gt; &lt;Button android:id=\"@+id/eight\" android:text=\"8\" /&gt; &lt;Button android:id=\"@+id/nine\" android:text=\"9\" /&gt; &lt;Button android:id=\"@+id/minus\" android:text=\"-\" /&gt; &lt;Button android:id=\"@+id/zero\" android:layout_columnSpan=\"2\" android:layout_gravity=\"fill\" android:text=\"0\" /&gt; &lt;Button android:id=\"@+id/point\" android:text=\".\" /&gt; &lt;Button android:id=\"@+id/plus\" android:layout_gravity=\"fill\" android:layout_rowSpan=\"2\" android:text=\"+\" /&gt; &lt;Button android:id=\"@+id/equal\" android:layout_columnSpan=\"3\" android:layout_gravity=\"fill\" android:text=\"=\" /&gt;&lt;/GridLayout&gt; 3、总结以上就是几种布局的基本方法，其中包括FrameLayout、LinearLayout、AbsoluteLayout、RelativeLayout、GridLayout。使用过程中应该灵活使用，加上布局嵌套之类的。","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"UI-Layout","slug":"UI-Layout","permalink":"http://blog.duanxu.tech/tags/UI-Layout/"}]},{"title":"Android 学习笔记(04) BroadcastReceiver监听电池信息","slug":"2015/2015-10-10-Android-Study-04-BroadcastReceiver","date":"2015-10-10T08:47:00.000Z","updated":"2018-12-07T12:39:36.111Z","comments":true,"path":"2015/10/10/2015/2015-10-10-Android-Study-04-BroadcastReceiver/","link":"","permalink":"http://blog.duanxu.tech/2015/10/10/2015/2015-10-10-Android-Study-04-BroadcastReceiver/","excerpt":"","text":"content{:toc} 在Android 中，Broadcast是一种在应用程序之间进行传输信息的机制。BroadcastReceiver对发送过来的Broadcast进行过滤和响应。根据这种机制，我们可以获取电池现有电量等信息。 1、实例化BroadcastReceiver 在接受信息的时候，可以通过intent.getAction().equals(Intent.ACTION_BATTERY_CHANGED)来判断接收的信息是否为电池电量变化信息。如果是，就获取此信息的详细情况。 12345678910private BroadcastReceiver batteryInfoReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; if(intent.getAction().equals(Intent.ACTION_BATTERY_CHANGED))&#123; int level = intent.getIntExtra(\"level\", 0); int scale = intent.getIntExtra(\"scale\", 100); batteryView.setText(\"BatteryLevel \" + String.valueOf(level*100/scale)+\"%\"); &#125; &#125; &#125;; 2、注册消息接收器 在onResume方法内注册消息接收器用来接收消息 registerReceiver(batteryInfoReceiver, new IntentFilter(Intent.ACTION_BATTERY_CHANGED)); 3、注销消息接收器 在onPause方法内注销消息接收器 unregisterReceiver(batteryInfoReceiver); 4、完整代码12345678910111213141516171819202122232425262728293031323334public class MainActivity extends AppCompatActivity &#123; private TextView batteryView; private BroadcastReceiver batteryInfoReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; if(intent.getAction().equals(Intent.ACTION_BATTERY_CHANGED))&#123; int level = intent.getIntExtra(\"level\", 0); int scale = intent.getIntExtra(\"scale\", 100); batteryView.setText(\"BatteryLevel \" + String.valueOf(level*100/scale)+\"%\"); &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); batteryView = (TextView) this.findViewById(R.id.batteryView); &#125; @Override protected void onResume()&#123; super.onResume(); registerReceiver(batteryInfoReceiver, new IntentFilter(Intent.ACTION_BATTERY_CHANGED)); &#125; @Override protected void onPause()&#123; super.onPause(); unregisterReceiver(batteryInfoReceiver); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"BroadcastReceiver","slug":"BroadcastReceiver","permalink":"http://blog.duanxu.tech/tags/BroadcastReceiver/"}]},{"title":"Android 学习笔记(03) Activity 间传递数据","slug":"2015/2015-10-08-Android-Study-03-Activity-Data-Transfer","date":"2015-10-08T12:17:00.000Z","updated":"2018-12-07T12:39:33.860Z","comments":true,"path":"2015/10/08/2015/2015-10-08-Android-Study-03-Activity-Data-Transfer/","link":"","permalink":"http://blog.duanxu.tech/2015/10/08/2015/2015-10-08-Android-Study-03-Activity-Data-Transfer/","excerpt":"","text":"content{:toc} 1. 简单数据传递建立两个Activity，名称分别为MainActivity和TheAty，在MainActivity中新建一个Button，id为btnStartAty。在TheAty中新建一个TextView，id为tv。分别加入如下代码： MainActivity.java12345678910111213141516171819202122 public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button)findViewById(R.id.btnStartAty); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent i = new Intent(); i.setClass(MainActivity.this, TheAty.class); i.putExtra(\"data\", \"hello android\"); startActivity(i); &#125; &#125;); &#125;&#125; TheAty.java123456789101112131415public class TheAty extends AppCompatActivity &#123; private TextView textv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_the_aty); Intent i = getIntent(); textv = (TextView)findViewById(R.id.tv); textv.setText(i.getStringExtra(\"data\")); &#125;&#125; 其中，Intent i 的作用是作为绑定两个Activity的中介，然后进行string的传递。使用putExtra()的getStringExtra()函数对来实现简单值的传递。 2. 使用Bundle传递数据MainActivity.java1234567891011121314151617181920212223242526272829 public class MainActivity extends AppCompatActivity &#123; private EditText myText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); myText = (EditText)findViewById(R.id.editText); Button button = (Button) findViewById(R.id.btnOK); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String str = myText.getText().toString(); Intent i = new Intent(MainActivity.this, TheAty.class); Bundle bundle = new Bundle(); bundle.putString(\"message\", str); i.putExtras(bundle); startActivity(i); &#125; &#125;); &#125;&#125; TheAty.java1234567891011121314 public class TheAty extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_the_aty); Bundle bundle = this.getIntent().getExtras(); String mesg = bundle.getString(\"message\"); TextView myText = (TextView) findViewById(R.id.tv); myText.setText(mesg); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"Activity","slug":"Activity","permalink":"http://blog.duanxu.tech/tags/Activity/"}]},{"title":"Android 学习笔记(02) Activity 生命周期","slug":"2015/2015-10-07-Android-Study-02-Activity-Life","date":"2015-10-07T08:26:00.000Z","updated":"2018-12-07T12:39:32.669Z","comments":true,"path":"2015/10/07/2015/2015-10-07-Android-Study-02-Activity-Life/","link":"","permalink":"http://blog.duanxu.tech/2015/10/07/2015/2015-10-07-Android-Study-02-Activity-Life/","excerpt":"","text":"content{:toc} 1. 单个Activity的生命周期当只有一个Activity的时候， 首先执行onCreate-&gt;onStart-&gt;onResume。 这时， 窗口便显示在屏幕上了。 然后我们按返回键退到桌面的时候，便执行onPause-&gt;onStop。这时候， 如果我们在最近使用程序列表内将其再次打开，便会执行onRestart-&gt;onStart-&gt;onResume。 2. 多个Activity相互跳转首先执行A.onCreate-&gt;A.onStart-&gt;A.onResume， 此时屏幕显示Activity A， 通过A来调用显示Activity B的时候，首先执行A.onPause， 然后执行B.onCreate-&gt;B.onStart-&gt;B.onResume， 在B显示之后执行A.onStop。之后按返回键返回到 A， 需要首先暂停窗口B，即执行 B.onPause， 但是需要指出的是， 这个时候在暂停B之后紧接着执行的是 A.onResume， 之后才会执行B的销毁程序 B.onStop-&gt;B.onDestroy。 3. 当B是对话框的时候(不能完全遮挡A)此时，因为B没有完全遮挡A， 只需要执行A.onPause即可， 不需要执行 A.onStop。其他的过程与2相同。","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"Activity","slug":"Activity","permalink":"http://blog.duanxu.tech/tags/Activity/"}]},{"title":"Android 学习笔记(01) Activity 跳转","slug":"2015/2015-10-07-Android-Study-01-Activity-Jump","date":"2015-10-07T06:57:00.000Z","updated":"2018-12-07T12:39:31.828Z","comments":true,"path":"2015/10/07/2015/2015-10-07-Android-Study-01-Activity-Jump/","link":"","permalink":"http://blog.duanxu.tech/2015/10/07/2015/2015-10-07-Android-Study-01-Activity-Jump/","excerpt":"","text":"content{:toc} 1. 新建Project，并将主页命名为MainActivity2. 创建一个Activity在App上“右键-&gt;New-&gt;Activity-&gt;Empty Activity”， 将新建的Activity命名为AnotherAty。 3. 在MainActivity上添加一个按钮，并设置 id 和 text 属性打开”activity_main.xml”， 添加如下代码： 12345678&lt;Buttonandroid:layout_width=\"wrap_content\"android:layout_height=\"wrap_content\"android:text=\"Another Activity\"android:id=\"@+id/btnStartAnotherAty\"android:layout_below=\"@+id/textView\"android:layout_alignParentLeft=\"true\"android:layout_alignParentStart=\"true\" /&gt; 4. 为按钮添加行为打开“MainActivity.java”，在OnCreate方法内添加： 123456findViewById(R.id.btnStartAnotherAty).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(MainActivity.this,AnotherAty.class)); &#125;&#125;); 这是完整代码: 123456789101112131415public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.btnStartAnotherAty).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(MainActivity.this,AnotherAty.class)); &#125; &#125;); &#125;&#125; 这样就实现了单击MainActivity中的Button跳转到AnotherAty的功能。","categories":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://blog.duanxu.tech/tags/Android/"},{"name":"Activity","slug":"Activity","permalink":"http://blog.duanxu.tech/tags/Activity/"}]}]}